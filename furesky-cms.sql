-- MySQL dump 10.13  Distrib 5.7.26, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: furesky-cms
-- ------------------------------------------------------
-- Server version	5.7.26

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article_info`
--

DROP TABLE IF EXISTS `article_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_info` (
  `article_id` bigint(20) NOT NULL,
  `title` varchar(128) NOT NULL,
  `author` varchar(64) NOT NULL,
  `summary` varchar(255) NOT NULL,
  `content` longtext NOT NULL,
  `state` int(4) NOT NULL,
  `catalog_id` bigint(20) NOT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`article_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_info`
--

LOCK TABLES `article_info` WRITE;
/*!40000 ALTER TABLE `article_info` DISABLE KEYS */;
INSERT INTO `article_info` VALUES (284572325780549632,'<h1>概述</h1>','sys','待编辑','<p>MyBatis 是一款优秀的轻量级持久层框架，它支持定制化 SQL、存储过程以及高级映射</p>\n\n<ul>\n	<li>SQL语句与代码分离。</li>\n	<li>面向配置编程（AOP思想）。</li>\n	<li>良好支持复杂数据的映射。</li>\n	<li>采用动态SQL替换了SQL语句的拼装，降低SQL注入的风险，增强了安全性。</li>\n</ul>\n',0,284570045819809792,'2019-05-07 04:44:32','2019-05-07 04:44:32'),(284587568749506560,'<h1>入门示例</h1>','sys','待编辑','<p>1、maven依赖：pom.xml</p>\n\n<pre><code class=\"language-xml\">&lt;!-- mybatis核心包 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n    &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- mysql --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2、数据库配置：jdbc.properties</p>\n\n<pre><code>jdbc.type=mysql\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8\njdbc.username=root\njdbc.password=root</code></pre>\n\n<p>&nbsp;</p>\n\n<p>3、mybatis配置：mybatis-config.xml</p>\n\n<pre><code class=\"language-xml\">&lt;?xml  version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n\n&lt;configuration&gt;\n    &lt;!-- 引入外部配置文件 --&gt;\n    &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt;\n   \n    &lt;!-- 配置mybatis运行环境,可配置多个环境 --&gt;\n    &lt;environments default=\"development\"&gt;\n        &lt;environment id=\"development\"&gt;\n            &lt;!-- type=\"JDBC\" 代表使用JDBC的提交和回滚来管理事务 --&gt;\n            &lt;transactionManager type=\"JDBC\" /&gt;\n            \n            &lt;!-- 配置数据源 --&gt;            \n            &lt;dataSource type=\"POOLED\"&gt;\n                &lt;property name=\"driver\" value=\"${jdbc.driver}\" /&gt;\n                &lt;property name=\"url\" value=\"${jdbc.url}\" /&gt;\n                &lt;property name=\"username\" value=\"${jdbc.username}\" /&gt;\n                &lt;property name=\"password\" value=\"${jdbc.password}\" /&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    \n    &lt;mappers&gt;\n        &lt;!-- 自动扫描包内的Mapper接口与配置文件 --&gt;\n        &lt;package name=\"com.furesky.mybatis.mapper\"/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>4、xml映射文件</p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n\n&lt;mapper namespace=\"com.furesky.mybatis.dao.StudentDAO\"&gt;    \n    &lt;select id=\"getById\" resultType=\"com.furesky.mybatis.model.stutent\"&gt;\n        select * from student where id=#{id}\n    &lt;/select&gt; \n&lt;/mapper&gt;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>5、Student.java</p>\n\n<pre><code class=\"language-java\">public class Student { \n    private String id;\n    private String name; \n    //setters and getters...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>6、StudentDao.jave</p>\n\n<pre><code class=\"language-java\">public interface StudentDAO {\n    public Student getById(String id); \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>7、MyBatisUtil.java</p>\n\n<pre><code class=\"language-java\">public class MyBatisUtil { \n    private static final SqlSessionFactory sqlSessionFactory;\n \n    static{\n        String resource=\"mybatis-config.xml\";\n        Reader reader=null;\n        try {\n            reader=Resources.getResourceAsReader(resource);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);\n    }\n \n    public static SqlSession getSession(){\n        return sessionFactory.openSession();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>7、Test.jave</p>\n\n<pre><code class=\"language-java\">public class Test { \n    public static void main(String args[]){\n        SqlSession session = MyBatisUtil.getSession();\n        StudentDAO studentDAO=session.getMapper(StudentDAO.class);\n        Student student=studentDAO.getById(\"1\");\n        System.out.println(\"姓名：\"+student.getName());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,284570045819809792,'2019-05-07 16:05:44','2019-05-07 16:05:44'),(284648349092442112,'<h1>总述</h1>','sys','待编辑','<p><br>\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p>\n\n<p>配置文档的顶层结构如下：</p>\n\n<ul>\n	<li>configuration（配置）</li>\n	<li>properties（属性）</li>\n	<li>settings（设置）</li>\n	<li>typeAliases（类型别名）</li>\n	<li>typeHandlers（类型处理器）</li>\n	<li>objectFactory（对象工厂）</li>\n	<li>plugins（插件）</li>\n	<li>environments（环境配置）\n	<ul>\n		<li>environment（环境变量）</li>\n		<li>transactionManager（事务管理器）</li>\n		<li>dataSource（数据源）</li>\n	</ul>\n	</li>\n	<li>databaseIdProvider（数据库厂商标识）</li>\n	<li>mappers（映射器）</li>\n</ul>\n',0,284571578275885056,'2019-05-04 15:08:18','2019-05-04 15:08:18'),(284649225190273024,'<h1>属性（properties）</h1>','sys','待编辑','<ul>\n	<li>可外部配置</li>\n	<li>可动态替换</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;dataSource type=\"POOLED\"&gt;\n  &lt;property name=\"driver\" value=\"${driver}\"/&gt;\n  &lt;property name=\"url\" value=\"${url}\"/&gt;\n  &lt;property name=\"username\" value=\"${username}\"/&gt;\n  &lt;property name=\"password\" value=\"${password}\"/&gt;\n&lt;/dataSource&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571578275885056,'2019-05-04 13:49:51','2019-05-04 13:44:01'),(284651756800864256,'<h1>设置（settings）</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;settings&gt;\n  &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;\n  &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n  &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;\n  &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;\n  &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;\n  &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;\n  &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt;\n  &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt;\n  &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt;\n  &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt;\n  &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt;\n  &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt;\n  &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;\n  &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt;\n  &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;\n&lt;/settings&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571578275885056,'2019-05-04 14:05:16','2019-05-04 14:05:16'),(284655060297609216,'<h1>类型别名（typeAliases）</h1>','sys','待编辑','<ul>\n	<li>为 Java 类型设置的一个短名字。</li>\n	<li>只和 XML 配置有关，仅用来减少类完全限定名的冗余</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;!-- 指定类名 --&gt;\n&lt;typeAliases&gt;\n  &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt;\n  &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; \n&lt;/typeAliases&gt;\n\n&lt;!-- 指定包名 --&gt;\n&lt;typeAliases&gt;\n  &lt;package name=\"domain.blog\"/&gt;\n&lt;/typeAliases&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571578275885056,'2019-05-04 14:09:21','2019-05-04 14:09:21'),(284664217255964672,'<h1>环境配置（environments）</h1>','sys','待编辑','<p>1、MyBatis 可以配置成适应多种环境。</p>\n\n<pre><code class=\"language-xml\">&lt;environments default=\"development\"&gt;\n  &lt;environment id=\"development\"&gt;\n    &lt;transactionManager type=\"JDBC\" /&gt;\n    &lt;dataSource type=\"POOLED\"&gt;\n      &lt;property name=\"driver\" value=\"${driver}\"/&gt;\n      &lt;property name=\"url\" value=\"${url}\"/&gt;\n      &lt;property name=\"username\" value=\"${username}\"/&gt;\n      &lt;property name=\"password\" value=\"${password}\"/&gt;\n    &lt;/dataSource&gt;\n  &lt;/environment&gt;\n\n  &lt;environment id=\"test\"&gt;\n   ...\n  &lt;/environment&gt;\n&lt;/environments&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2、事务管理器（transactionManager）</p>\n\n<p>&nbsp;类型：JDBC、MANAGED、</p>\n\n<p>&nbsp;</p>\n\n<p>3、数据源（dataSource）</p>\n\n<p>类型：UNPOOLED、POOLED、JNDI</p>\n',0,284571578275885056,'2019-05-04 14:50:51','2019-05-04 14:50:51'),(284666910921879552,'<h1>映射器（mappers）</h1>','sys','待编辑','<p>告知 MyBatis 到哪里去找映射文件</p>\n\n<pre><code class=\"language-xml\">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;\n&lt;mappers&gt;\n  &lt;package name=\"org.mybatis.builder\"/&gt;\n&lt;/mappers&gt;\n\n&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;\n&lt;mappers&gt;\n  &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt;\n  &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt;\n  &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;\n&lt;/mappers&gt;\n\n&lt;!-- 使用相对于类路径的资源引用 --&gt;\n&lt;mappers&gt;\n  &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt;\n  &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt;\n  &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;\n&lt;/mappers&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571578275885056,'2019-05-05 03:08:01','2019-05-05 03:08:01'),(284672878401449984,'<h1>&lt;select&gt;</h1>','sys','待编辑','<p>示例：</p>\n\n<pre><code class=\"language-xml\">&lt;select id=\"getById\" resultType=\"com.furesky.cms.model.Article\"&gt;\n    SELECT \n        article_id articleId,\n        title,\n        author,\n        summary,\n        content  \n    FROM article_info\n    WHERE article_id = #{articleId} \n    AND state=0\n&lt;/select&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>id</td>\n			<td>命名空间下，唯一标识符</td>\n		</tr>\n		<tr>\n			<td>parameterType</td>\n			<td>传入的参数类的完全限定名或别名。这个属性是可选的</td>\n		</tr>\n		<tr>\n			<td>resultType</td>\n			<td>\n			<p>返回的期望类型的类的完全限定名或别名。</p>\n\n			<p>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>resultMap</td>\n			<td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,284571670672207872,'2019-05-04 15:57:46','2019-05-04 15:57:46'),(284672928867315712,'<h1>&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;<br></h1>','sys','待编辑','<p>示例：</p>\n\n<pre><code class=\"language-xml\">&lt;insert id=\"insertAuthor\"&gt;\n    INSERT INTO Author(\n        id,\n        username,\n        password,\n        create_time\n    ) VALUES (\n        #{id},\n        #{username},\n        #{password},\n        now()\n    )\n&lt;/insert&gt;\n\n&lt;update id=\"updateAuthor\"&gt;\n    UPDATE Author SET\n        update_time= now()\n        &lt;if test=\"username !=null and username !=\'\'\"&gt;\n             ,username = #{username}\n        &lt;/if&gt;    \n        &lt;if test=\"password !=null and password !=\'\'\"&gt;\n             ,password = #{password}\n        &lt;/if&gt;\n    WHERE id = #{id}\n&lt;/update&gt;\n\n&lt;delete id=\"deleteAuthor\"&gt;\n    DELETE FROM Author where id = #{id}\n&lt;/delete&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571670672207872,'2019-05-04 15:58:17','2019-05-04 15:58:17'),(284679928774815744,'<h1>&lt;sql&gt;</h1>','sys','待编辑','<p>定义可重用的 SQL 代码段</p>\n\n<pre><code class=\"language-xml\">&lt;sql id=\"userColumns\"&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;\n    \n&lt;select id=\"selectUsers\" resultType=\"map\"&gt;\n    select\n        &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;,\n        &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt;\n    from some_table t1\n        cross join some_table t2\n&lt;/select&gt;\n</code></pre>\n\n<p>&nbsp;</p>\n',0,284571670672207872,'2019-05-04 15:56:05','2019-05-04 15:56:05'),(284684857283342336,'<h1>参数</h1>','sys','待编辑','<p>示例：</p>\n\n<pre><code class=\"language-xml\">&lt;insert id=\"insertUser\" parameterType=\"User\"&gt;\n    insert into users (id, username, password)\n    values (#{id}, #{username}, #{password})\n&lt;/insert&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>使用#、$传参的区别：</p>\n\n<ul>\n	<li>#是占位符，$是拼接符</li>\n	<li>尽量使用#</li>\n	<li>当参数表示表名/列名时，只能使用$</li>\n</ul>\n',0,284571670672207872,'2019-05-04 16:11:09','2019-05-04 16:11:09'),(284813052183736320,'<h1>结果映射</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt;\n    &lt;id property=\"id\" column=\"blog_id\" /&gt;\n    &lt;result property=\"title\" column=\"blog_title\"/&gt;\n    &lt;collection property=\"posts\" ofType=\"Post\"&gt;\n        &lt;id property=\"id\" column=\"post_id\"/&gt;\n        &lt;result property=\"subject\" column=\"post_subject\"/&gt;\n        &lt;result property=\"body\" column=\"post_body\"/&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>详情见：http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps</p>\n',0,284571670672207872,'2019-05-05 00:43:26','2019-05-05 00:43:26'),(284816604092329984,'<h1>自动映射</h1>','sys','待编辑','<p>自动映射：MyBatis 会获取结果中返回的列名，将其值映射到，&nbsp;Java 类中的同名属性（忽略大小写）。</p>\n\n<ul>\n	<li>一般来说，数据库列名使用大写字母，Java 属性使用驼峰命名法。为者间启用自动映射，需设置mapUnderscoreToCamelCase 为 true</li>\n	<li>mybatis默认：对手动映射以外的属性进行自动映射</li>\n</ul>\n',0,284571670672207872,'2019-05-05 00:55:38','2019-05-05 00:55:38'),(284819019680083968,'<h1>缓存</h1>','sys','待编辑','待编辑',0,284571670672207872,'2019-05-05 00:55:56','2019-06-05 22:06:06'),(284820302780592128,'<h1>&lt;if&gt;</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt;\n    SELECT * FROM BLOG WHERE state = ‘ACTIVE’\n    &lt;if test=\"title != null\"&gt;\n        AND title like #{title}\n    &lt;/if&gt;\n    &lt;if test=\"author != null and author.name != null\"&gt;\n        AND author_name like #{author.name}\n    &lt;/if&gt;\n&lt;/select&gt;</code>\n</pre>\n\n<p>&nbsp;</p>\n\n',0,284571884682375168,'2019-05-05 04:13:30','2019-05-05 03:43:17'),(284861241066680320,'<h1>&lt;choose&gt;</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt;\n    SELECT * FROM BLOG WHERE state = ‘ACTIVE’\n    &lt;choose&gt;\n        &lt;when test=\"title != null\"&gt;\n            AND title like #{title}\n        &lt;/when&gt;\n        &lt;when test=\"author != null and author.name != null\"&gt;\n            AND author_name like #{author.name}\n        &lt;/when&gt;\n        &lt;otherwise&gt;\n            AND featured = 1\n        &lt;/otherwise&gt;\n    &lt;/choose&gt;\n&lt;/select&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571884682375168,'2019-05-05 04:06:11','2019-05-05 04:06:11'),(284867187922857984,'<h1>&lt;where&gt;</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt;\n    SELECT * FROM BLOG\n    &lt;where&gt;\n        &lt;if test=\"state != null\"&gt;\n            state = #{state}\n        &lt;/if&gt;\n        &lt;if test=\"title != null\"&gt;\n            AND title like #{title}\n        &lt;/if&gt;\n        &lt;if test=\"author != null and author.name != null\"&gt;\n            AND author_name like #{author.name}\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571884682375168,'2019-05-05 04:08:36','2019-05-05 04:08:36'),(284867570493714432,'<h1>&lt;set&gt;</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;update id=\"updateAuthorIfNecessary\"&gt;\n    update Author\n        &lt;set&gt;\n            &lt;if test=\"username != null\"&gt;username=#{username},&lt;/if&gt;\n            &lt;if test=\"password != null\"&gt;password=#{password},&lt;/if&gt;\n            &lt;if test=\"email != null\"&gt;email=#{email},&lt;/if&gt;\n            &lt;if test=\"bio != null\"&gt;bio=#{bio}&lt;/if&gt;\n        &lt;/set&gt;\n    where id=#{id}\n&lt;/update&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571884682375168,'2019-05-05 04:09:29','2019-05-05 04:09:29'),(284867856343920640,'<h1>&lt;foreach&gt;</h1>','sys','待编辑','<pre><code class=\"language-xml\">&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt;\n    SELECT *\n    FROM POST P\n    WHERE ID in\n    &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt;\n        #{item}\n    &lt;/foreach&gt;\n&lt;/select&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,284571884682375168,'2019-05-05 04:11:14','2019-05-05 04:11:14'),(284947957127475100,'<h1>参考资料</h1>','sys','待编辑','<p><strong>官方参考文档</strong></p>\n\n<p><a href=\"http://www.mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>\n',0,284563567113302016,'2019-05-18 12:02:28','2019-05-08 17:32:23'),(284947957127475200,'<h1>提问-MyBatis</h1>','sys','待编辑','<p><span style=\"color:#d35400\"><strong>1、#{}和${}的区别是什么？</strong></span></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#{}是预编译处理，${}是字符串替换。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mybatis在处理${}时，就是把${}替换成变量的值。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#d35400\"><strong>2、mybatis的一级缓存、二级缓存</strong></span></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）一级缓存：基于HashMap 的本地缓存，其存储作用域为 Session，默认打开一级缓存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）二级缓存：基于HashMap 的本地缓存，其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开启二级缓存：a、属性类实现Serializable序列化接口；b、其映射文件中配置&lt;cache/&gt;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）缓存数据更新机制：当某一个作用域内进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#d35400\"><strong>3、Mapper 接口的工作原理</strong></span></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>Mapper&nbsp;接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#d35400\"><strong>4、使用MyBatis的mapper接口调用时有哪些要求？</strong></span></p>\n\n<p><span style=\"color:#d35400\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>&nbsp; &nbsp; 1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4） Mapper.xml文件中的namespace即是mapper接口的类路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 第1种： 通过在查询的sql语句中定义字段名的别名</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系</p>\n\n<p>&nbsp;</p>\n\n<p><strong>6、如何获取自动生成的(主)键值?&nbsp;</strong></p>\n\n<pre><code class=\"language-xml\">&lt;insert id=”insertname” usegeneratedkeys=”true” keyproperty=”id”&gt;\n     insert into names (name) values (#{name})\n&lt;/insert&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 因为Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 而Hibernate可以根据对象关系模型直接获取，属于全自动ORM映射工具</p>\n',0,284563567113302016,'2019-06-02 13:05:43','2019-06-02 13:05:43'),(285072088250609664,'<h1>Spring是什么</h1>','sys','待编辑','<p>Spring是一个开源的轻量级&nbsp;Java EE开发框架，为简化企业级应用程序开发而生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>特点：</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、轻量级，非侵入式</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;基于Spring开发的应用中的对象可以不依赖于Spring的API。</p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2、控制反转</strong></p>\n\n<p><strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong></strong>所有对象创建和依赖关系维护，由Spring来管理。（低耦合）</p>\n\n<p>&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp; &nbsp; 3、面向切面</strong></p>\n\n<p><strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong></strong>Spring支持面向切面编程。（高内聚）</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp; &nbsp; 4、声明式事务的支持</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n\n<p>&nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 5、容器</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;Spring是一个容器，因为它包含并且管理应用对象的生命周期。</p>\n\n<p>&nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 6、组件化</strong></p>\n\n<p><strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong></strong>Spring实现了使用简单的组件配置组合成一个复杂的应用。</p>\n\n<p>&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp; &nbsp; 7、一站式</strong></p>\n\n<p><strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong></strong>在IOC和AOP的基础上，Spring整合了各种优秀的开源框架和第三方类库。<strong>&nbsp;</strong></p>\n\n<p>&nbsp;</p>\n\n<p>官方文档：https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/&nbsp;&nbsp;</p>\n',0,285067054821568512,'2019-05-07 04:33:55','2019-05-07 04:33:55'),(285197001963761664,'<h1>Spring体系结构</h1>','sys','待编辑','<p><a href=\"/furesky/images/spring/springframework.jpg\" target=\"_self\"><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-031.png\" style=\"height:363px; margin-left:200px; margin-right:200px; width:500px\"></a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>核心容器</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <strong>1、spring-core</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong>提供了框架的基础部分，包括反转控制和依赖注入。</p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2、spring-beans</strong>&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、spring-context</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;核心接口是ApplicationContext。</p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、spring-expression</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong>模块提供了强大的表达式语言，用于在运行时查询和操作对象图。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>AOP/Aspects模块</strong></p>\n\n<p><strong>数据访问/集成</strong></p>\n\n<p><strong>Web模块&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p>\n',0,285067054821568512,'2019-06-14 01:51:20','2019-06-14 01:51:20'),(285201968967610368,'<h1>概述</h1>','sys','待编辑','<p><strong>1、IoC</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Inversion of Control，即“控制反转”，是一种设计思想。</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;传统程序中，由调用者主动控制，去直接创建获取依赖对象，即“正转”。</p>\n\n<p>&nbsp; &nbsp; &nbsp;IoC中，由IoC容器，来控制创建获取依赖对象，即“反转”。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、DI</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;<strong>Dependency Injection，即“依赖注入”</strong></p>\n\n<p><strong>&nbsp; &nbsp; &nbsp;</strong>由容器动态的将某个依赖关系注入到组件之中。</p>\n\n<p>&nbsp; &nbsp; &nbsp;对象依赖于IoC容器，由IoC容器向其注入外部资源。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、IoC和DI</strong></p>\n\n<p><strong>&nbsp; &nbsp; &nbsp;</strong>IoC和DI是同一个概念的不同角度描述。</p>\n\n<p>&nbsp; &nbsp; &nbsp;相对IoC 而言，<strong>“</strong><strong>依赖注入”明确描述了“被注入对象依赖IoC容器对其的配置”。</strong></p>\n',0,285201811140145152,'2019-05-14 10:29:48','2019-05-14 10:29:48'),(285228086055563264,'<h1>IoC 容器</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;<strong>IOC 容器：</strong>具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、BeanFactory&nbsp;</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;最简单的容器，给 DI 提供了基本的支持。</p>\n\n<p>&nbsp; &nbsp; &nbsp;最常被使用的接口实现：<strong>XmlBeanFactory</strong>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、ApplicationContext</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; BeanFactory 的子接口，并添加了更多的企业特定的功能。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最常被使用的接口实现：<strong>FileSystemXmlApplicationContext、ClassPathXmlApplicationContext、WebXmlApplicationContext</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p>\n',0,285201811140145152,'2019-05-06 04:46:37','2019-05-06 04:46:37'),(285239684115623936,'<h1>Bean</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;Bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、属性&nbsp;</strong> &nbsp; &nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>class</td>\n			<td>必要，指定用来创建 bean 的 bean 类</td>\n		</tr>\n		<tr>\n			<td>name/id</td>\n			<td>必要，指定唯一的 bean 标识符</td>\n		</tr>\n		<tr>\n			<td>scope</td>\n			<td>指定bean实例对象的作用域</td>\n		</tr>\n		<tr>\n			<td>lazy-init</td>\n			<td>是否延迟初始化bean实例</td>\n		</tr>\n		<tr>\n			<td>init-method</td>\n			<td>在实例化 bean 时，立即调用该方法</td>\n		</tr>\n		<tr>\n			<td>destroy-method</td>\n			<td>从容器中移除 bean 之后，才能调用该方法</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、作用域</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">作用域</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>singleton</td>\n			<td>在spring&nbsp;IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值</td>\n		</tr>\n		<tr>\n			<td>prototype</td>\n			<td>每次从容器中调用Bean时，都返回一个新的实例。</td>\n		</tr>\n		<tr>\n			<td>request</td>\n			<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>session</td>\n			<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>global-session</td>\n			<td>一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、生命周期</strong></p>\n\n<ul>\n	<li>读取bean定义，创建实例</li>\n	<li>属性注入</li>\n	<li>执行已实现接口的一些方法</li>\n	<li>执行init-method</li>\n	<li>Bean的使用</li>\n	<li>执行destroy()</li>\n	<li>执行destroy-method</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、定义继承</strong></p>\n\n<p><strong>&nbsp; &nbsp; &nbsp;</strong>子 bean 的定义继承父定义的配置数据。（<strong>parent</strong>&nbsp;属性）</p>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"helloWorld\" class=\"com.tutorialspoint.HelloWorld\"&gt;\n    &lt;property name=\"message1\" value=\"Hello World!\"/&gt;\n    &lt;property name=\"message2\" value=\"Hello Second World!\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"helloIndia\" class=\"com.tutorialspoint.HelloIndia\" parent=\"helloWorld\"&gt;\n    &lt;property name=\"message1\" value=\"Hello India!\"/&gt;\n    &lt;property name=\"message3\" value=\"Namaste India!\"/&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285201811140145152,'2019-07-03 00:52:24','2019-07-03 00:52:24'),(285257736584589312,'<h1>入门示例</h1>','sys','待编辑','<p>1、maven依赖：pom.xml</p>\n\n<p>2、Beans.xml</p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;\n\n   &lt;bean id=\"helloWorld\" class=\"com.tutorialspoint.HelloWorld\"&gt;\n       &lt;property name=\"message\" value=\"Hello World!\"/&gt;\n   &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>3、HelloWorld.java</p>\n\n<pre><code class=\"language-java\">public class HelloWorld {\n    private String message;\n    public void setMessage(String message){\n        this.message  = message;\n    }\n    public void getMessage(){\n        System.out.println(\"Your Message : \" + message);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>4、MainApp.java</p>\n\n<pre><code class=\"language-java\">import org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext context = \n                 new ClassPathXmlApplicationContext(\"Beans.xml\");\n        HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\");\n        obj.getMessage();\n    }\n}</code></pre>\n\n<p><br>\n&nbsp;</p>\n',0,285067054821568512,'2019-05-07 16:05:57','2019-05-07 16:05:57'),(285262091136167936,'<h1>概述</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dependency Injection，即“依赖注入”，<strong>&nbsp;</strong></p>\n\n<p><strong>&nbsp; &nbsp; &nbsp;</strong>由容器动态的将某个依赖关系注入到组件之中。</p>\n\n<p>&nbsp; &nbsp; &nbsp;对象依赖于IoC容器，由IoC容器向其注入外部资源。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、类型</strong></p>\n\n<ul>\n	<li>基于构造函数的依赖注入</li>\n	<li>基于设值函数的依赖注入</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,285260926591856640,'2019-05-06 07:19:39','2019-05-06 07:19:39'),(285265645305491456,'<h1>依赖注入的方式</h1>','sys','待编辑','<p><strong>1、构造函数注入：&lt;constructor-arg&gt;</strong></p>\n\n<ul>\n	<li>value：传递值</li>\n	<li>ref：传递引用</li>\n	<li>index：显式的指定，构造函数参数的索引</li>\n	<li>type :&nbsp;显式的指定，构造函数参数的类型</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"bar\" class=\"x.y.Bar\"/&gt;\n\n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;\n    &lt;constructor-arg value=\"2001\" /&gt;\n    &lt;constructor-arg ref=\"bar\" /&gt;\n    &lt;constructor-arg index=\"2\" type=\"java.lang.String\" value=\"abc\" /&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、设值函数注入：&lt;property&gt;</strong></p>\n\n<ul>\n	<li>value：传递值</li>\n	<li>ref：传递引用</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n&nbsp; &nbsp; &nbsp;xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n&nbsp; &nbsp; &nbsp;xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n&nbsp; &nbsp; &nbsp;http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;\n\n&nbsp; &nbsp; &lt;bean id=\"john-classic\" class=\"com.example.Person\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property name=\"name\" value=\"John Doe\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property name=\"spouse\" ref=\"jane\"/&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n\n&nbsp; &nbsp; &lt;bean name=\"jane\" class=\"com.example.Person\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property name=\"name\" value=\"John Doe\"/&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2.1、p命名空间简化设值函数注入</strong></p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;\n\n   &lt;bean id=\"john-classic\" class=\"com.example.Person\"\n      p:name=\"John Doe\"\n      p:spouse-ref=\"jane\"/&gt;\n   &lt;/bean&gt;\n\n   &lt;bean name=\"jane\" class=\"com.example.Person\"\n      p:name=\"John Doe\"/&gt;\n   &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例：</strong></p>\n\n<p>TextEditor.java</p>\n\n<pre><code class=\"language-java\">public class TextEditor {\n    private SpellChecker spellChecker;\n    public TextEditor(SpellChecker spellChecker) {\n        System.out.println(\"Inside TextEditor constructor.\" );\n        this.spellChecker = spellChecker;\n    }\n    public void spellCheck() {\n        spellChecker.checkSpelling();\n    }\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>SpellChecker.java</p>\n\n<pre><code class=\"language-java\">public class SpellChecker {\n    public SpellChecker(){\n        System.out.println(\"Inside SpellChecker constructor.\" );\n    }\n    public void checkSpelling() {\n        System.out.println(\"Inside checkSpelling.\" );\n    } \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>MainApp.java</p>\n\n<pre><code class=\"language-java\">import org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext context = \n                 new ClassPathXmlApplicationContext(\"Beans.xml\");\n        TextEditor te = (TextEditor) context.getBean(\"textEditor\");\n        te.spellCheck();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Beans.xml</p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;\n\n   &lt;!-- Definition for textEditor bean --&gt;\n   &lt;bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\"&gt;\n      &lt;constructor-arg ref=\"spellChecker\"/&gt;\n   &lt;/bean&gt;\n\n   &lt;!-- Definition for spellChecker bean --&gt;\n   &lt;bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\"&gt;\n   &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285260926591856640,'2019-05-06 07:28:23','2019-05-06 07:28:23'),(285276971096502272,'<h1>注入内部类、集合、null值</h1>','sys','待编辑','<p><strong>1、注入内部 Beans</strong></p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;\n\n   &lt;bean id=\"outerBean\" class=\"...\"&gt;\n      &lt;property name=\"target\"&gt;\n         &lt;bean id=\"innerBean\" class=\"...\"/&gt;\n      &lt;/property&gt;\n   &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、注入集合</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">元素</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>&lt;list&gt;</td>\n			<td>它有助于连线，如注入一列值，允许重复。</td>\n		</tr>\n		<tr>\n			<td>&lt;set&gt;</td>\n			<td>它有助于连线一组值，但不能重复。</td>\n		</tr>\n		<tr>\n			<td>&lt;map&gt;</td>\n			<td>它可以用来注入名称-值对的集合，其中名称和值可以是任何类型。</td>\n		</tr>\n		<tr>\n			<td>&lt;props&gt;</td>\n			<td>它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"...\" class=\"...\"&gt;\n\n    &lt;property name=\"addressList\"&gt;\n        &lt;list&gt;\n            &lt;ref bean=\"address1\"/&gt;\n            &lt;ref bean=\"address2\"/&gt;\n            &lt;value&gt;Pakistan&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n\n    &lt;property name=\"addressSet\"&gt;\n        &lt;set&gt;\n            &lt;ref bean=\"address1\"/&gt;\n            &lt;ref bean=\"address2\"/&gt;\n            &lt;value&gt;Pakistan&lt;/value&gt;\n        &lt;/set&gt;\n    &lt;/property&gt;\n\n    &lt;property name=\"addressMap\"&gt;\n        &lt;map&gt;\n            &lt;entry key=\"one\" value=\"INDIA\"/&gt;\n            &lt;entry key =\"two\" value-ref=\"address1\"/&gt;\n            &lt;entry key =\"three\" value-ref=\"address2\"/&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n\n    &lt;property name=\"addressProp\"&gt;\n        &lt;props&gt;\n            &lt;prop key=\"one\"&gt;INDIA&lt;/prop&gt;\n            &lt;prop key=\"two\"&gt;Pakistan&lt;/prop&gt;\n            &lt;prop key=\"three\"&gt;USA&lt;/prop&gt;\n            &lt;prop key=\"four\"&gt;USA&lt;/prop&gt;\n        &lt;/props&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、注入 空字符串和 null</strong></p>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"...\" class=\"exampleBean\"&gt;\n    &lt;property name=\"name\" value=\"\"&gt;&lt;/property&gt;\n    &lt;property name=\"email\"&gt;&lt;null/&gt;&lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285260926591856640,'2019-05-06 07:40:05','2019-05-06 07:40:05'),(285286025558650880,'<h1>自动装配</h1>','sys','待编辑','<p><strong>自动装配模式</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">模式</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>no</td>\n			<td>默认模式，没有自动装配</td>\n		</tr>\n		<tr>\n			<td>byName</td>\n			<td>由属性名自动装配。</td>\n		</tr>\n		<tr>\n			<td>byType</td>\n			<td>由属性数据类型自动装配。</td>\n		</tr>\n		<tr>\n			<td>constructor</td>\n			<td>类似于 byType，但该类型适用于构造函数参数类型。</td>\n		</tr>\n		<tr>\n			<td>autodetect</td>\n			<td>首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\" autowire=\"constructor\"&gt;\n    &lt;constructor-arg value=\"Generic Text Editor\"/&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285260926591856640,'2019-05-06 07:58:05','2019-05-06 07:58:05'),(285289787715121152,'<h1>开启注解注入</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt;\n\n   &lt;context:annotation-config/&gt;\n   &lt;!-- bean definitions go here --&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285291594407374848,'2019-05-06 08:14:34','2019-05-06 08:14:34'),(285292213339844608,'<h1>@Required、@Autowired、@Qualifier</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">注解&nbsp;</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>@Required</td>\n			<td>应用于 bean 属性的 setter 方法。</td>\n		</tr>\n		<tr>\n			<td>@Autowired</td>\n			<td>应用到 bean 属性的 setter 方法，构造函数和属性。</td>\n		</tr>\n		<tr>\n			<td>@Qualifier</td>\n			<td>指定确切的 bean，@Autowired 和 @Qualifier 注解可以用来删除混乱。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,285291594407374848,'2019-05-06 08:19:51','2019-05-06 08:19:51'),(285293318207598592,'<h1>@Resource、@PostConstruct、@PreDestroy</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">注解</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>@Resource</td>\n			<td>应用到 bean 属性的 setter 方法、属性。</td>\n		</tr>\n		<tr>\n			<td>@PostConstruct</td>\n			<td>指定初始化回调函数。</td>\n		</tr>\n		<tr>\n			<td>@PreDestroy</td>\n			<td>指定销毁回调函数。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,285291594407374848,'2019-05-06 08:38:19','2019-05-06 08:38:19'),(285301121475309568,'<h1>@Configuration、@Bean<br></h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p>示例：</p>\n\n<pre><code class=\"language-java\">//示例1\nimport org.springframework.context.annotation.*;\n@Configuration\npublic class HelloWorldConfig {\n    @Bean \n    public HelloWorld helloWorld(){\n        return new HelloWorld();\n    }\n}\n\n//示例2\n@Configuration\npublic class AppConfig {\n    @Bean(initMethod = \"init\", destroyMethod = \"cleanup\" )\n    @Scope(\"prototype\")\n    public Foo foo() {\n        return new Foo();\n    }\n}</code></pre>\n\n<p>示例1相当于xml配置：</p>\n\n<pre><code class=\"language-xml\">&lt;beans&gt;\n    &lt;bean id=\"helloWorld\" class=\"com.tutorialspoint.HelloWorld\" /&gt;\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>@Import</strong></p>\n\n<pre><code class=\"language-java\">@Configuration\npublic class ConfigA {\n    @Bean\n    public A a() {\n        return new A(); \n    }\n}\n\n@Configuration\n@Import(ConfigA.class)\npublic class ConfigB {\n    @Bean\n    public B a() {\n        return new A(); \n    }\n}\n\npublic static void main(String[] args) {\n    ApplicationContext ctx = \n    new AnnotationConfigApplicationContext(ConfigB.class);\n    // now both beans A and B will be available...\n    A a = ctx.getBean(A.class);\n    B b = ctx.getBean(B.class);\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,285291594407374848,'2019-05-06 09:00:57','2019-05-06 09:00:57'),(285314199482953728,'<h1>概述</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;Aspect Oriented Programming，面向切面编程，是一种编程范式</p>\n\n<p>&nbsp; &nbsp; &nbsp;提供了与 OOP( Object-Oriented Programming, 面向对象编程)不同的抽象软件结构的视角.</p>\n\n<p>&nbsp; &nbsp; &nbsp;在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是&nbsp;<strong>Aspect(切面)</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、术语</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th colspan=\"2\" rowspan=\"1\" scope=\"col\">术语</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>通知</td>\n			<td>Advice</td>\n			<td>被织入到连接点上的一段程序代码</td>\n		</tr>\n		<tr>\n			<td>连接点</td>\n			<td>Jointpoint</td>\n			<td>程序类中，所有可以被织入通知的位置点</td>\n		</tr>\n		<tr>\n			<td>切入点</td>\n			<td>Pointcut</td>\n			<td>程序类中，部分被织入通知的位置点</td>\n		</tr>\n		<tr>\n			<td>切面</td>\n			<td>Aspect</td>\n			<td>是通知和切入点的组合。</td>\n		</tr>\n		<tr>\n			<td>目标对象</td>\n			<td>Target object</td>\n			<td>被织入通知的目标对象，这个对象永远是一个被代理对象</td>\n		</tr>\n		<tr>\n			<td>织入</td>\n			<td>Weaving</td>\n			<td>将通知添加到目标类具体连接点上的过程</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>3、通知类型</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th colspan=\"2\" rowspan=\"1\" scope=\"col\">通知</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>环绕通知</td>\n			<td>around</td>\n			<td>在建议方法调用之前和之后，执行通知。</td>\n		</tr>\n		<tr>\n			<td>前置通知</td>\n			<td>before</td>\n			<td>在一个方法执行之前，执行通知。</td>\n		</tr>\n		<tr>\n			<td>后置通知</td>\n			<td>after</td>\n			<td>在一个方法执行之后，不考虑其结果，执行通知。</td>\n		</tr>\n		<tr>\n			<td>正常返回通知</td>\n			<td>after-returning</td>\n			<td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>\n		</tr>\n		<tr>\n			<td>异常返回通知</td>\n			<td>after-throwing</td>\n			<td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,285314020126126080,'2019-05-06 14:10:21','2019-05-06 14:10:21'),(285407195729653760,'<h1>基于xml</h1>','sys','待编辑','<p><strong>1、AOP命名空间</strong></p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \n    http://www.springframework.org/schema/aop \n    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt;\n\n   &lt;!-- bean definition &amp; AOP specific configuration --&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、xml配置</strong></p>\n\n<pre><code class=\"language-xml\">&lt;aop:config&gt;\n    &lt;!--声明切面--&gt;\n    &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt;\n    \n        &lt;!--声明切点--&gt;\n        &lt;aop:pointcut id=\"businessService\"\n            expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt;\n\n        &lt;!--声明通知--&gt;\n        &lt;aop:before pointcut-ref=\"businessService\" \n            method=\"doRequiredTask\"/&gt;\n        &lt;aop:after pointcut-ref=\"businessService\" \n            method=\"doRequiredTask\"/&gt;\n        &lt;aop:after-returning pointcut-ref=\"businessService\" returning=\"retVal\"\n            method=\"doRequiredTask\"/&gt;\n        &lt;aop:after-throwing pointcut-ref=\"businessService\" throwing=\"ex\"\n            method=\"doRequiredTask\"/&gt;\n        &lt;aop:around pointcut-ref=\"businessService\" \n            method=\"doRequiredTask\"/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n\n&lt;bean id=\"aBean\" class=\"...\"&gt;\n...\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285314020126126080,'2019-05-06 16:07:47','2019-05-06 16:07:47'),(285407251161575424,'<h1>基于注解</h1>','sys','待编辑','<p><strong>1、Spring配置文件中，开启@AspectJ</strong></p>\n\n<pre><code class=\"language-xml\">&lt;aop:aspectj-autoproxy/&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java类中，注释切面</strong></p>\n\n<pre><code class=\"language-java\">@Aspect\npublic class Logging {    \n    @Pointcut(\"execution(* com.tutorialspoint.*.*(..))\")\n    private void selectAll(){}\n   \n    @Before(\"selectAll()\")\n    public void beforeAdvice(){\n        System.out.println(\"Going to setup student profile.\");\n    }\n   \n    @After(\"selectAll()\")\n    public void afterAdvice(){\n        System.out.println(\"Student profile has been setup.\");\n    }\n    \n    @AfterReturning(pointcut = \"selectAll()\", returning=\"retVal\")\n    public void afterReturningAdvice(Object retVal){\n        System.out.println(\"Returning:\" + retVal.toString() );\n    }\n    \n    @AfterThrowing(pointcut = \"selectAll()\", throwing = \"ex\")\n    public void AfterThrowingAdvice(IllegalArgumentException ex){\n        System.out.println(\"There has been an exception: \" + ex.toString());    \n    }  \n}</code></pre>\n\n<p>&nbsp;</p>\n',0,285314020126126080,'2019-05-06 16:09:53','2019-05-06 16:09:53'),(285412098061529088,'<h1>事务管理</h1>','sys','待编辑','<p><strong>事务</strong>：是一个被视为单一的工作单元的操作序列，这些操作应该要么完整地执行，要么完全不执行</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、ACID特性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>原子性</td>\n			<td>Atomicity</td>\n			<td>事务应该当作一个单独单元的操作，要么成功，要么失败</td>\n		</tr>\n		<tr>\n			<td>一致性</td>\n			<td>Consistency</td>\n			<td>事务执行前后，数据库的数据都保持正确</td>\n		</tr>\n		<tr>\n			<td>隔离性</td>\n			<td>Isolation</td>\n			<td>并发事务执行之间无影响</td>\n		</tr>\n		<tr>\n			<td>持久性</td>\n			<td>Durability</td>\n			<td>事务一旦执行成功，它对数据库的数据的改变必须是永久的</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、局部事务&nbsp;vs. 全局事务</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;局部事务：特定于单一事务资源的事务，如一个 JDBC 连接的事务。</p>\n\n<p>&nbsp; &nbsp; &nbsp;全局事务：跨多个事务资源的事务，如在一个分布式系统中的事务。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、编程式事务 vs. 声明式事务</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp;编程式事务：通过编写代码实现的事务。</p>\n\n<p>&nbsp; &nbsp; &nbsp;声明式事务：通过注解或XML配置文件实现的事务。</p>\n\n<p>&nbsp;</p>\n',0,285411895787024384,'2019-05-12 18:08:24','2019-05-12 18:08:24'),(285412130508664832,'<h1>编程式事务</h1>','sys','待编辑','<h4>TransactionTemplate编程式事务</h4>\n\n<p>&nbsp;</p>\n\n<p><strong>1、配置xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- 事务管理器 --&gt;\n&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;/bean&gt;\n\n&lt;!-- 配置 transactionTemplate --&gt;\n&lt;bean id=\"transactionTemplate\"\n      class=\"org.springframework.transaction.support.TransactionTemplate\"&gt;\n    &lt;property name=\"transactionManager\"&gt;\n        &lt;ref bean=\"transactionManager\"/&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、业务代码引入事务</strong></p>\n\n<pre><code class=\"language-java\">public Object getObject(String str) {\n    /*\n     *  执行带有返回值&lt;Object&gt;的事务管理\n     */\n    transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() {\n        @Override\n        public Object doInTransaction(TransactionStatus transactionStatus) {\n            try {\n                  ...\n                //.......   业务代码\n                return new Object();\n            } catch (Exception e) {\n                //回滚\n                transactionStatus.setRollbackOnly();\n                return null;\n            }\n        }\n    });\n}\n\n\npublic void update(String str) {\n     /*\n     *  执行无返回值的事务管理\n     */\n    transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {\n            try {\n                // ....  业务代码\n            } catch (Exception e){\n                //回滚\n                transactionStatus.setRollbackOnly();\n            }\n        }\n    });\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,285411895787024384,'2019-05-06 18:16:54','2019-05-06 18:16:54'),(285412156240719872,'<h1>声明式事务</h1>','sys','待编辑','<p><strong>声明式事务</strong>：基于 AOP ，其本质是在方法前后进行拦截，然后在目标方法开始前创建一个事务，在执行这目标方法结束后，根据执行情况提交或进行回滚事务。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>方式一：基于@Transactional注解</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- 定义事务管理器 --&gt;\n&lt;bean id=\"transactionManager\"\n    class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\"  ref=\"dataSource\" /&gt;     \n&lt;/bean&gt;\n\n&lt;!-- 开启注解事务管理，扫描@Transactional --&gt;\n&lt;tx:annotation-driven /&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>方式二：基于xml配置</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- 定义事务管理器 --&gt;\n&lt;bean id=\"transactionManager\"\n    class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\"  ref=\"dataSource\" /&gt;     \n&lt;/bean&gt;\n\n&lt;!-- 定义通知 --&gt;\n&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;\n&nbsp; &nbsp; &lt;tx:attributes&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;!-- 传播行为 --&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"create*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\" /&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\" /&gt;\n&nbsp; &nbsp; &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n&lt;!-- 定义切面 --&gt;\n&lt;aop:config&gt;\n    &lt;aop:pointcut id=\"createOperation\"  expression=\"execution(* com.xxx.xxx.service.*.*(..))\"/&gt;\n    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"createOperation\"/&gt;\n&lt;/aop:config&gt;\n</code></pre>\n\n<p>&nbsp;</p>\n',0,285411895787024384,'2019-05-06 18:24:35','2019-05-06 18:24:35'),(285602272598978560,'<h1>参考资料</h1>','sys','待编辑','<p><strong>官方参考文档</strong></p>\n\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/\" target=\"_blank\">https://docs.spring.io/spring/docs/current/spring-framework-reference/</a></p>\n',0,284556803206705152,'2019-05-18 12:05:10','2019-05-08 17:32:37'),(285603738822799360,'<h1>提问-Spring</h1>','sys','待编辑','<p><strong>1、Spring是什么?</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring是一个轻量级的IoC和AOP容器框架。目的是用于简化企业应用程序的开发。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring的优点？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）轻量、低侵入式： Spring 在代码量和透明度方面都很轻便。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）控制反转： Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）面向切面编程(AOP)： Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开，以实现高内聚。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）容器： Spring 负责创建和管理对象（Bean）的生命周期和配置。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）MVC框架 ：对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）事务管理： 提供了用于事务管理的通用抽象层。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）异常处理： Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring中的模块？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心容器、数据访问/集成、Web、AOP及其他</p>\n\n<ul>\n	<li>Spring Core</li>\n	<li>Spring Bean</li>\n	<li>SpEL&nbsp;</li>\n	<li>Spring Context</li>\n	<li>...</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Spring 中用到的设计模式？</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）单例模式：Bean默认为单例模式。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）模板方法：用来解决代码重复的问题。比如.&nbsp;RestTemplate,&nbsp;JmsTemplate,&nbsp;JpaTemplate。</p>\n',0,284556803206705152,'2019-06-02 13:03:29','2019-06-02 13:03:29'),(285627402054168576,'<h1>提问-IoC</h1>','sys','待编辑','<p><strong>1、IOC？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; IOC，即控制反转，是一种设计思想。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 传统程序由调用者主动控制，去直接创建获取依赖对象。IoC中，则是由IoC容器，来控制创建获取依赖对象。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建被调用者的工作由spring来完成，然后注入调用者直接使用，从而实现程序的低耦合</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; DI，依赖注入，由容器动态的将某个依赖关系注入到组件之中。IoC和DI是同一个概念的不同角度描述。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、BeanFactory 和 ApplicationContext的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th>BeanFactory</th>\n			<th>ApplicationContext</th>\n		</tr>\n		<tr>\n			<td>它使用懒加载</td>\n			<td>它使用即时加载</td>\n		</tr>\n		<tr>\n			<td>它使用语法显式提供资源对象</td>\n			<td>它自己创建和管理资源对象</td>\n		</tr>\n		<tr>\n			<td>不支持国际化</td>\n			<td>支持国际化</td>\n		</tr>\n		<tr>\n			<td>不支持基于依赖的注解</td>\n			<td>支持基于依赖的注解</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、构造函数注入和 setter 注入的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">构造函数注入</th>\n			<th scope=\"col\">setter 注入</th>\n		</tr>\n		<tr>\n			<td>没有部分注入</td>\n			<td>有部分注入</td>\n		</tr>\n		<tr>\n			<td>不会覆盖 setter 属性</td>\n			<td>会覆盖 setter 属性</td>\n		</tr>\n		<tr>\n			<td>任意修改都会创建一个新实例</td>\n			<td>任意修改不会创建一个新实例</td>\n		</tr>\n		<tr>\n			<td>适用于设置很多属性</td>\n			<td>适用于设置少量属性</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Spring自动装配模式？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">模式</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>no</td>\n			<td>默认模式，没有自动装配</td>\n		</tr>\n		<tr>\n			<td>byName</td>\n			<td>由属性名自动装配。</td>\n		</tr>\n		<tr>\n			<td>byType</td>\n			<td>由属性数据类型自动装配。</td>\n		</tr>\n		<tr>\n			<td>constructor</td>\n			<td>类似于 byType，但该类型适用于构造函数参数类型。</td>\n		</tr>\n		<tr>\n			<td>autodetect</td>\n			<td>首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。</td>\n		</tr>\n	</thead>\n</table>\n',0,284556803206705152,'2019-06-02 13:03:48','2019-06-02 13:03:48'),(285627947166887936,'<h1>提问-AOP</h1>','sys','待编辑','<p><strong>1、AOP？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义：面向切面编程，是一种编程范式。提供了与 OOP不同的抽象软件结构的视角。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：低耦合性、源代码无关性</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、AOP 两种动态代理方式？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）JDK动态代理</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：因为有接口，所以使系统更加松耦合</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：为每一个目标类创建接口</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CGLIB动态代理</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、AOP通知类型？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th colspan=\"2\" rowspan=\"1\" scope=\"col\">通知</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>环绕通知</td>\n			<td>around</td>\n			<td>在建议方法调用之前和之后，执行通知。</td>\n		</tr>\n		<tr>\n			<td>前置通知</td>\n			<td>before</td>\n			<td>在一个方法执行之前，执行通知。</td>\n		</tr>\n		<tr>\n			<td>后置通知</td>\n			<td>after</td>\n			<td>在一个方法执行之后，不考虑其结果，执行通知。</td>\n		</tr>\n		<tr>\n			<td>正常返回通知</td>\n			<td>after-returning</td>\n			<td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>\n		</tr>\n		<tr>\n			<td>异常返回通知</td>\n			<td>after-throwing</td>\n			<td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>\n		</tr>\n	</tbody>\n</table>\n',0,284556803206705152,'2019-06-02 13:03:58','2019-06-02 13:03:58'),(285628032193818624,'<h1>提问-Bean</h1>','sys','待编辑','<p><strong>1、Spring Bean？</strong></p>\n\n<ul>\n	<li>它们是构成用户应用程序主干的对象。</li>\n	<li>Bean 由 Spring IoC 容器管理。</li>\n	<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>\n	<li>Bean 是基于用户提供给容器的配置元数据创建。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Bean的作用域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">\n			<p>作用域</p>\n			</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>singleton</td>\n			<td>在spring&nbsp;IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值</td>\n		</tr>\n		<tr>\n			<td>prototype</td>\n			<td>每次从容器中调用Bean时，都返回一个新的实例。</td>\n		</tr>\n		<tr>\n			<td>request</td>\n			<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>session</td>\n			<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>global-session</td>\n			<td>一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring常见创建对象的注解？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>@Component</td>\n			<td>将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。</td>\n		</tr>\n		<tr>\n			<td>@Controller</td>\n			<td>将一个类标记为 Spring Web MVC 控制器。</td>\n		</tr>\n		<tr>\n			<td>@Service</td>\n			<td>是@Component 注解的特化，它没有提供额外的行为，只是更好指定了意图。</td>\n		</tr>\n		<tr>\n			<td>@Repository</td>\n			<td>是@Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</td>\n		</tr>\n	</tbody>\n</table>\n',0,284556803206705152,'2019-06-02 13:04:11','2019-06-02 13:04:11'),(285703665179586560,'<h1>MVC模式</h1>','sys','待编辑','<p><strong>MVC</strong></p>\n\n<ul>\n	<li>Model View Controller</li>\n	<li>是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。</li>\n	<li>使程序分层、分工合作，既相互独立，又协同合作。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>Model</td>\n			<td>模型</td>\n			<td>数据模型，提供要展示的数据，包含数据和行为</td>\n		</tr>\n		<tr>\n			<td>View</td>\n			<td>视图</td>\n			<td>负责进行模型的展示，一般指客户所看到的东西，如用户界面。</td>\n		</tr>\n		<tr>\n			<td>Controller</td>\n			<td>控制器</td>\n			<td>负责居中调度。接收用户请求，委托给模型进行处理，处理完毕后，把返回数据交由视图进行展示。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,285703542961762304,'2019-07-03 00:36:27','2019-07-03 00:36:27'),(285707682303602688,'<h1>SpringMVC</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种基于 Java 的、实现了MVC 设计模式的、请求驱动类型的轻量级 Web 框架。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>清晰的角色划分，分工明确，可灵活扩展</li>\n	<li>功能强大的数据验证、格式化、绑定机制</li>\n	<li>和 Spring 其他框架无缝集成</li>\n	<li>支持各种请求资源的映射策略</li>\n	<li>支持各种视图技术</li>\n	<li>支持RESTful 风格</li>\n	<li>...</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、核心组件</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>前端控制器</td>\n			<td>DispatcherServlet</td>\n		</tr>\n		<tr>\n			<td>处理器映射器&nbsp;</td>\n			<td>HandlerMapping</td>\n		</tr>\n		<tr>\n			<td>处理器适配器</td>\n			<td>HandlerAdapter</td>\n		</tr>\n		<tr>\n			<td>处理器</td>\n			<td>Handler</td>\n		</tr>\n		<tr>\n			<td>视图解析器</td>\n			<td>ViewResolver</td>\n		</tr>\n		<tr>\n			<td>视图</td>\n			<td>View</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、工作流程</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）发起请求到前端控制器(DispatcherServlet)。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）前端控制器请求HandlerMapping查找 Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）HandlerMapping向前端控制器返回Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）前端控制器调用HandlerAdapter去执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）HandlerAdapter执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）Handler执行完成后，向HandlerAdapter返回ModelAndView。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）HandlerAdapter将ModelAndView返回给前端控制器。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8）前端控制器将ModelAndView传给ViewReslover。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9）ViewReslover解析后，向前端控制器返回具体View。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10）前端控制器根据View进行渲染视图。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11）前端控制器响应用户。</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"SpringMVC工作流程\" src=\"/furesky/images/201906/20190613-000000-029.png\" style=\"height:360px; width:844px\"></p>\n\n<ul>\n</ul>\n',0,285703542961762304,'2019-06-14 02:51:40','2019-06-14 02:51:40'),(285772669336317952,'<h1>入门示例</h1>','sys','待编辑','<p><strong>1、maven依赖：pom.xml</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、web.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;web-app id=\"WebApp_ID\" version=\"2.4\"\n    xmlns=\"http://java.sun.com/xml/ns/j2ee\" \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee \n    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;\n\n    &lt;display-name&gt;Spring MVC Application&lt;/display-name&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        \n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、spring-mvc.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n    http://www.springframework.org/schema/beans      \n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context \n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt;\n\n    &lt;context:component-scan base-package=\"com.tutorialspoint\" /&gt;\n    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、HelloController.java</strong></p>\n\n<pre><code class=\"language-java\">package com.tutorialspoint;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.ui.ModelMap;\n@Controller\n@RequestMapping(\"/hello\")\npublic class HelloController{ \n    @RequestMapping(method = RequestMethod.GET)\n    public String printHello(ModelMap model) {\n        model.addAttribute(\"message\", \"Hello Spring MVC Framework!\");\n        return \"hello\";\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、hello.jsp</strong></p>\n\n<pre><code class=\"language-html\">&lt;%@ page contentType=\"text/html; charset=UTF-8\" %&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Hello World&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h2&gt;${message}&lt;/h2&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285703542961762304,'2019-05-08 14:48:37','2019-05-08 14:48:37'),(285955316264103936,'<h1>基于xml</h1>','sys','待编辑','<p>了解即可，略</p>\n',0,285955163037790208,'2019-05-08 04:15:09','2019-05-08 04:15:09'),(285955953483739136,'<h1>基于注解</h1>','sys','待编辑','<p><strong>2、web.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- Spring 集成 Web 环境的通用配置，加载除 Web 层的 Bean（如 DAO、Service 等）--&gt;\n&lt;context-param&gt;\n&nbsp; &nbsp; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n&nbsp; &nbsp; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n&lt;listener&gt;\n&nbsp; &nbsp; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;!-- 配置前端控制器 --&gt;\n&lt;servlet&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;!-- 启动web容器时初始化该 Servlet --&gt; \n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   \n    &lt;init-param&gt;\n    	&lt;!-- 配置springmvc加载的配置文件，如果不配置，默认加载的是/WEB-INF/servlet名称-serlvet.xml --&gt;\n    	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    	&lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n&nbsp;   &lt;!-- 所有请求都由DispatcherServlet进行解析，可实现 RESTful风格的url，静态资源需另行配置 --&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、spring-mvc.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- 配置处理器，扫描@controller（对于SpringMVC）--&gt;\n&lt;!-- 扫描Bean相关注解 --&gt;\n&lt;context:component-scan base-package=\"com.furesky.cms\"&gt;&lt;/context:component-scan&gt;\n\n&lt;!--配置处理器映射器，配置处理器适配器 --&gt;\n&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\n\n&lt;!-- 配置视图解析器--&gt;  \n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;  \n    &lt;!-- 把处理器返回的逻辑视图名,加入前缀/WEB-INF/views/,加入后缀.jsp --&gt;\n    &lt;property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt;  \n    &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n&lt;/bean&gt;\n\n&lt;!-- 配置静态资源访问  --&gt;\n&lt;!--例如：把符合/images/**匹配规则的请求,映射到目录/WEB-INF/images/下--&gt;\n&lt;mvc:resources mapping=\"/images/**\" location=\"/WEB-INF/images/\"/&gt;\n&lt;mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/css/\"/&gt;\n&lt;mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/js/\"/&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,285955163037790208,'2019-06-14 02:28:56','2019-06-14 02:28:56'),(285974611601813504,'<h1>乱码问题</h1>','sys','待编辑','<p>1<strong>、post乱码</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </strong>方案：修改web.xml文件</p>\n\n<pre><code class=\"language-xml\">&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;/param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、get乱码</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 方案一：修改tomcat配置文件：</p>\n\n<p><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">&nbsp;&nbsp;&nbsp;&nbsp;</span></span>&lt;Connector <strong>URIEncoding</strong>=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案二：对参数进行重新编码：</p>\n\n<p><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">&nbsp;&nbsp;&nbsp;&nbsp;</span></span>String <span style=\"color:#c0392b\">oldName</span>=<span style=\"color:#c0392b\">request</span>.getParamter(<span style=\"color:#3300ff\">\"userName\"</span>).getBytes(<span style=\"color:#3300ff\">\"ISO8859-1\"</span>);</p>\n\n<p><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">&nbsp;&nbsp;&nbsp;&nbsp;</span></span>String <span style=\"color:#c0392b\">newName</span>=new String(<span style=\"color:#c0392b\">oldName</span>,<span style=\"color:#3300ff\">\"utf-8\"</span>);</p>\n',0,285974274438492160,'2019-06-20 19:15:59','2019-06-20 19:15:59'),(285974698197413888,'<h1>@RequestMapping</h1>','sys','待编辑','<p><strong>URL绑定</strong></p>\n\n<ul>\n	<li>定义处理器方法对应的URL</li>\n	<li>窄化请求映射</li>\n	<li>限定HTTP请求方法</li>\n</ul>\n\n<pre><code>@RequestMapping(value=\"/addArticle\",method=RequestMethod.POST)\npublic ActionResult addArticle(HttpServletRequest request) {\n    //......\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,286059549709725696,'2019-05-08 11:10:26','2019-05-08 11:10:26'),(286039088506499072,'<h1>返回值类型</h1>','sys','待编辑','<p><strong>1、ModelAndView</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义ModelAndView，分别设置model和view</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、String</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）表示逻辑视图名，真正视图=前缀+逻辑视图名+后缀</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：<strong><span style=\"color:#990033\">return</span> <span style=\"color:#0033ff\">\"/cms/article\"</span>;&nbsp;</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）redirect重定向</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：<strong><span style=\"color:#990033\">return</span> <span style=\"color:#0033ff\">\"redirect:label.jsp\"</span>;&nbsp;&nbsp;</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）forward页面转发 &nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：<strong><span style=\"color:#990033\">return</span> <span style=\"color:#0033ff\">\"forward:label.jsp\"</span>;&nbsp;&nbsp;</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、void</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在处理器方法形参上可以定义request和response，使用request或response指定响应结果</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）响应json数据</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;例:&nbsp;<strong>&nbsp;response.setCharacterEncoding(<span style=\"color:#0033ff\">\"utf-8\"</span>);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.setContentType(<span style=\"color:#0033ff\">\"application/json;charset=utf-8\"</span>);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.getWriter().write(<span style=\"color:#0033ff\">\"json串\"</span>);&nbsp;&nbsp;</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）重定向</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：<strong>response.sendRedirect(<span style=\"color:#0033ff\">\"url\"</span>);</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）页面转发</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：<strong>request.getRequestDispatcher(<span style=\"color:#0033ff\">\"页面路径\"</span>).forward(<span style=\"color:#c0392b\">request</span>, <span style=\"color:#c0392b\">response</span>);</strong></p>\n',0,286059589295566848,'2019-05-08 11:41:05','2019-05-08 11:41:05'),(286059969790242816,'<h1>参数绑定</h1>','sys','待编辑','<p><strong>1、默认支持的类型</strong></p>\n\n<ul>\n	<li>HttpServletRequest</li>\n	<li>HttpServletResponse</li>\n	<li>HttpSession</li>\n	<li>Model/ModelMap</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、简单类型</strong></p>\n\n<ul>\n	<li>request入参、处理器方法形参，名称相同，可免注解</li>\n	<li>request入参、处理器方法形参，名称不同，使用@RequestParam</li>\n</ul>\n\n<pre><code>// required属性：否必须传入\n// defaultValue属性：设置默认值\npublic String editItem(String id,\n    @RequestParam(value = \"name\", required = true) String itemName){\n    //......\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、简单pojo</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 前提条件：接收参数的pojo，内部属性为简单类型，且与request入参名称相同</p>\n\n<pre><code class=\"language-java\">//pojo类\npublic class Label{\n	private String labelId;\n	private String labelName;\n	//...\n}\n\n//处理器类\n@Controller\n@RequestMapping(method=RequestMethod.POST)\npublic class LabelController {\n    @RequestMapping(\"/addLabel\")\n    public ActionResult addLabel(Label label) {\n        //...\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、包装类型pojo</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 包装类型pojo：指内部属性不止简单类型，还有引用类型</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 方式一：通过HttpServletRequest参数，进行接收</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 方式二：通过点来绑定，如示例</p>\n\n<pre><code class=\"language-java\">//页面参数\n&lt;input name=\"parent.name\" /&gt;\n\n//pojo\npublic class Person{\n    private String id;\n    private String name;\n    //...\n}\npublic class PersonVo{\n    private String id;\n    private Person parent;\n    private Person son;\n    //...\n}\n\n//处理器类\n@Controller\n@RequestMapping(method=RequestMethod.POST)\npublic class PersonController {\n    @RequestMapping(\"/setPerson\")\n    public ActionResult setPerson(PersonVo vo) {\n        //...\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、数组</strong>&nbsp;</p>\n\n<pre><code class=\"language-java\">@RequestMapping(\"/deleteItems\")\npublic ActionResult deleteItems(Intege[] item_ids) {\n    //...\n}</code></pre>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</p>\n\n<p><strong>6、List、Map</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前提条件：List、Map需要绑定在对象上</p>\n\n<pre><code class=\"language-xml\">//pojo\npublic class UserForm {\n    private List&lt;User&gt; userList;\n    private Map&lt;String, User&gt; userMap;\n    //...\n}\n\n//处理器类\n@Controller\n@RequestMapping(method=RequestMethod.POST)\npublic class UserController {\n    @RequestMapping(\"/userForm\")\n    public ActionResult userForm(UserForm userForm) {\n        //...\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286059549709725696,'2019-05-08 11:10:59','2019-05-08 11:10:59'),(286061117410537472,'<h1>参数校验</h1>','sys','待编辑','<p><strong>1、服务端校验</strong></p>\n\n<ul>\n	<li>控制层conroller：校验页面请求的参数的合法性。</li>\n	<li>业务层service：主要校验关键业务参数，仅限于service接口中使用的参数。</li>\n	<li>持久层dao：一般是不校验的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、使用校验框架validation</strong></p>\n\n<p>2.1、依赖的jar</p>\n\n<p>2.2、配置校验器：spring-mvc.xml</p>\n\n<pre><code class=\"language-xml\">&lt;!-- 向处理器适配器，注入校验器 --&gt;\n&lt;mvc:annotation-driven  validator=\"validator\"&gt;&lt;/mvc:annotation-driven&gt;\n\n&lt;!-- 配置校验器 --&gt;\n&lt;bean id=\"validator\"\n    class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt;\n    &lt;!-- hibernate校验器--&gt;\n    &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt;\n    &lt;!-- 指定校验器配置文件，在文件中配置校验错误信息，默认使用classpath下的ValidationMessages.properties --&gt;\n    &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt;\n&lt;/bean&gt;\n\n&lt;!-- 校验器的配置文件 --&gt;\n&lt;bean id=\"messageSource\"\n    class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt;\n    &lt;!-- 资源文件名--&gt;\n    &lt;property name=\"basenames\"&gt;   \n       	 &lt;list&gt;    \n            &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt; \n       	 &lt;/list&gt;   \n    	&lt;/property&gt;\n    &lt;!-- 资源文件编码格式 --&gt;\n    &lt;property name=\"fileEncodings\" value=\"utf-8\" /&gt;\n    &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;\n    &lt;property name=\"cacheSeconds\" value=\"120\" /&gt;\n&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2.3、校验器配置文件：CustomValidationMessages.properties</p>\n\n<pre><code class=\"language-ini\">#添加校验失败时的提示信息\nitems.name.length.error=请输入1到30个字符的商品名称</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2.4、pojo配置</p>\n\n<pre><code class=\"language-java\">public class Item {\n    private Integer id;\n\n    //message：校验失败时，提示信息\n    //groups：分组校验，以类定义组名\n    @Size(min=1,max=30,message=\"{items.name.length.error}\",groups={ValidGroup1.class})\n    private String name;\n\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2.5、处理器方法</p>\n\n<pre><code class=\"language-java\">// 用@Validated注释pojo，在pojo后添加BindingResult，接收校验失败提示信息\n// 注意：@Validated和BindingResult bindingResult是配对出现，并且形参顺序是固定的（一前一后）。\n@RequestMapping(\"/editItem\")\npublic String editItem(\n&nbsp;   @Validated(value = { ValidGroup1.class }) Item item,BindingResult bindingResult){\n\n    // 获取校验错误信息\n    if (bindingResult.hasErrors()) {\n        List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();\n        for (ObjectError objectError : allErrors) {\n            // 输出错误信息\n            System.out.println(objectError.getDefaultMessage());\n        }\n    }\n    //......\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286059549709725696,'2019-05-08 14:51:04','2019-05-08 14:51:04'),(286068475465461760,'<h1>数据回显</h1>','sys','待编辑','<p><strong>1、什么是数据回显</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 页面提交后，如果出现错误，将刚才提交的数据回显到提交页面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、方式一：pojo</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>springmvc会自动将形参中的pojo重新放回request域中，key为pojo的类名（首字母小写）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、方式二：@ModelAttribute</strong></p>\n\n<pre><code class=\"language-java\">@RequestMapping(\"/editItem\")\npublic String editItem(@ModelAttribute(\"item\") Item itemCustom){\n    //...	\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、方式三：Model</strong></p>\n\n<pre><code class=\"language-java\">@RequestMapping(\"/editItem\")\npublic String editItem(Model model,Item itemCustom){\n    model.addAttribute(\"item\",itemCustom);\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286059589295566848,'2019-05-08 12:12:21','2019-05-08 12:12:21'),(286084352348942336,'<h1>全局异常处理</h1>','sys','待编辑','<p><strong>1、配置异常处理器</strong>：spring-mvc.xml</p>\n\n<pre><code class=\"language-xml\">&lt;!-- 配置全局异常处理器 --&gt;\n&lt;!-- 只要实现HandlerExceptionResolver接口就是全局异常处理器 --&gt;\n&lt;bean class=\"cn.furesky.cms.exception.CustomExceptionResolver\"&gt;&lt;/bean&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、自定义异常类</strong>：CustomException.java</p>\n\n<pre><code class=\"language-java\">public class CustomException extends Exception {\n    //异常信息\n    public String message;    \n    public CustomException(String message){\n        super(message);\n        this.message = message;\n    }\n    //....\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、全局异常处理器</strong>：CustomExceptionResolver.java</p>\n\n<pre><code class=\"language-java\">public class CustomExceptionResolver implements HandlerExceptionResolver {\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex) {\n\n        CustomException customException = null;\n        if(ex instanceof CustomException){\n            customException = (CustomException)ex;\n        }else{\n            customException = new CustomException(\"未知错误\");\n        }\n        \n        //错误信息\n        String message = customException.getMessage();        \n        ModelAndView modelAndView = new ModelAndView();        \n        //将错误信息传到页面\n        modelAndView.addObject(\"message\", message);        \n        //指向错误页面\n        modelAndView.setViewName(\"error\");        \n        return modelAndView;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286059589295566848,'2019-05-08 12:55:24','2019-05-08 12:55:24'),(286086965240950784,'<h1>上传文件</h1>','sys','待编辑','<p><strong>1、依赖的jar</strong></p>\n\n<p><strong>2、配置解析器</strong>：spring-mvc.xml</p>\n\n<pre><code class=\"language-xml\">&lt;!-- 配置文件上传 --&gt;  \n&lt;bean id=\"multipartResolver\"    \n    class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;    \n    &lt;!-- 默认编码 --&gt;  \n    &lt;property name=\"defaultEncoding\" value=\"utf-8\" /&gt;    \n    &lt;!-- 文件大小最大值 --&gt;  \n    &lt;property name=\"maxUploadSize\" value=\"10485760000\" /&gt;    \n    &lt;!-- 内存中的最大值 --&gt;  \n    &lt;property name=\"maxInMemorySize\" value=\"40960\" /&gt;    \n&lt;/bean&gt;   </code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、上传文件</strong></p>\n\n<pre><code class=\"language-java\">@RequestMapping(\"/uploadFile\")\npublic String uploadFile(MultipartFile pic_file){\n    //原始名称\n    String originalFilename = pic_file.getOriginalFilename();\n    //存储图片的物理路径\n    String pic_path = \"F:\\\\develop\\\\upload\\\\temp\\\\\";\n    //新的图片名称\n    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(\".\"));\n    //新图片\n    File newFile = new File(pic_path+newFileName);    	\n    //将内存中的数据写入磁盘\n    pic_file.transferTo(newFile);\n    	\n    //....\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286059549709725696,'2019-05-08 13:11:33','2019-05-08 13:11:33'),(286091462373699584,'<h1>Json 交互</h1>','sys','待编辑','<p><strong>1、导入jar</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、配置Json转换器</strong>：spring-mvc.xml</p>\n\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">mvc:annotation-driven</span>/&gt;</span></code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、请求方式一：&nbsp;Json 串</strong></p>\n\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//请求json，返回是json</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">requestJson</span><span class=\"hljs-params\">()</span>{</span>    \n    $.ajax({\n        type:<span class=\"hljs-string\">\'post\'</span>,\n        url:<span class=\"hljs-string\">\'x.xxx\'</span>,\n        contentType:<span class=\"hljs-string\">\'application/json;charset=utf-8\'</span>,\n        data:<span class=\"hljs-string\">\'{\"name\":\"手机\",\"price\":999}\'</span>,\n        success:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span>{</span>\n            alert(data.name);\n        }        \n    });    \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、请求方式二： key/value 串</strong></p>\n\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//请求key/value，输出是json</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">responseJson</span><span class=\"hljs-params\">()</span>{</span>    \n    $.ajax({\n        type:<span class=\"hljs-string\">\'post\'</span>,\n        url:<span class=\"hljs-string\">\'x.xxx\'</span>,\n        <span class=\"hljs-comment\">//不需要指定contentType，因为默认就 是key/value类型</span>\n        <span class=\"hljs-comment\">//contentType : \'application/x-www-form-urlencoded; charset=utf-8\',</span>\n        data:<span class=\"hljs-string\">\'name=手机&amp;price=999\'</span>,\n        success:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span>{</span>\n            alert(data.name);\n        }        \n    });    \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、返回方式： Json 串</strong></p>\n\n<pre><code class=\"language-java\"><span class=\"hljs-annotation\">@Controller</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JsonTest</span> {</span>    \n    <span class=\"hljs-annotation\">@RequestMapping</span>(<span class=\"hljs-string\">\"/jsonTest\"</span>)\n    <span class=\"hljs-keyword\">public</span> @ResponseBody Item <span class=\"hljs-title\">jsonTest</span>(Item item){        \n        <span class=\"hljs-comment\">//@ResponseBody将item转成json输出</span>\n        <span class=\"hljs-keyword\">return</span> item;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,285974274438492160,'2019-06-12 19:29:57','2019-06-12 19:29:57'),(286106130668482560,'<h1>RESTfull</h1>','sys','待编辑','<p><strong>1、什么是RESTful</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; RESTful 是一种互联网软件架构，是一种设计风格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、RESTful 原则</strong></p>\n\n<ul>\n	<li>网络上的所有事物都被抽象为资源</li>\n	<li>每个资源都有唯一的标识，对资源的操作不会改变标识</li>\n	<li>同一个资源具有多种表现形式(xml,json等)</li>\n	<li>所有的操作都是无状态的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、RESTful 规范</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）使用 URL 标识资源，URL中原则上不使用“动词”。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）使用标准方法（GET、POST、PUT、PATCH、DELETE）操作资源。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）使用 Json 格式返回结果，并用HTTP状态码进行标识。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、RESTful 示例</strong></p>\n\n<pre><code class=\"language-java\">//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称\n@RequestMapping(\"/item/{id}\")\npublic @ResponseBody Item item(@PathVariable(\"id\") Integer itemId){\n    //....    \n}</code></pre>\n\n<p>&nbsp;</p>\n',0,285974274438492160,'2019-05-08 14:47:32','2019-05-08 14:47:32'),(286149233139937280,'<h1>拦截器</h1>','sys','待编辑','<p><strong>1、配置拦截器</strong>：spring-mvc.xml</p>\n\n<pre><code class=\"language-xml\">&lt;mvc:interceptors&gt;\n    &lt;!--多个拦截器,顺序执行 --&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;!-- /**表示所有url包括子url路径 --&gt;\n        &lt;mvc:mapping path=\"/**\"/&gt;\n        &lt;bean class=\"com.furesky.cms.interceptor.HandlerInterceptor1\"&gt;&lt;/bean&gt;\n    &lt;/mvc:interceptor&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=\"/**\"/&gt;\n        &lt;bean class=\"com.furesky.cms.interceptor.HandlerInterceptor2\"&gt;&lt;/bean&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义拦截器</strong></p>\n\n<pre><code class=\"language-java\">public class HandlerInterceptor1 implements HandlerInterceptor {    \n    //进入 Handler方法之前执行,比如：身份认证、身份授权\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler) throws Exception {        \n        //...\n        \n        //true放行,false拦截\n        return false;\n    }\n\n    //进入Handler方法之后，返回modelAndView之前执行，比如传递公用的模型数据\n    @Override\n    public void postHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        //....        \n    }\n\n    //执行Handler完成后执行，比如：异常处理、日志处理\n    @Override\n    public void afterCompletion(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        //....        \n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、多个拦截器执行顺序</strong></p>\n\n<p>&nbsp;<img alt=\"\" src=\"/furesky/images/201906/20190613-000000-030.png\" style=\"height:274px; width:600px\"></p>\n',0,285974274438492160,'2019-06-12 19:37:58','2019-06-12 19:37:58'),(286156689979109376,'<h1>参考资料</h1>','sys','待编辑','<p><strong>官方参考文档</strong></p>\n\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" target=\"_blank\">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p>\n',0,285596120477757440,'2019-05-18 12:05:02','2019-05-10 16:25:37'),(286156719108550656,'<h1>提问-SpringMVC</h1>','sys','待编辑','<p><strong>1、什么是 SpringMVC？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种基于 Java 的、实现了MVC 设计模式的、请求驱动类型的轻量级 Web 框架。，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便开发人员间的配合</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、SpringMVC 的流程？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）发起请求到前端控制器(DispatcherServlet)。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）前端控制器请求HandlerMapping查找 Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）HandlerMapping向前端控制器返回Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）前端控制器调用HandlerAdapter去执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）HandlerAdapter执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）Handler执行完成后，向HandlerAdapter返回ModelAndView。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）HandlerAdapter将ModelAndView返回给前端控制器。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8）前端控制器将ModelAndView传给ViewReslover。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9）ViewReslover解析后，向前端控制器返回具体View。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10）前端控制器根据View进行渲染视图。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11）前端控制器响应用户。</p>\n\n<p><img alt=\"SpringMVC工作流程\" src=\"/furesky/images/spring/springmvc-flow.png\" style=\"margin-left:50px; margin-right:50px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、SpringMVC 的优点？</strong></p>\n\n<ul>\n	<li>清晰的角色划分，分工明确，可灵活扩展</li>\n	<li>功能强大的数据验证、格式化、绑定机制</li>\n	<li>和 Spring 其他框架无缝集成</li>\n	<li>支持各种请求资源的映射策略</li>\n	<li>支持各种视图技术</li>\n	<li>支持RESTful 风格</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、中文乱码问题？</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong> &nbsp; 1）get乱码</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案一：修改tomcat配置文件：</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案二：对参数进行重新编码：</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String userName=new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\");</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）post乱码：<strong>&nbsp;&nbsp;</strong>修改web.xml文件</p>\n\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;/param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、SpringMVC 与 Struts2 的区别？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）SpringMVC 的入口是一个 servlet 即前端控制器，而 Struts2 入口是一个 filter 过虑器。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）SpringMVC&nbsp;基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;Struts2&nbsp;是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）参数传递方式不同</p>\n\n<p>&nbsp;</p>\n',0,285596120477757440,'2019-06-02 13:02:43','2019-06-02 13:02:43'),(286568521986371584,'<h1>概述</h1>','sys','待编辑','<p><strong>1、Spring Boot 是什么</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Spring Boot 是一个用来简化新 Spring 应用的初始搭建以及开发过程的框架。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Boot 核心功能</strong></p>\n\n<ul>\n	<li>可独立运行 Spring 项目</li>\n	<li>内嵌 servlet 容器</li>\n	<li>提供 starter 简化 Maven 配置</li>\n	<li>自动配置 Spring</li>\n	<li>准生产的应用监控</li>\n	<li>无代码生成和xml配置</li>\n</ul>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Boot 优点</strong></p>\n\n<ul>\n	<li>快速搭建项目</li>\n	<li>对主流框架无配置集成</li>\n	<li>项目可独立运行，不依赖servlet容器</li>\n	<li>提供运行时的应用监控</li>\n	<li>极大提高开发、部署效率</li>\n	<li>与云计算天然集成</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,286568455259189248,'2019-05-10 15:10:34','2019-05-10 15:10:34'),(286577411880808448,'<h1>配置方式的演进</h1>','sys','待编辑','<p><strong>1、基于XML配置</strong>（Spring1.x）</p>\n\n<pre><code class=\"language-xml\">&lt;bean id=\"userService\" class=\"com.sivalabs.myapp.service.UserService\"&gt;\n    &lt;property name=\"userDao\" ref=\"userDao\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"userDao\" class=\"com.sivalabs.myapp.dao.JdbcUserDao\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;\n    &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt;\n    &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt;\n    &lt;property name=\"username\" value=\"root\"/&gt;\n    &lt;property name=\"password\" value=\"secret\"/&gt;\n&lt;/bean&gt;</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、基于注解配置</strong>（Spring2.x）</p>\n\n<pre><code class=\"language-java\">@Service\npublic class UserService{\n    private UserDao userDao;\n    @Autowired\n    public UserService(UserDao dao){\n        this.userDao = dao;\n    }\n    //...\n}\n\n@Repository\npublic class JdbcUserDao{\n    private DataSource dataSource;\n    @Autowired\n    public JdbcUserDao(DataSource dataSource){\n        this.dataSource = dataSource;\n    }\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、基于Java配置</strong>（Spring3.x-4.x）</p>\n\n<pre><code class=\"language-java\">@Configuration\npublic class AppConfig{\n    @Bean\n    public UserService userService(UserDao dao){\n        return new UserService(dao);\n    }\n    @Bean\n    public UserDao userDao(DataSource dataSource){\n        return new JdbcUserDao(dataSource);\n    }\n    @Bean\n    public DataSource dataSource(){\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"secret\");\n        return dataSource;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286568455259189248,'2019-06-20 19:30:35','2019-06-20 19:30:35'),(286577445087113216,'<h1>入门示例</h1>','sys','待编辑','<p><strong>1、maven配置</strong>：pom.xml</p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.furesky&lt;/groupId&gt;\n    &lt;artifactId&gt;springboot&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;springboot&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、SpringBoot项目启动类</strong></p>\n\n<pre><code class=\"language-java\">package com.furesky.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringbootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootApplication.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、controller类</strong></p>\n\n<pre><code class=\"language-java\">package com.furesky.springboot;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class DemoController {\n    @RequestMapping(\"/\")\n    String home() {\n        return \"Hello World!\";\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、测试</strong></p>\n\n<ul>\n	<li>Eclipse中，右键启动类--&gt; Run As --&gt; Java Application</li>\n	<li>浏览器访问http://127.0.0.1:8080/</li>\n</ul>\n',0,286568455259189248,'2019-05-10 12:10:39','2019-05-10 12:10:39'),(286799642670034944,'<h1>入口类</h1>','sys','待编辑','<p><strong>1、入口类</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot的项目一般都会有*Application的入口类，入口类中会有main方法。</p>\n\n<pre><code class=\"language-java\">import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringbootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootApplication.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、@SpringBootApplication</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </strong>Spring Boot 核心注解，主要组合以下注解：</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1）@SpringBootConfiguration：Spring Boot 项目的配置注解</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）@EnableAutoConfiguration：启用自动配置</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）@ComponentScan：默认扫描@SpringBootApplication所在类的同级目录以及它的子目录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、关闭自动配置</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; exclude属性可关闭自动配置。</p>\n\n<pre><code class=\"language-java\">import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n//关闭Redis自动配置\n@SpringBootApplication(exclude ={RedisAutoConfiguration.class})\npublic class SpringbootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootApplication.class, args);\n    }\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、定制 Banner</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）打开网站：<a href=\"http://patorjk.com/software/taag\">http://patorjk.com/software/taag</a></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）复制生成的字符，得到 banner.txt 文件</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）将banner.txt拷贝到项目的resources目录中</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 4）如果想要关闭 Banner，可设置入口类</p>\n\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    SpringApplication app = new SpringApplication(SpringbootApplication.class);\n    app.setShowBanner(false);\n    app.run(args);\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,286799487287848960,'2019-05-10 15:51:31','2019-05-10 15:51:31'),(286799723091619840,'<h1>全局配置文件</h1>','sys','待编辑','<p><strong>1、位置</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 项目使用一个全局的配置文件 application.properties，一般在 resources 下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 例如：修改tomcat的端口为 9090</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在 application.properties 加入：server.port=9090<br>\n&nbsp;</p>\n\n<p><strong>3、配置大全</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ......</p>\n',0,286799487287848960,'2019-05-10 13:06:24','2019-05-10 13:06:24'),(286799760961990656,'<h1>starter pom</h1>','sys','待编辑','<p>Spring Boot/第三方提供了简化企业级开发的starter pom，使用它们可以极大简化Maven配置。</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th>名称</th>\n			<th>描述</th>\n		</tr>\n		<tr>\n			<td>spring-boot-starter</td>\n			<td>核心Spring Boot starter，包括自动配置支持，日志和YAML</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-actuator</td>\n			<td>生产准备的特性，用于帮你监控和管理应用</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-amqp</td>\n			<td>对”高级消息队列协议”的支持，通过<code>spring-rabbit</code>实现</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-aop</td>\n			<td>对面向切面编程的支持，包括<code>spring-aop</code>和AspectJ</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-batch</td>\n			<td>对Spring Batch的支持，包括HSQLDB数据库</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-cloud-connectors</td>\n			<td>对Spring Cloud Connectors的支持，简化在云平台下（例如，Cloud Foundry 和Heroku）服务的连接</td>\n		</tr>\n		<tr>\n			<td>...</td>\n			<td>...</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,286799487287848960,'2019-05-10 13:15:17','2019-05-10 13:15:17'),(286817310957531136,'<h1>xml 配置</h1>','sys','待编辑','<p>Spring提供的<strong>@ImportResource</strong>，可以加载xml配置</p>\n\n<pre><code class=\"language-java\">@ImportResource({\"classpath:somecontext.xml\",\"classpath:another-context.xml\"})</code></pre>\n\n<p>&nbsp;</p>\n',0,286799487287848960,'2019-05-10 13:18:47','2019-05-10 13:18:47'),(286823840398340096,'<h1>参考资料</h1>','sys','待编辑','<p><strong>官方参考文档</strong></p>\n\n<p><a href=\"https://spring.io/projects/spring-boot#learn\" target=\"_blank\">https://spring.io/projects/spring-boot#learn</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>中文参考文档</strong></p>\n\n<p><a href=\"https://springcloud.cc/spring-boot.html\" target=\"_blank\">https://springcloud.cc/spring-boot.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>定制 Banner</strong></p>\n\n<p><a href=\"http://patorjk.com/software/taag\" target=\"_blank\">http://patorjk.com/software/taag</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>生成 Spring Boot 项目</strong></p>\n\n<p><a href=\"https://start.spring.io/\" target=\"_blank\">https://start.spring.io/</a></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,286428845560459264,'2019-05-18 12:03:40','2019-05-10 16:25:01'),(286854967557255168,'<h1>提问-SpringBoot</h1>','sys','待编辑','<p><strong>1.1、Spring Boot 是什么？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Spring Boot 是一个用来简化新 Spring 应用的初始搭建以及开发过程的框架。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1.2、Spring Boot 核心功能？</strong></p>\n\n<ul>\n	<li>可独立运行 Spring 项目</li>\n	<li>内嵌 servlet 容器</li>\n	<li>提供 starter 简化 Maven 配置</li>\n	<li>自动配置 Spring</li>\n	<li>准生产的应用监控</li>\n	<li>无代码生成和xml配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>1.3、Spring Boot 优点？</strong></p>\n\n<ul>\n	<li>快速搭建项目</li>\n	<li>对主流框架无配置集成</li>\n	<li>项目可独立运行，不依赖servlet容器</li>\n	<li>提供运行时的应用监控</li>\n	<li>极大提高开发、部署效率</li>\n	<li>与云计算天然集成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>1.4、Spring Boot 自动配置原理？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 spring 程序main方法中，添加@SpringBootApplication或者@EnableAutoConfiguration后，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 框架会自动去 maven 中读取每个 starter 中的 spring.factories 文件。该文件里配置了所有需要被创建的spring bean。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Boot 核心注解？</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</strong> @SpringBootApplication，主要组合以下注解：</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1）@SpringBootConfiguration：Spring Boot 项目的配置注解</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）@EnableAutoConfiguration：启用自动配置</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）@ComponentScan：默认扫描@SpringBootApplication所在类的同级目录以及它的子目录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring Boot 常用的starter？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>spring-boot-starter</td>\n			<td>Spring Boot 核心 starter，包括自动配置、日志、yaml配置文件支持</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-web</td>\n			<td>\n			<p>对web项目开发的支持，包括Tomcat与spring-webmvc</p>\n			</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-test</td>\n			<td>测试工具支持</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-data-redis</td>\n			<td>集成redis缓存</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-data-jpa</td>\n			<td>数据库支持</td>\n		</tr>\n		<tr>\n			<td>mybatis-spring-boot-starter</td>\n			<td>第三方的mybatis集成starter</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4.1、Spring Boot 读取配置文件的方式？</strong></p>\n\n<ul>\n	<li>application.properties</li>\n	<li>application.yml</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4.2、Spring Boot 读取配置属性的方式？</strong></p>\n\n<ul>\n	<li>@PropertySource</li>\n	<li>@Value</li>\n	<li>@Environment</li>\n	<li>@ConfigurationProperties</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4.3、Spring Boot 如何兼容老 Spring 项目？</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ImportResource 注解导入老 Spring 项目配置文件。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5.1、如何开启 Spring Boot？</strong></p>\n\n<ul>\n	<li>继承spring-boot-starter-parent项目</li>\n	<li>导入spring-boot-dependencies项目依赖</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5.2、如何运行 Spring Boot 项目？</strong></p>\n\n<ul>\n	<li>打包用命令或者放到容器中运行</li>\n	<li>用 Maven/ Gradle 插件运行</li>\n	<li>执行 main 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、Spring Boot 热启动方式？</strong></p>\n\n<ul>\n	<li>方式一：spring-boot-devtools</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;!-- pom.xml --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>方式二：springloaded</li>\n</ul>\n\n<pre><code class=\"language-xml\">&lt;!-- pom.xml --&gt;\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;dependencies&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;\n                    &lt;version&gt;1.2.5.RELEASE&lt;/version&gt;\n                &lt;/dependency&gt;\n            &lt;/dependencies&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n\n&lt;!-- 以命令方式启动 --&gt;\nmvn spring-boot:run </code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,286428845560459264,'2019-06-02 13:04:44','2019-06-02 13:04:44'),(287213604255461376,'<h1>数据库</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 数据库：按照数据结构来组织、存储和管理数据的仓库。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、关系型数据库</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 采用了关系模型来组织数据的数据库。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>代表</strong>：Microsoft Access、SQL Server、Mysql、Oracle、DB2</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <strong>优点</strong>：容易理解、使用方便、易于维护</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<strong> 缺点</strong>：海量数据的读写效率低、难以横向扩展&nbsp; &nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、非关系型数据库</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>主要指非关系型的、分布式的，且一般不保证ACID的数据存储系统</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>代表</strong>：MongoDB、Redis、CouchDB</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <strong>优点</strong>：善于处理海量数据、支持分布式集群，负载均衡，性能高</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<strong> 缺点</strong>：事务处理能力弱、数据间没有关系、对于复杂业务场景支持较差</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、术语</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>关系数据库管理系统(Relational Database Management System)：</p>\n\n<ul>\n	<li><strong>数据库</strong>：数据库是一些关联表的集合。</li>\n	<li><strong>数据表</strong>：表是数据的矩阵。</li>\n	<li><strong>列</strong>：一列(数据元素) 包含了相同的数据。</li>\n	<li><strong>行</strong>：一行（=元组，或记录）是一组相关的数据。</li>\n	<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>\n	<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。</li>\n	<li><strong>外键</strong>：外键用于关联两个表。</li>\n	<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>\n	<li><strong>索引</strong>：使用索引可快速访问数据库表中的特定信息。</li>\n	<li><strong>参照完整性</strong>：参照的完整性要求关系中不允许引用不存在的实体。</li>\n</ul>\n',0,287212421000359936,'2019-06-05 23:03:15','2019-06-05 23:03:15'),(287223054903177216,'<h1>SQL</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构化查询语言，Structured Query Language，简称SQL。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、分类</strong></p>\n\n<ul>\n	<li>数据定义语句&nbsp; DDL（Data Definition Language）</li>\n	<li>数据操纵语句&nbsp; DML（Data Manipulation Language）</li>\n	<li>数据查询语句&nbsp; DQL（Data Query Language）</li>\n	<li>数据控制语句&nbsp; DCL（Data Control Language）</li>\n</ul>\n',0,287212421000359936,'2019-05-30 06:21:15','2019-05-30 06:21:15'),(287225627756359680,'<h1>MySQL</h1>','sys','待编辑','<p><strong>1、MySQL是什么</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>是一个关系型数据库管理系统，是&nbsp;Oracle 旗下产品。开源免费，且十分流行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、安装（略）</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、开/关服务</strong>&nbsp;</p>\n\n<pre><code  class=\"language-html\">开：net start mysql\n关：net stop mysql</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、登录</strong>&nbsp;</p>\n\n<pre><code class=\"language-html\">mysql -h主机地址 -P端口 -u用户名 -p密码</code></pre>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p><strong>5、退出</strong>&nbsp;</p>\n\n<pre><code class=\"language-html\">exit\n\\q\nquit</code></pre>\n\n\n\n<p>&nbsp;</p>\n\n<p><strong>6、备份</strong></p>\n\n<pre><code>mysqldump&nbsp; -h-P-u-p&nbsp; &nbsp;数据库名 [表1 &nbsp; [表2…]]&nbsp; &gt;&nbsp; 备份文件地址</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、还原</strong>&nbsp;</p>\n\n<pre><code  class=\"language-html\">mysql&nbsp;&nbsp;-h-P-u-p&nbsp; &nbsp;数据库名&nbsp; &lt;&nbsp; 备份文件地址\nsource &nbsp;备份文件地址;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;              //必须先进入到对应的数据库</code></pre>\n\n<p>&nbsp;</p>\n',0,287212421000359936,'2019-05-13 01:32:37','2019-05-13 01:31:20'),(287238061086896128,'<h1>操作-数据库</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<pre><code class=\"language-sql\">-- 创建\ncreate database 库名 [charset = 字符集] [collate&nbsp;= 校对集];&nbsp;\n\n\n-- 选择\nuse 库名;&nbsp;\n\n\n-- 显示\nshow create database&nbsp;库名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;    //显示库结构\nshow databases [like \'...\'];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //显示库名\nselect database();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//显示当前库名 \n\n\n-- 修改\nalter database 库名 [charset&nbsp;= 字符集]/[collate&nbsp;= 校对集];\n\n\n-- 删除\ndrop database 库名;</code></pre>\n\n<p>&nbsp;</p>\n',0,287457461102604288,'2019-05-14 15:39:46','2019-05-14 15:39:46'),(287251178105761792,'<h1>操作-数据表</h1>','sys','待编辑','<p><strong>1、创建</strong></p>\n\n<pre><code class=\"language-sql\">-- 语法\ncreate table 表名(列名 列类型 [长度],...) [engine = 存储引擎] [charset = 字符集] [collate = 校对集];\n\n-- 示例\nCREATE TABLE IF NOT EXISTS `runoob_tbl`(\n   `runoob_id` INT UNSIGNED AUTO_INCREMENT,\n   `runoob_title` VARCHAR(100) NOT NULL,\n   `runoob_author` VARCHAR(40) NOT NULL,\n   `submission_date` DATE,\n   PRIMARY KEY ( `runoob_id` )\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、复制</strong></p>\n\n<pre><code class=\"language-sql\">create table 新表名 like [数据库名.]表名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、显示</strong>&nbsp;</p>\n\n<pre><code class=\"language-sql\">show create table 表名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//显示表结构\nshow columns from 表名;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//显示列结构\ndescribe 表名;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //同上\ndesc 表名;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //同上\nshow tables [like \'...\'];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //显示表名\n</code></pre>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p><strong>4、修改</strong></p>\n\n<pre><code class=\"language-sql\">rename table 旧表名 to 新表名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                      //改表名\nalter table 表名 [engine=存储引擎]/[charset=字符集]/[collate=校对集];&nbsp;&nbsp;&nbsp;&nbsp; //改选项\nalter table 表名 drop 列名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                //删除列\n\nalter table 表名 change 旧列名 新列名  列类型 [列属性] [first]/[after 字段名];&nbsp;&nbsp;//改列名\nalter table 表名 modify 列名          列类型 [列属性] [first]/[after 字段名];&nbsp; //改列类型\nalter table 表名 add    列名 &nbsp;        列类型 [列属性] [first]/[after 字段名]; &nbsp;//添加列\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、删除</strong>&nbsp;</p>\n\n<pre><code class=\"language-sql\">drop table 表名;\ntruncate 表名;\ndelete from 表名;</code></pre>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">区别项</th>\n			<th scope=\"col\">drop</th>\n			<th scope=\"col\">truncate</th>\n			<th scope=\"col\">delete</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>速度</td>\n			<td>快</td>\n			<td>中</td>\n			<td>慢</td>\n		</tr>\n		<tr>\n			<td>空间</td>\n			<td>释放全部空间</td>\n			<td>恢复到初始大小</td>\n			<td>不释放空间</td>\n		</tr>\n		<tr>\n			<td>表结构</td>\n			<td>删除</td>\n			<td>不删</td>\n			<td>不删</td>\n		</tr>\n		<tr>\n			<td>类型</td>\n			<td colspan=\"2\" rowspan=\"1\">DDL</td>\n			<td>DML</td>\n		</tr>\n		<tr>\n			<td>事务</td>\n			<td colspan=\"2\" rowspan=\"1\">不支持</td>\n			<td>支持</td>\n		</tr>\n		<tr>\n			<td>trigger</td>\n			<td colspan=\"2\" rowspan=\"1\">不触发</td>\n			<td>触发</td>\n		</tr>\n		<tr>\n			<td>生效时机</td>\n			<td colspan=\"2\" rowspan=\"1\">执行立即生效</td>\n			<td>事务提交后生效</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,287457461102604288,'2019-05-14 15:43:03','2019-05-14 15:43:03'),(287387199434813440,'<h1>操作-数据记录</h1>','sys','待编辑','<p><strong>1、语法</strong></p>\n\n<pre><code class=\"language-sql\">-- 插入\ninsert into 表名(列名, .... ) values(列值, ....);&nbsp;&nbsp;&nbsp;&nbsp;//省略部分列名：列名与列值必须相对应\ninsert into 表名 values(列值, ....);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//省略全部列名：需提供表所有列的值\n\n\n-- 查询\nselect [*]/[列名，…] from 表名 [where 条件];\n\n\n-- 修改\nupdate 表名 set 列名=值,… [where 条件];\n\n\n-- 删除\ndelete from 表名 [where 条件];</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-sql\">--插入\nINSERT INTO table_name (\n   field1,field2,...,fieldN\n)VALUES(\n   value1,value2,...,valueN\n);\n\n--查询\nSELECT \n    field1,\n    field2,\n    ...,\n    fieldN\nFROM table_name\nWHERE field1 = value1;\n\n\n--更新\nUPDATE table_name a SET\n    a.field1= value1,\n    a.field2= value2,\n    ... ,\n    a.fieldN= valueN\nWHERE field1 = value1;\n\n--删除\nDELETE FROM table_name WHERE field1 = value1;</code></pre>\n\n<p>&nbsp;</p>\n',0,287457461102604288,'2019-05-14 15:39:36','2019-05-14 15:39:36'),(287458988882030592,'<h1>数据类型</h1>','sys','待编辑','<p>1<strong>、整数类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th>类型</th>\n			<th>描述</th>\n			<th>大小</th>\n			<th>范围（有符号）</th>\n			<th>范围（无符号）</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>TINYINT</td>\n			<td>迷你整形</td>\n			<td>1 字节</td>\n			<td>(-128，127)</td>\n			<td>(0，255)</td>\n		</tr>\n		<tr>\n			<td>SMALLINT</td>\n			<td>小整形</td>\n			<td>2 字节</td>\n			<td>(-32 768，32 767)</td>\n			<td>(0，65 535)</td>\n		</tr>\n		<tr>\n			<td>MEDIUMINT</td>\n			<td>中整形</td>\n			<td>3 字节</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>INT或INTEGER</td>\n			<td>标准整形</td>\n			<td>4 字节</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>BIGINT</td>\n			<td>大整形</td>\n			<td>8 字节</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、小数类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">大小</th>\n			<th scope=\"col\">语法</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>FLOAT</td>\n			<td>单精度浮点型</td>\n			<td>4 字节</td>\n			<td colspan=\"1\" rowspan=\"3\">\n			<p>例：Float(M,D)</p>\n\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M表示数值总位数</p>\n\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D代表小数部分位数</p>\n			</td>\n		</tr>\n		<tr>\n			<td>DOUBLE</td>\n			<td>双精度浮点型</td>\n			<td>8 字节</td>\n		</tr>\n		<tr>\n			<td>DECIMAL</td>\n			<td>数值型</td>\n			<td>16 字节</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、日期时间类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">大小</th>\n			<th scope=\"col\">格式</th>\n			<th scope=\"col\">范围</th>\n			<th scope=\"col\">0值</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>YEAR</td>\n			<td>年</td>\n			<td>1 字节</td>\n			<td>YYYY</td>\n			<td>1901&nbsp; ~&nbsp; 2155</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>DATE</td>\n			<td>日期</td>\n			<td>3 字节</td>\n			<td>YYYY-MM-DD</td>\n			<td>1000-01-01&nbsp; ~&nbsp; 9999-12-31</td>\n			<td>0000-00-00</td>\n		</tr>\n		<tr>\n			<td>TIME</td>\n			<td>时间</td>\n			<td>3 字节</td>\n			<td>HH:MM:SS</td>\n			<td>\'-838:59:59\'&nbsp; ~&nbsp; \'838:59:59\'</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>TIMESTAMP</td>\n			<td>时间戳</td>\n			<td>4 字节</td>\n			<td>YYYYMMDD HHMMSS</td>\n			<td>1970-01-01 00:00:00&nbsp; ~&nbsp; 2038</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>DATETIME</td>\n			<td>日期时间</td>\n			<td>8 字节</td>\n			<td>YYYY-MM-DD HH:MM:SS</td>\n			<td>1000-01-01 00:00:00&nbsp; ~&nbsp; 9999-12-31 23:59:59</td>\n			<td>0000-00-00 00:00:00</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、字符串类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">大小</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>CHAR</td>\n			<td>定长字符</td>\n			<td>0-255字节</td>\n		</tr>\n		<tr>\n			<td>VARCHAR</td>\n			<td>变长字符</td>\n			<td>0-65535 字节</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>TINYTEXT</td>\n			<td>短文本</td>\n			<td>0-255字节</td>\n		</tr>\n		<tr>\n			<td>TEXT</td>\n			<td>文本</td>\n			<td>0-65 535字节</td>\n		</tr>\n		<tr>\n			<td>MEDIUMTEXT</td>\n			<td>长文本</td>\n			<td>0-16 777 215字节</td>\n		</tr>\n		<tr>\n			<td>LONGTEXT</td>\n			<td>极大文本</td>\n			<td>0-4 294 967 295字节</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>TINYBLOB</td>\n			<td>二进制，短文本</td>\n			<td>0-255字节</td>\n		</tr>\n		<tr>\n			<td>BLOB</td>\n			<td>二进制，文本</td>\n			<td>0-65 535字节</td>\n		</tr>\n		<tr>\n			<td>MEDIUMBLOB</td>\n			<td>二进制，长文本</td>\n			<td>0-16 777 215字节</td>\n		</tr>\n		<tr>\n			<td>LONGBLOB</td>\n			<td>二进制，极大文本</td>\n			<td>0-4 294 967 295字节</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,287456761731772416,'2019-05-14 15:20:56','2019-05-14 15:20:56'),(287458988882030600,'<h1>运算符</h1>','sys','待编辑','<p><strong>1、算术运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:350px\">\n	<tbody>\n		<tr>\n			<th>运算符</th>\n			<th>作用</th>\n		</tr>\n		<tr>\n			<td>+</td>\n			<td>加法</td>\n		</tr>\n		<tr>\n			<td>-</td>\n			<td>减法</td>\n		</tr>\n		<tr>\n			<td>*</td>\n			<td>乘法</td>\n		</tr>\n		<tr>\n			<td>/ 或 DIV</td>\n			<td>除法</td>\n		</tr>\n		<tr>\n			<td>% 或 MOD</td>\n			<td>取余</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、比较运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px\">\n	<tbody>\n		<tr>\n			<th>符号</th>\n			<th>描述</th>\n			<th>符号</th>\n			<th>描述</th>\n		</tr>\n		<tr>\n			<td>=</td>\n			<td>等于</td>\n			<td>BETWEEN</td>\n			<td>在两值之间</td>\n		</tr>\n		<tr>\n			<td>&lt;&gt;, !=</td>\n			<td>不等于</td>\n			<td>NOT BETWEEN</td>\n			<td>不在两值之间</td>\n		</tr>\n		<tr>\n			<td>&gt;</td>\n			<td>大于</td>\n			<td>IN</td>\n			<td>在集合中</td>\n		</tr>\n		<tr>\n			<td>&lt;</td>\n			<td>小于</td>\n			<td>NOT IN</td>\n			<td>不在集合中</td>\n		</tr>\n		<tr>\n			<td>&lt;=</td>\n			<td>小于等于</td>\n			<td>IS NULL</td>\n			<td>为空</td>\n		</tr>\n		<tr>\n			<td>&gt;=</td>\n			<td>大于等于</td>\n			<td>IS NOT NULL</td>\n			<td>不为空</td>\n		</tr>\n		<tr>\n			<td>&lt;=&gt;</td>\n			<td>含NULL值的比较</td>\n			<td>LIKE</td>\n			<td>模糊匹配</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>RLIK 或 EREGEXP</td>\n			<td>正则式匹配</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>备注：LIKE子句中，可使用占位符</p>\n\n<ul>\n	<li>代表多个字符&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%&nbsp;</li>\n	<li>代表单个字符&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、逻辑运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:350px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<th>运算符号</th>\n			<th>作用</th>\n		</tr>\n		<tr>\n			<td>NOT 或 !</td>\n			<td>逻辑非</td>\n		</tr>\n		<tr>\n			<td>AND</td>\n			<td>逻辑与</td>\n		</tr>\n		<tr>\n			<td>OR</td>\n			<td>逻辑或</td>\n		</tr>\n		<tr>\n			<td>XOR</td>\n			<td>逻辑异或</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、位运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:350px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<th>运算符号</th>\n			<th>作用</th>\n		</tr>\n		<tr>\n			<td>&amp;</td>\n			<td>按位与</td>\n		</tr>\n		<tr>\n			<td>|</td>\n			<td>按位或</td>\n		</tr>\n		<tr>\n			<td>^</td>\n			<td>按位异或</td>\n		</tr>\n		<tr>\n			<td>!</td>\n			<td>取反</td>\n		</tr>\n		<tr>\n			<td>&lt;&lt;</td>\n			<td>左移</td>\n		</tr>\n		<tr>\n			<td>&gt;&gt;</td>\n			<td>右移</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,287456761731772416,'2019-05-13 01:09:12','2019-05-13 01:09:12'),(287483161205436416,'<h1>列属性</h1>','sys','待编辑','<p><strong>1、null、not null</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据列是否允许NULL值。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计表的时候，尽量不要让数据为空。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p><strong>2、default</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 默认值，如果没有数据插入，以默认值进行填充。通常是NULL。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、comment</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 列的注释说明。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、unsigned、zerofill</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNSIGNED：数值型数据，无符号</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZEROFILL：当存储的数值型数据未达到显示长度时，在左侧补0，适用于正数数值</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、auto_increment</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动递增，适用于整数类型</p>\n\n<pre><code class=\"language-sql\">show&nbsp; variables&nbsp; like&nbsp; \'auto_increment%\';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//查询自动递增变量\nalter&nbsp; table&nbsp; 表名&nbsp; auto_increment&nbsp; =&nbsp; 值;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//修改步长</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、primary key</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 主键，在一张表中，有且只有一个主键。</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 不能为空，且具有唯一性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<pre><code class=\"language-sql\">alter&nbsp; table&nbsp; 表名&nbsp; add&nbsp; primary&nbsp; key(字段);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//修改\nalter&nbsp; table&nbsp; 表名&nbsp; drop&nbsp; primary&nbsp; key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//删除</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、foreign key</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 外键，表示两表间的关系。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般不设外键，影响数据库效率，外键关系一般由业务来实现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>6、unique</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 唯一键，在不为空的情况下，不允许重复。&nbsp;&nbsp;</p>\n\n<pre><code class=\"language-sql\">alter&nbsp; table&nbsp; 表名&nbsp;&nbsp;add&nbsp; unique&nbsp; key(字段);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//修改\nalter&nbsp; table&nbsp; 表名&nbsp; drop&nbsp; index&nbsp;&nbsp;键名;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//删除</code></pre>\n\n<p>&nbsp;</p>\n',0,287456761731772416,'2019-05-13 01:35:33','2019-05-13 01:35:33'),(287483161205436420,'<h1>字符集</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符集，Character set，是多个字符的集合。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 场景字符集：ASCII、GB2312、Unicode</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、数据库字符集</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; MySQL使用变量来存储字符集：</p>\n\n<ul>\n	<li>character_set_client&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; //客户端传入数据给服务端</li>\n	<li>character_set_results&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //服务端返回数据给客户端 &nbsp; &nbsp;&nbsp;</li>\n	<li>character_set_connection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//客户端与服务端之间的连接</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、查询数据库字符集</strong></p>\n\n<pre><code class=\"language-sql\">show variables like \'character_set_%\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、设置数据库字符集</strong>&nbsp;</p>\n\n<pre><code class=\"language-sql\">set&nbsp; names&nbsp; 字符集;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //同时设置\nset&nbsp; 变量名 = 值;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //单个设置</code></pre>\n\n<p>&nbsp;</p>\n',0,287456761731772416,'2019-05-13 01:36:40','2019-05-13 01:36:40'),(287504203441401856,'<h1>表关系</h1>','sys','待编辑','<p><strong>1、一对一</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表设计：将任何一方主键作为外键，添加到另一方</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、一对多</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表设计：将非多方表主键作为外键，添加到多方表，</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、多对多</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 表设计：将两实体表主键作为外键，添加到第三张数据表</p>\n',0,287456761731772416,'2019-05-12 18:14:36','2019-05-12 18:14:36'),(287506728353689600,'<h1>其他</h1>','sys','待编辑','<p><strong>1、语句结束符</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 常用结束符，列名显示在上边，值显示在下边；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; \\g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;效果与分号一样</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; \\G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名显示在左边，值显示在右边；</p>\n',0,287456761731772416,'2019-05-12 10:56:22','2019-05-12 10:56:22'),(287514220466958336,'<h1>条件查询</h1>','sys','待编辑','<p><strong>1、完整查询语句</strong></p>\n\n<pre><code class=\"language-sql\">select  [distinct去重]  字段列表  from数据源  where条件  group by分组  having条件  order by排序  limit限制;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、FROM</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 为查询提供数据源。</p>\n\n<ul>\n	<li>单表数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //格式：from&nbsp; 表名</li>\n	<li>多表数据&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //各表的记录数相乘，字段数拼接（应尽量避免）。格式：from&nbsp; 表1,表2…</li>\n	<li>动态数据&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //格式：from (子查询语句) as 别名</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、WHERE</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 对从数据表获取的数据进行条件筛选。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、GROUP BY</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 根据指定的字段，将数据进行分组，方便数据统计。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 聚合函数：统计数量count()、求平均值avg()、求和sum()、求最大值max()、求最小值min()...</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、HAVING</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和where一样，是用来对数据进行条件筛选。</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">where</th>\n			<th scope=\"col\">having</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\">原理</td>\n			<td>一条条从磁盘读取数据，判断条件，放入内存</td>\n			<td>将所有数据读入内存，在内存内部，逐条判断</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\">使用别名</td>\n			<td>不能</td>\n			<td>可以</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\">使用聚合函数</td>\n			<td>不能</td>\n			<td>可以</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、ORDER BY</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据校对规则对数据进行排序。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 格式：order&nbsp; by&nbsp; 字段&nbsp; [asc|desc];&nbsp;&nbsp; &nbsp;<br>\n&nbsp;</p>\n\n<p><strong>7、LIMIT</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 1）限制数量</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 2）限制获取指定区间的数据，即分页。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式：limit offset,length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //offset：偏移量（从0起），length：条数</p>\n',0,287512265581555712,'2019-05-13 01:38:15','2019-05-13 01:38:15'),(287565744098406400,'<h1>联合查询</h1>','sys','待编辑','<p><strong>1、UNION</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 将多个子查询的结果，组合到一个结果集合中。（子查询所查询的列数量须相同）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、格式</strong></p>\n\n<pre><code class=\"language-sql\">SELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nUNION [ALL | DISTINCT]\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<pre><code class=\"language-sql\">SELECT country, name FROM Websites\nWHERE country=\'CN\'\nUNION ALL\nSELECT country, app_name FROM apps\nWHERE country=\'CN\'\nORDER BY country;</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555712,'2019-05-12 15:25:34','2019-05-12 15:25:34'),(287572539722330112,'<h1>连接查询</h1>','sys','待编辑','<p><strong>1、内连接：INNER JOIN</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取两个表中，符合字段匹配关系的记录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、左连接：LEFT JOIN</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取左表所有记录，即使右表没有对应匹配的记录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、右连接：RIGHT JOIN</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取右表所有记录，即使左表没有对应匹配的记录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、示例</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    a.id, \n    a.author, \n    b.count \nFROM a_tb a \nINNER JOIN b_tb b ON a.author = b.author;</code></pre>\n',0,287512265581555712,'2019-05-12 15:36:29','2019-05-12 15:36:29'),(287579669523230720,'<h1>子查询</h1>','sys','待编辑','<p><strong>1、子查询</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指在一条select语句中，嵌入了另外一条select语句，那么被嵌入的select语句称之为子查询语句。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、关键字</strong></p>\n\n<ul>\n	<li>IN( 子查询 )</li>\n	<li>ANY( 子查询 )</li>\n	<li>SOME( 子查询 )</li>\n	<li>ALL( 子查询 )</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、分类</strong></p>\n\n<p><strong>3.1、子查询返回单一值</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    * \nFROM article \nWHERE user_id = (\n    SELECT \n        user_id \n    FROM user \n    WHERE user_name=\'Jack\' LIMIT 1\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.2、子查询返回列</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    * \nFROM article \nWHERE user_id IN(\n    SELECT \n        user_id \n    FROM user WHERE status=1\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.3、子查询返回行</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    * \nFROM article \nWHERE (title,content,uid) = (\n    SELECT \n        title,content,uid \n    FROM blog \n    WHERE bid=2\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.4、子查询返回表</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    * \nFROM article \nWHERE (title,content,uid) IN (\n    SELECT \n        title,content,uid \n    FROM blog\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.5、子查询返回0/1</strong></p>\n\n<pre><code class=\"language-sql\">SELECT \n    *\nFROM table1\nWHERE city=\'hangzhou\' and exists(\n    select \n        *\n    from table2\n    where table1.customer_id=table2.customer_id\n);</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555712,'2019-05-12 16:14:23','2019-05-12 16:14:23'),(287588100380454912,'<h1>用户管理</h1>','sys','待编辑','<p><strong>1、查询用户信息</strong>&nbsp;</p>\n\n<pre><code class=\"language-sql\">select&nbsp;*&nbsp;from&nbsp;mysql.user;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建用户</strong></p>\n\n<pre><code class=\"language-sql\">-- @后为主机域，可使用占位符\ncreate user \'username\'@\'localhost\' identified by \'password\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、删除用户</strong></p>\n\n<pre><code class=\"language-sql\">drop user \'username\'@\'localhost\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、修改用户密码</strong></p>\n\n<pre><code class=\"language-sql\">-- 修改root用户密码\nmysqladmin -u root -h localhost -p password \"password\"\n\n-- root用户修改普通用户密码\nset password for \'username\'@\'localhost\'=password(\'password\');</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555720,'2019-05-13 01:02:01','2019-05-12 16:38:23'),(287593028859621376,'<h1>权限管理</h1>','sys','待编辑','<p><strong>1、权限分类</strong></p>\n\n<ul>\n	<li>数据权限：增删改查（select\\update\\delete\\insert）</li>\n	<li>结构权限：结构操作（create\\drop）</li>\n	<li>管理权限：权限管理（create user\\grant\\revoke）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、授予权限：grant</strong></p>\n\n<pre><code class=\"language-sql\">-- grant&nbsp; 权限列表&nbsp; on&nbsp; 数据库.表名&nbsp; to&nbsp; 用户;\n\n\n-- 授予username用户，所有数据库所有表的，增删改查权限\ngrant select,insert,update,delete on *.* to \'username\'@\'localhost\';\n-- 授予username用户，所有数据库所有表的，所有权限\ngrant all on *.* to \'username\'@\'localhost\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、取消权限：revoke</strong></p>\n\n<pre><code class=\"language-sql\">-- revoke&nbsp; 权限列表&nbsp; on&nbsp; 数据库.表&nbsp; from&nbsp; 用户;\n\n\n-- 取消username用户，所有库所有表的，插入权限\nrevoke insert on *.* from \'username\'@\'localhost\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、刷新权限</strong></p>\n\n<pre><code class=\"language-sql\">flush privileges;</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555720,'2019-05-13 01:02:05','2019-05-12 16:55:25'),(287604899696242688,'<h1>视图管理</h1>','sys','待编辑','<p><strong>1、创建视图</strong>&nbsp;</p>\n\n<pre><code class=\"language-sql\">create view 视图名 as select指令;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、使用视图</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图是一张虚拟表，可以直接把视图当做“表”来操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、修改视图</strong></p>\n\n<pre><code class=\"language-sql\">alter view 视图名字 as 新select指令;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、删除视图</strong></p>\n\n<pre><code class=\"language-sql\">drop view 视图名;</code></pre>\n\n<p>&nbsp;</p>\n',0,287600438802280448,'2019-05-13 01:41:23','2019-05-13 01:41:23'),(287608264975085568,'<h1>事务</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务，Transaction，一个最小的不可再分的工作单元，通常对应一个完整的业务。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、原理</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mysql允许将事务统一进行管理（存储引擎INNODB），先将用户所做的操作暂时保存成操作日志，等到确认之后，再进行操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、事务特性：ACID</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>原子性</td>\n			<td>Atomicity</td>\n			<td>事务应该当作一个单独单元的操作，要么成功，要么失败</td>\n		</tr>\n		<tr>\n			<td>一致性</td>\n			<td>Consistency</td>\n			<td>事务的执行不能破坏数据库数据的完整性和一致性</td>\n		</tr>\n		<tr>\n			<td>隔离性</td>\n			<td>Isolation</td>\n			<td>并发事务执行之间无影响</td>\n		</tr>\n		<tr>\n			<td>持久性</td>\n			<td>Durability</td>\n			<td>事务一旦执行成功，它对数据库的数据的改变必须是永久的</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、事务并发问题</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th scope=\"row\">脏读</th>\n			<td>一个事务处理过程里读取了另一个未提交的事务中的数据。</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">不可重复读</th>\n			<td>在一个事务中，对同一条记录，多次查询到的数据值不一致。（针对 update）</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">幻读</th>\n			<td>在一个事务中，对于多条记录，多次查询到的记录条数不一致。（针对 insert）</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、隔离级别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">隔离级别</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\" style=\"text-align:center\">脏读</th>\n			<th scope=\"col\" style=\"text-align:center\">不可重复读</th>\n			<th scope=\"col\" style=\"text-align:center\">幻读</th>\n		</tr>\n		<tr>\n			<td>级别一</td>\n			<td>读未提交</td>\n			<td>可以读取到其他事务未提交的内容</td>\n			<td style=\"text-align:center\">√</td>\n			<td style=\"text-align:center\">√</td>\n			<td style=\"text-align:center\">√</td>\n		</tr>\n		<tr>\n			<td>级别二</td>\n			<td>读已提交</td>\n			<td>只能读取到其他事务已经提交的数据</td>\n			<td style=\"text-align:center\">×</td>\n			<td style=\"text-align:center\">√</td>\n			<td style=\"text-align:center\">√</td>\n		</tr>\n		<tr>\n			<td>级别三</td>\n			<td>可重复读</td>\n			<td>可以保证整个事务过程中，对同数据的多次读取结果是相同的。MySQL默认级别</td>\n			<td style=\"text-align:center\">×</td>\n			<td style=\"text-align:center\">×</td>\n			<td style=\"text-align:center\">√</td>\n		</tr>\n		<tr>\n			<td>级别四</td>\n			<td>串行化</td>\n			<td>所有事务操作都依次顺序执行，性能最差</td>\n			<td style=\"text-align:center\">×</td>\n			<td style=\"text-align:center\">×</td>\n			<td style=\"text-align:center\">×</td>\n		</tr>\n	</thead>\n</table>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-028.png\" style=\"height:340px; width:584px\"></p>\n\n<p>&nbsp;</p>\n',0,287606829403238400,'2019-06-12 19:19:22','2019-06-12 19:19:22'),(287610470935719936,'<h1>事务管理</h1>','sys','待编辑','<p><strong>1、事务</strong></p>\n\n<pre><code class=\"language-sql\">use RUNOOB;\n\n-- 创建数据表\nCREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  \n \n-- 开启事务\n-- start transaction;\nbegin;  \n \n-- 事务操作\ninsert into runoob_transaction_test value(5); \ninsert into runoob_transaction_test value(6);\n\n-- 回滚事务\n-- rollback;\n-- 提交事务\ncommit;\n\n#结果 \nselect * from runoob_transaction_test;\n+------+\n| id   |\n+------+\n| 5    |\n| 6    |\n+------+</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、回滚点</strong></p>\n\n<pre><code class=\"language-sql\">savepoint 回滚点名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   -- 增加回滚点：&nbsp;&nbsp;&nbsp;&nbsp;\n\nrollback to 回滚点名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;-- 回到回滚点：&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>\n\n<p>&nbsp;</p>\n',0,287606829403238400,'2019-05-13 01:40:52','2019-05-13 01:40:52'),(287721131942506496,'<h1>变量</h1>','sys','待编辑','<p><strong>1、系统变量</strong></p>\n\n<pre><code class=\"language-sql\">-- 查询\nshow variables [like \'...\'];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- 多个\nselect @@变量名;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             -- 单个\n\n\n--修改\nset 变量名 = 新值;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- 局部修改（会话级别） \nset global 变量名 = 新值;           -- 全局修改 \nset @@global.变量名 = 新值;         -- 全局修改      </code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、会话变量</strong></p>\n\n<p>只对当前用户使用的客户端生效</p>\n\n<pre><code class=\"language-sql\">-- 设置\nset @变量名 = 值;\nset @变量名 := 值;\n\n-- 查看\nselect @变量名;\n\n\n-- 示例\nSELECT @name := stu_name,@age := stu_age FROM student WHERE stu_id = \'1\';\nSELECT stu_name,stu_age FROM student WHERE stu_id = \'1\' INTO @name,@age;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、局部变量</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用范围：在begin到end语句之间</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明语法：declare&nbsp; 变量名&nbsp; 数据类型&nbsp; [属性];</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、变量作用域</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 全局作用域：全局有效</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 会话作用域：在当前用户的当次连接有效</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 局部作用域：仅在结构体语句块中有效</p>\n\n<p>&nbsp;</p>\n',0,287512265581555715,'2019-05-13 01:57:38','2019-05-13 01:57:38'),(287721294002024448,'<h1>语句</h1>','sys','待编辑','<p><strong>1、if</strong></p>\n\n<ul>\n	<li>在select查询中，作为条件</li>\n	<li>用在复杂的语句块中（函数/存储过程/触发器）</li>\n</ul>\n\n<pre><code class=\"language-sql\">if(条件,为真结果,为假结果)\n\n\nif &nbsp;条件  then&nbsp;\n    为真时，要执行的语句;\nelse\n    为假时，要执行的语句;\nend &nbsp;if;&nbsp;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、while</strong></p>\n\n<pre><code class=\"language-sql\">while 条件 do\n    要循环执行的语句;\nend while;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、结构标识符</strong></p>\n\n<ul>\n	<li>为某些特定的结构进行命名，方便在某些地方使用。</li>\n</ul>\n\n<pre><code class=\"language-sql\">标识名:while 条件 do\n    循环体\nend while [标识名];\n</code></pre>\n\n<ul>\n	<li>在 mysql 中，没有 continue/break，只有 iterate/leave</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- iterate：开始下次循环\n-- leave：跳出循环\n\n标识名:while 条件 do\n    if 条件判断 then\n        循环控制;\n		iterate/leave 标识名;\n	end if;\n    循环体\nend while [标识名];</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555715,'2019-06-20 18:46:57','2019-06-20 18:46:57'),(287721337689894912,'<h1>内置函数</h1>','sys','待编辑','<p>详情请参考：<a href=\"https://www.runoob.com/mysql/mysql-functions.html\">https://www.runoob.com/mysql/mysql-functions.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、数学函数</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<td>max(exp)</td>\n			<td>返回指定字段中的最大值&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</td>\n			<td>sum(exp)&nbsp; &nbsp;&nbsp;</td>\n			<td>返回指定字段的总和&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</td>\n		</tr>\n		<tr>\n			<td>min(exp)</td>\n			<td>返回指定字段中的最小值</td>\n			<td>avg(exp)</td>\n			<td>返回指定字段的平均值</td>\n		</tr>\n		<tr>\n			<td>greatest(exp1, exp2, ...)</td>\n			<td>返回列表中的最大值</td>\n			<td>count(exp)</td>\n			<td>返回指定字段的记录总数</td>\n		</tr>\n		<tr>\n			<td>least(exp1, exp2, ...)</td>\n			<td>返回列表中的最小值</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"4\" style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>exp(x)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>\n			<td>返回 e 的 x 次方&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</td>\n			<td>ceil(x)</td>\n			<td>返回大于或等于 x 的最小整数&nbsp;</td>\n		</tr>\n		<tr>\n			<td>power(x,y)</td>\n			<td>返回 x 的 y 次方</td>\n			<td>round(x)</td>\n			<td>返回离 x 最近的整数</td>\n		</tr>\n		<tr>\n			<td>log(x)</td>\n			<td>返回以 e 为底的对数</td>\n			<td>floor(x)</td>\n			<td>返回小于或等于 x 的最大整数</td>\n		</tr>\n		<tr>\n			<td>log2(x)</td>\n			<td>返回以 2 为底的对数</td>\n			<td>truncate(x,y)</td>\n			<td>返回数值 x 保留到小数点后 y 位的值</td>\n		</tr>\n		<tr>\n			<td>log10(x)</td>\n			<td>返回以 10 为底的对数</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"4\" style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>pi()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>\n			<td>返回圆周率&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>\n			<td>\n			<p>mod(x,y)</p>\n			</td>\n			<td>返回 x 除以 y 以后的余数</td>\n		</tr>\n		<tr>\n			<td>rand()</td>\n			<td>返回 0 到 1 的随机数　</td>\n			<td>n div m</td>\n			<td>整除，n 为被除数，m 为除数</td>\n		</tr>\n		<tr>\n			<td>abs(x)</td>\n			<td>返回 x 的绝对值</td>\n			<td>degrees(x)</td>\n			<td>将弧度转换为角度</td>\n		</tr>\n		<tr>\n			<td>sort(x)</td>\n			<td>返回x的平方根</td>\n			<td>radians(x)&nbsp;</td>\n			<td>将角度转换为弧度</td>\n		</tr>\n		<tr>\n			<td>sign(x)</td>\n			<td>返回 x 的符号</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n	</thead>\n</table>\n\n<p>&nbsp;&nbsp;&nbsp;</p>\n\n<p><strong>2、字符串函数</strong></p>\n\n<table style=\"width:950px\">\n	<tbody>\n		<tr>\n			<td>ASCII(s)</td>\n			<td>返回字符串 s 的第一个字符的 ASCII 码。</td>\n		</tr>\n		<tr>\n			<td>char_length(s)</td>\n			<td>返回字符串 s 的字符数</td>\n		</tr>\n		<tr>\n			<td>concat(s1,s2...sn)</td>\n			<td>合并字符串</td>\n		</tr>\n		<tr>\n			<td>concat_ws(x, s1,s2...sn)</td>\n			<td>加前缀x/分隔符x，合并字符串</td>\n		</tr>\n		<tr>\n			<td>field(s,s1,s2...)</td>\n			<td>返回第一个字符串 s 在字符串列表(s1,s2...)中的位置</td>\n		</tr>\n		<tr>\n			<td>find_in_set(s1,s2)</td>\n			<td>返回在字符串s2中与s1匹配的字符串的位置</td>\n		</tr>\n		<tr>\n			<td>format(x,n)</td>\n			<td>函数可以将数字 x 进行格式化 \"#,###.##\", 将 x 保留到小数点后 n 位，最后一位四舍五入。</td>\n		</tr>\n		<tr>\n			<td>insert(s1,x,len,s2)</td>\n			<td>字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串</td>\n		</tr>\n		<tr>\n			<td>locate(s1,s)</td>\n			<td>从字符串 s 中获取 s1 的开始位置</td>\n		</tr>\n		<tr>\n			<td>left(s,n)</td>\n			<td>返回字符串 s 的前 n 个字符</td>\n		</tr>\n		<tr>\n			<td>lcase(s)</td>\n			<td>转换为小写</td>\n		</tr>\n		<tr>\n			<td>lpad(s1,len,s2)</td>\n			<td>在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td>\n		</tr>\n		<tr>\n			<td>ltrim(s)</td>\n			<td>去掉字符串 s 开始处的空格</td>\n		</tr>\n		<tr>\n			<td>position(s1 IN s)</td>\n			<td>从字符串 s 中获取 s1 的开始位置</td>\n		</tr>\n		<tr>\n			<td>repeat(s,n)</td>\n			<td>将字符串 s 重复 n 次</td>\n		</tr>\n		<tr>\n			<td>replace(s,s1,s2)</td>\n			<td>将字符串 s2 替代字符串 s 中的字符串 s1</td>\n		</tr>\n		<tr>\n			<td>reverse(s)</td>\n			<td>反序</td>\n		</tr>\n		<tr>\n			<td>right(s,n)</td>\n			<td>返回字符串 s 的后 n 个字符</td>\n		</tr>\n		<tr>\n			<td>rpad(s1,len,s2)</td>\n			<td>在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len</td>\n		</tr>\n		<tr>\n			<td>rtrim(s)</td>\n			<td>去掉字符串 s 结尾处的空格</td>\n		</tr>\n		<tr>\n			<td>space(n)</td>\n			<td>返回 n 个空格</td>\n		</tr>\n		<tr>\n			<td>strcmp(s1,s2)</td>\n			<td>比较字符串 s1 和 s2</td>\n		</tr>\n		<tr>\n			<td>substring(s, start, length)</td>\n			<td>从字符串 s 的 start 位置截取长度为 length 的子字符串</td>\n		</tr>\n		<tr>\n			<td>substring_index(s, delimiter, number)</td>\n			<td>返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。</td>\n		</tr>\n		<tr>\n			<td>trim(s)</td>\n			<td>去掉字符串 s 开始和结尾处的空格</td>\n		</tr>\n		<tr>\n			<td>ucase(s)</td>\n			<td>转换为大写</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、日期时间函数</strong></p>\n\n<table style=\"width:950px\">\n	<tbody>\n		<tr>\n			<td>ADDDATE(d,n)</td>\n			<td>计算起始日期 d 加上 n 天的日期</td>\n		</tr>\n		<tr>\n			<td>ADDTIME(t,n)</td>\n			<td>时间 t 加上 n 秒的时间</td>\n		</tr>\n		<tr>\n			<td>CURDATE()</td>\n			<td>返回当前日期</td>\n		</tr>\n		<tr>\n			<td>CURRENT_DATE()</td>\n			<td>返回当前日期</td>\n		</tr>\n		<tr>\n			<td>CURRENT_TIME</td>\n			<td>返回当前时间</td>\n		</tr>\n		<tr>\n			<td>CURRENT_TIMESTAMP()</td>\n			<td>返回当前日期和时间</td>\n		</tr>\n		<tr>\n			<td>CURTIME()</td>\n			<td>返回当前时间</td>\n		</tr>\n		<tr>\n			<td>DATE()</td>\n			<td>从日期或日期时间表达式中提取日期值</td>\n		</tr>\n		<tr>\n			<td>DATEDIFF(d1,d2)</td>\n			<td>计算日期 d1-&gt;d2 之间相隔的天数</td>\n		</tr>\n		<tr>\n			<td>DATE_ADD(d，INTERVAL expr type)</td>\n			<td>计算起始日期 d 加上一个时间段后的日期</td>\n		</tr>\n		<tr>\n			<td>DATE_FORMAT(d,f)</td>\n			<td>按表达式 f的要求显示日期 d</td>\n		</tr>\n		<tr>\n			<td>DATE_SUB(date,INTERVAL expr type)</td>\n			<td>函数从日期减去指定的时间间隔。</td>\n		</tr>\n		<tr>\n			<td>DAY(d)</td>\n			<td>返回日期值 d 的日期部分</td>\n		</tr>\n		<tr>\n			<td>DAYNAME(d)</td>\n			<td>返回日期 d 是星期几，如 Monday,Tuesday</td>\n		</tr>\n		<tr>\n			<td>DAYOFMONTH(d)</td>\n			<td>计算日期 d 是本月的第几天</td>\n		</tr>\n		<tr>\n			<td>DAYOFWEEK(d)</td>\n			<td>日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td>\n		</tr>\n		<tr>\n			<td>DAYOFYEAR(d)</td>\n			<td>计算日期 d 是本年的第几天</td>\n		</tr>\n		<tr>\n			<td>EXTRACT(type FROM d)</td>\n			<td>从日期 d 中获取指定的值，type 指定返回的值。&nbsp;<br>\n			type可取值为：&nbsp;\n			<ul>\n				<li>MICROSECOND</li>\n				<li>SECOND</li>\n				<li>MINUTE</li>\n				<li>HOUR</li>\n				<li>DAY</li>\n				<li>WEEK</li>\n				<li>MONTH</li>\n				<li>QUARTER</li>\n				<li>YEAR</li>\n				<li>SECOND_MICROSECOND</li>\n				<li>MINUTE_MICROSECOND</li>\n				<li>MINUTE_SECOND</li>\n				<li>HOUR_MICROSECOND</li>\n				<li>HOUR_SECOND</li>\n				<li>HOUR_MINUTE</li>\n				<li>DAY_MICROSECOND</li>\n				<li>DAY_SECOND</li>\n				<li>DAY_MINUTE</li>\n				<li>DAY_HOUR</li>\n				<li>YEAR_MONTH</li>\n			</ul>\n			</td>\n		</tr>\n		<tr>\n			<td>FROM_DAYS(n)</td>\n			<td>计算从 0000 年 1 月 1 日开始 n 天后的日期</td>\n		</tr>\n		<tr>\n			<td>HOUR(t)</td>\n			<td>返回 t 中的小时值</td>\n		</tr>\n		<tr>\n			<td>LAST_DAY(d)</td>\n			<td>返回给给定日期的那一月份的最后一天</td>\n		</tr>\n		<tr>\n			<td>LOCALTIME()</td>\n			<td>返回当前日期和时间</td>\n		</tr>\n		<tr>\n			<td>LOCALTIMESTAMP()</td>\n			<td>返回当前日期和时间</td>\n		</tr>\n		<tr>\n			<td>MAKEDATE(year, day-of-year)</td>\n			<td>基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td>\n		</tr>\n		<tr>\n			<td>MAKETIME(hour, minute, second)</td>\n			<td>组合时间，参数分别为小时、分钟、秒</td>\n		</tr>\n		<tr>\n			<td>MICROSECOND(date)</td>\n			<td>返回日期参数所对应的毫秒数</td>\n		</tr>\n		<tr>\n			<td>MINUTE(t)</td>\n			<td>返回 t 中的分钟值</td>\n		</tr>\n		<tr>\n			<td>MONTHNAME(d)</td>\n			<td>返回日期当中的月份名称，如 Janyary</td>\n		</tr>\n		<tr>\n			<td>MONTH(d)</td>\n			<td>返回日期d中的月份值，1 到 12</td>\n		</tr>\n		<tr>\n			<td>NOW()</td>\n			<td>返回当前日期和时间</td>\n		</tr>\n		<tr>\n			<td>PERIOD_ADD(period, number)</td>\n			<td>为 年-月 组合日期添加一个时段</td>\n		</tr>\n		<tr>\n			<td>PERIOD_DIFF(period1, period2)</td>\n			<td>返回两个时段之间的月份差值</td>\n		</tr>\n		<tr>\n			<td>QUARTER(d)</td>\n			<td>返回日期d是第几季节，返回 1 到 4</td>\n		</tr>\n		<tr>\n			<td>SECOND(t)</td>\n			<td>返回 t 中的秒钟值</td>\n		</tr>\n		<tr>\n			<td>SEC_TO_TIME(s)</td>\n			<td>将以秒为单位的时间 s 转换为时分秒的格式</td>\n		</tr>\n		<tr>\n			<td>STR_TO_DATE(string, format_mask)</td>\n			<td>将字符串转变为日期</td>\n		</tr>\n		<tr>\n			<td>SUBDATE(d,n)</td>\n			<td>日期 d 减去 n 天后的日期</td>\n		</tr>\n		<tr>\n			<td>SUBTIME(t,n)</td>\n			<td>时间 t 减去 n 秒的时间</td>\n		</tr>\n		<tr>\n			<td>SYSDATE()</td>\n			<td>返回当前日期和时间</td>\n		</tr>\n		<tr>\n			<td>TIME(expression)</td>\n			<td>提取传入表达式的时间部分</td>\n		</tr>\n		<tr>\n			<td>TIME_FORMAT(t,f)</td>\n			<td>按表达式 f 的要求显示时间 t</td>\n		</tr>\n		<tr>\n			<td>TIME_TO_SEC(t)</td>\n			<td>将时间 t 转换为秒</td>\n		</tr>\n		<tr>\n			<td>TIMEDIFF(time1, time2)</td>\n			<td>计算时间差值</td>\n		</tr>\n		<tr>\n			<td>TIMESTAMP(expression, interval)</td>\n			<td>单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和</td>\n		</tr>\n		<tr>\n			<td>TO_DAYS(d)</td>\n			<td>计算日期 d 距离 0000 年 1 月 1 日的天数</td>\n		</tr>\n		<tr>\n			<td>WEEK(d)</td>\n			<td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td>\n		</tr>\n		<tr>\n			<td>WEEKDAY(d)</td>\n			<td>日期 d 是星期几，0 表示星期一，1 表示星期二</td>\n		</tr>\n		<tr>\n			<td>WEEKOFYEAR(d)</td>\n			<td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td>\n		</tr>\n		<tr>\n			<td>YEAR(d)</td>\n			<td>返回年份</td>\n		</tr>\n		<tr>\n			<td>YEARWEEK(date, mode)</td>\n			<td>返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、高级函数</strong></p>\n\n<table style=\"width:950px\">\n	<tbody>\n		<tr>\n			<td>BIN(x)</td>\n			<td>返回 x 的二进制编码</td>\n		</tr>\n		<tr>\n			<td>BINARY(s)</td>\n			<td>将字符串 s 转换为二进制字符串</td>\n		</tr>\n		<tr>\n			<td>\n			<pre>CASE expression\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n   ...\n    WHEN conditionN THEN resultN\n    ELSE result\nEND</pre>\n			</td>\n			<td>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td>\n		</tr>\n		<tr>\n			<td>CAST(x AS type)</td>\n			<td>转换数据类型</td>\n		</tr>\n		<tr>\n			<td>COALESCE(expr1, expr2, ...., expr_n)</td>\n			<td>返回参数中的第一个非空表达式（从左向右）</td>\n		</tr>\n		<tr>\n			<td>CONNECTION_ID()</td>\n			<td>返回服务器的连接数</td>\n		</tr>\n		<tr>\n			<td>CONV(x,f1,f2)</td>\n			<td>返回 f1 进制数变成 f2 进制数</td>\n		</tr>\n		<tr>\n			<td>CONVERT(s USING cs)</td>\n			<td>函数将字符串 s 的字符集变成 cs</td>\n		</tr>\n		<tr>\n			<td>CURRENT_USER()</td>\n			<td>返回当前用户</td>\n		</tr>\n		<tr>\n			<td>DATABASE()</td>\n			<td>返回当前数据库名</td>\n		</tr>\n		<tr>\n			<td>IF(expr,v1,v2)</td>\n			<td>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td>\n		</tr>\n		<tr>\n			<td><a href=\"https://www.runoob.com/mysql/mysql-func-ifnull.html\" rel=\"noopener noreferrer\" target=\"_blank\">IFNULL(v1,v2)</a></td>\n			<td>如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。</td>\n		</tr>\n		<tr>\n			<td>ISNULL(expression)</td>\n			<td>判断表达式是否为 NULL</td>\n		</tr>\n		<tr>\n			<td>LAST_INSERT_ID()</td>\n			<td>返回最近生成的 AUTO_INCREMENT 值</td>\n		</tr>\n		<tr>\n			<td>NULLIF(expr1, expr2)</td>\n			<td>比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td>\n		</tr>\n		<tr>\n			<td>SESSION_USER()</td>\n			<td>返回当前用户</td>\n		</tr>\n		<tr>\n			<td>SYSTEM_USER()</td>\n			<td>返回当前用户</td>\n		</tr>\n		<tr>\n			<td>USER()</td>\n			<td>返回当前用户</td>\n		</tr>\n		<tr>\n			<td>VERSION()</td>\n			<td>返回数据库的版本号</td>\n		</tr>\n	</tbody>\n</table>\n',0,287512265581555715,'2019-06-14 02:59:38','2019-06-14 02:59:38'),(287763947796197376,'<h1>自定义函数</h1>','sys','待编辑','<p><strong>1、修改语句结束符</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mysql一旦见到语句结束符，就会自动开始执行。所以定义函数时，需要修改语句结束符，控制执行时机</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建函数</strong></p>\n\n<pre><code class=\"language-sql\">-- 语法\n修改语句结束符\n    create function 函数名(形参) returns 返回值类型\n    begin\n        //函数体...\n        return 返回值数据;\n    end 语句结束符\n修改语句结束符（改回来）\n\n\n-- 示例\nDELIMITER $$\n    CREATE FUNCTION hello() RETURNS VARCHAR(255)\n    BEGIN\n        RETURN \'Hello world, mysql\';\n    END $$\nDELIMITER ;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>&nbsp;2、查看函数&nbsp;</strong></p>\n\n<pre><code class=\"language-sql\">show function status [like \'...\'];\nshow create function 函数名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、调用函数</strong></p>\n\n<pre><code class=\"language-sql\">-- 与内置函数相同\nselect 函数名(实参列表);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、删除函数</strong></p>\n\n<pre><code class=\"language-sql\">drop function 函数名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、注意事项</strong></p>\n\n<ul>\n	<li>自定义函数是属于用户级别的，只有当前客户端对应的数据库中可以使用</li>\n	<li>函数内部不能使用select指令，因为select一旦执行就会立即返回。（例外情况：select 字段 into @变量;）</li>\n</ul>\n',0,287512265581555715,'2019-05-13 07:33:11','2019-05-13 07:33:11'),(287800498580254720,'<h1>概述</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储过程，stored procedure，是一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译（效率比较高）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、与函数的区别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">区别</th>\n			<th scope=\"col\">存储过程</th>\n			<th scope=\"col\">函数</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>标识符</td>\n			<td>PROCEDURE</td>\n			<td>FUNCTION</td>\n		</tr>\n		<tr>\n			<td>返回值</td>\n			<td>无</td>\n			<td>有</td>\n		</tr>\n		<tr>\n			<td>使用</td>\n			<td>不能在select语句中使用</td>\n			<td>可以在select语句中使用</td>\n		</tr>\n	</tbody>\n</table>\n\n<p><br>\n&nbsp;</p>\n',0,287512265581555750,'2019-05-13 06:32:10','2019-05-13 06:32:10'),(287802817812262912,'<h1>存储过程管理</h1>','sys','待编辑','<p><strong>1、创建存储过程</strong></p>\n\n<pre><code class=\"language-sql\">-- 语法\n修改语句结束符\n    create procedure 过程名字([参数列表])\n    begin\n        过程体\n    end 语句结束符    \n修改语句结束符（改回来）\n\n\n-- 示例\nDELIMITER $$\n    CREATE PROCEDURE proc_countUser()\n    BEGIN\n        SELECT COUNT(*) FROM t_user;\n    END $$    \nDELIMITER ;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查询存储过程</strong></p>\n\n<pre><code class=\"language-sql\">show procedure status [like \'...\'];\nshow create procedure 过程名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、使用存储过程</strong></p>\n\n<pre><code class=\"language-sql\">call 过程名([实参列表]);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、删除存储过程</strong></p>\n\n<pre><code class=\"language-sql\">drop procedure 过程名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、存储过程的形参类型</strong></p>\n\n<ul>\n	<li>IN：参数从外部传入，供过程内部使用。默认类型</li>\n	<li>OUT：参数从过程内部传出，供外部使用。</li>\n	<li>INOUT：参数从外部传入，过程内部使用后，又传出，供外部使用。</li>\n</ul>\n\n<pre><code class=\"language-sql\">DELIMITER $$\n    CREATE PROCEDURE set_counter(INOUT count INT(4),IN inc INT(4))\n    BEGIN\n        SET count = count + inc;\n    END $$    \nDELIMITER ;</code></pre>\n\n<p>&nbsp;</p>\n',0,287512265581555750,'2019-05-13 07:30:02','2019-05-13 07:30:02'),(287810090244665344,'<h1>概述</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一种特殊类型的存储过程，通过触发事件而被执行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>实现相关表的级联更改。</li>\n	<li>通过触发器进行安全校验，保证数据安全</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、缺点</strong></p>\n\n<ul>\n	<li>过分依赖触发器，会影响数据库结构，增加了维护难度。</li>\n	<li>由于执行触发器不可见，很难弄清数据库层情况</li>\n	<li>对数据库服务器资源的开销较大</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、建议</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽量不使用触发器，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 如果要使用，需确保触发器高效低耗</p>\n',0,287512265581555760,'2019-05-13 07:20:52','2019-05-13 07:20:52'),(287815116505640960,'<h1>触发器管理</h1>','sys','待编辑','<p><strong>1、创建触发器</strong></p>\n\n<pre><code class=\"language-sql\">-- 触发时机：before/after\n-- 触发事件：insert/update/delete\n\n-- 语法\n修改语句结束符\n    create trigger 触发器名 触发时机 触发事件 on 表名 for each row\n    begin\n        //执行体...        \n    end 语句结束符\n修改语句结束符\n\n\n-- 示例\nDELIMITER $$\n    CREATE TRIGGER demo BEFORE DELETE ON users FOR EACH ROW\n        BEGIN\n            INSERT INTO logs VALUES(NOW());\n            INSERT INTO logs VALUES(NOW());\n        END $$\nDELIMITER ;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查看触发器</strong></p>\n\n<pre><code class=\"language-sql\">show triggers [like \'...\'];\nshow create trigger 触发器名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、删除触发器</strong></p>\n\n<pre><code class=\"language-sql\">drop trigger 触发器名;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、old、new</strong></p>\n\n<p>触发器，针对数据表中的每一行，会记录其操作前后的数据。</p>\n\n<p>old：记录操作前的数据。</p>\n\n<p>new：记录操作后的数据</p>\n\n<pre><code class=\"language-sql\">-- 在触发器中，可通过“old/new.字段名”，来获取对应数据\n-- 示例：商品自动扣除库存\nDELIMITER $$\n    CREATE TRIGGER demo AFTER INSERT ON my_orders FOR EACH ROW\n        BEGIN\n            UPDATE my_goods SET inv = inv -NEW.goods_num WHERE id = NEW.goods_id;			\n        END $$\nDELIMITER ;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,287512265581555760,'2019-05-13 07:46:08','2019-05-13 07:46:08'),(287826379621167104,'<h1>参考资料</h1>','sys','待编辑','<p><strong>官方参考文档</strong></p>\n\n<p><strong><a href=\"https://dev.mysql.com/doc/refman/5.7/en/\" target=\"_blank\">https://dev.mysql.com/doc/refman/5.7/en/</a></strong></p>\n',0,287200745656053760,'2019-05-18 12:03:57','2019-05-13 08:08:26'),(287826479244275712,'<h1>提问1-MySQL</h1>','sys','待编辑','<p>数据表</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">表名</th>\n			<th scope=\"col\">名称</th>\n			<th scope=\"col\">字段</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>Student</td>\n			<td>学生表</td>\n			<td>S#：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别</td>\n		</tr>\n		<tr>\n			<td>Course</td>\n			<td>课程表</td>\n			<td>C#,课程编号；Cname：课程名字；T#：教师编号</td>\n		</tr>\n		<tr>\n			<td>SC</td>\n			<td>成绩表</td>\n			<td>S#：学号；C#,课程编号；score：成绩</td>\n		</tr>\n		<tr>\n			<td>Teacher</td>\n			<td>教师表</td>\n			<td>T#：教师编号； Tname：教师名字</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>1、查询“001”课程比“002”课程成绩高的所有学生的学号；</p>\n\n<pre><code class=\"language-sql\">select a.S# \nfrom (\n    select s#,score \n    from SC where C#=\'001\'\n) a,(\n    select s#,score \n    from SC where C#=\'002\'\n) b\nwhere a.score&gt;b.score and a.s#=b.s#;</code></pre>\n\n<p><br>\n2、查询平均成绩大于60分的同学的学号和平均成绩；</p>\n\n<pre><code class=\"language-sql\">select S#,avg(score)\nfrom sc\ngroup by S# having avg(score) &gt;60;</code></pre>\n\n<p><br>\n3、查询所有同学的学号、姓名、选课数、总成绩；</p>\n\n<pre><code class=\"language-sql\">select Student.S#,Student.Sname,count(SC.C#),sum(score)\nfrom Student \nleft outer join SC on Student.S#=SC.S#\ngroup by Student.S#,Sname;</code></pre>\n\n<p><br>\n4、查询姓“李”的老师的个数；</p>\n\n<pre><code class=\"language-sql\">select count(distinct(Tname))\nfrom Teacher\nwhere Tname like \'李%\';</code></pre>\n\n<p><br>\n5、查询没学过“叶平”老师课的同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">select Student.S#,Student.Sname\nfrom Student&nbsp;\nwhere S# not in (\n    select distinct( SC.S#) \n    from SC,Course,Teacher \n    where SC.C#=Course.C# and Teacher.T#=Course.T# &nbsp;and Teacher.Tname=\'叶平\'\n);</code></pre>\n\n<p>&nbsp; &nbsp;<br>\n6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">select Student.S#,Student.Sname \nfrom Student,SC \nwhere Student.S#=SC.S# and SC.C#=\'001\'and exists( \n    Select * \n    from SC as SC_2 \n    where SC_2.S#=SC.S# and SC_2.C#=\'002\'\n);</code></pre>\n\n<p>&nbsp;&nbsp;<br>\n7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">select S#,Sname\nfrom Student\nwhere S# in (\n    select S# \n    from SC ,Course ,Teacher \n    where SC.C#=Course.C# and Teacher.T#=Course.T# and Teacher.Tname=\'叶平\' group by S# having count(SC.C#)=(\n        select count(C#) \n        from Course,Teacher &nbsp;\n        where Teacher.T#=Course.T# and Tname=\'叶平\'\n    )\n);</code></pre>\n\n<p><br>\n<br>\n8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">Select S#,Sname \nfrom (\n    select Student.S#,Student.Sname,score ,(\n        select score \n        from SC SC_2 \n        where SC_2.S#=Student.S# and SC_2.C#=\'002\'\n    ) score2\n    from Student,SC \n    where Student.S#=SC.S# and C#=\'001\'\n) S_2 \nwhere score2 &lt;score;</code></pre>\n\n<p><br>\n9、查询所有课程成绩小于60分的同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">select S#,Sname\nfrom Student\nwhere S# not in (\n    select Student.S# \n    from Student,SC \n    where S.S#=SC.S# and score&gt;60\n);</code></pre>\n\n<p><br>\n<br>\n10、查询没有学全所有课的同学的学号、姓名；</p>\n\n<pre><code class=\"language-sql\">select Student.S#,Student.Sname\nfrom Student,SC\nwhere Student.S#=SC.S# group by &nbsp;Student.S#,Student.Sname having count(C#) &lt;(\n    select count(C#) \n    from Course\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p>11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；</p>\n\n<pre><code class=\"language-sql\">select S#,Sname \nfrom Student,SC \nwhere Student.S#=SC.S# and C# in (\n    select C# \n    from SC \n    where S#=\'1001\'\n);</code></pre>\n\n<p><br>\n12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；</p>\n\n<pre><code class=\"language-sql\">select distinct SC.S#,Sname\nfrom Student,SC\nwhere Student.S#=SC.S# and C# in (\n    select C# \n    from SC \n    where S#=\'001\'\n);</code></pre>\n\n<p>&nbsp;<br>\n13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；</p>\n\n<pre><code class=\"language-sql\">update SC set score=(\n    select avg(SC_2.score)\n    from SC SC_2\n    where SC_2.C#=SC.C# \n) from Course,Teacher \nwhere Course.C#=SC.C# and Course.T#=Teacher.T# and Teacher.Tname=\'叶平\';</code></pre>\n\n<p>&nbsp;<br>\n14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；</p>\n\n<pre><code class=\"language-sql\">select S# \nfrom SC \nwhere C# in (\n    select C# \n    from SC \n    where S#=\'1002\'\n)\ngroup by S# having count(*)=(\n    select count(*) \n    from SC \n    where S#=\'1002\'\n);</code></pre>\n\n<p>&nbsp;<br>\n15、删除学习“叶平”老师课的SC表记录；</p>\n\n<pre><code class=\"language-sql\">delete SC\nfrom course ,Teacher&nbsp;\nwhere Course.C#=SC.C# and Course.T#= Teacher.T# and Tname=\'叶平\';</code></pre>\n\n<p>&nbsp;<br>\n16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2号课的平均成绩；</p>\n\n<pre><code class=\"language-sql\">Insert SC select S#,\'002\',(\n    Select avg(score)\n    from SC \n    where C#=\'002\'\n) \nfrom Student \nwhere S# not in (\n    Select S# \n    from SC \n    where C#=\'002\'\n);</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，</p>\n\n<p>按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分</p>\n\n<pre><code class=\"language-sql\">SELECT S# as 学生ID\n    ,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=\'004\') AS 数据库\n    ,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=\'001\') AS 企业管理\n    ,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=\'006\') AS 英语\n    ,COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩\nFROM SC AS t\nGROUP BY S#\nORDER BY avg(t.score)&nbsp;</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分</p>\n\n<pre><code class=\"language-sql\">SELECT L.C# As 课程ID,L.score AS 最高分,R.score AS 最低分\nFROM SC L ,SC AS R\nWHERE L.C# = R.C# and L.score = (\n    SELECT MAX(IL.score)\n    FROM SC AS IL,Student AS IM\n    WHERE L.C# = IL.C# and IM.S#=IL.S# GROUP BY IL.C#\n)\nAND R.Score = (\n    SELECT MIN(IR.score)\n    FROM SC AS IR\n    WHERE R.C# = IR.C# GROUP BY IR.C#\n);</code></pre>\n\n<p><br>\n19、按各科平均成绩从低到高和及格率的百分数从高到低顺序</p>\n\n<pre><code class=\"language-sql\">SELECT t.C# AS 课程号,max(course.Cname)AS 课程名,isnull(AVG(score),0) AS 平均成绩\n    ,100 * SUM(CASE WHEN &nbsp;isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) AS 及格百分数\nFROM SC T,Course\nwhere t.C#=course.C# GROUP BY t.C# ORDER BY 100 * SUM(\n    CASE WHEN isnull(score,0)&gt;=60 \n    THEN 1 \n    ELSE 0 END\n)/COUNT(*) DESC</code></pre>\n\n<p>&nbsp; &nbsp;<br>\n20、查询不同老师所教不同课程平均分从高到低显示</p>\n\n<pre><code class=\"language-sql\">SELECT max(Z.T#) AS 教师ID,MAX(Z.Tname) AS 教师姓名,C.C# AS 课程ＩＤ,MAX(C.Cname) AS 课程名称,AVG(Score) AS 平均成绩\nFROM SC AS T,Course AS C ,Teacher AS Z\nwhere T.C#=C.C# and C.T#=Z.T# GROUP BY C.C# ORDER BY AVG(Score) DESC\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>21、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]</p>\n\n<pre><code class=\"language-sql\">SELECT SC.C# as 课程ID, Cname as 课程名称\n    ,SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85]\n    ,SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70]\n    ,SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60]\n    ,SUM(CASE WHEN score &lt; 60 THEN 1 ELSE 0 END) AS [60 -]\nFROM SC,Course\nwhere SC.C#=Course.C# GROUP BY SC.C#,Cname;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>22、查询学生平均成绩及其名次</p>\n\n<pre><code class=\"language-sql\">SELECT 1+(\n    SELECT COUNT( distinct 平均成绩)\n    FROM (\n        SELECT S#,AVG(score) AS 平均成绩\n        FROM SC GROUP BY S#\n    ) AS T1\n    WHERE 平均成绩 &gt; T2.平均成绩) as 名次, S# as 学生学号,平均成绩\nFROM (\n    SELECT S#,AVG(score) 平均成绩\n    FROM SC GROUP BY S#\n) AS T2\nORDER BY 平均成绩 desc;</code></pre>\n\n<p>&nbsp;<br>\n23、查询各科成绩前三名的记录:(不考虑成绩并列情况)<br>\n&nbsp;</p>\n\n<pre><code class=\"language-sql\">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数\nFROM SC t1\nWHERE score IN (\n    SELECT TOP 3 score\n    FROM SC\n    WHERE t1.C#= C#  ORDER BY score DESC\n)\nORDER BY t1.C#;</code></pre>\n\n<p><br>\n24、查询每门课程被选修的学生数</p>\n\n<pre><code class=\"language-sql\">select c#,count(S#) \nfrom sc group by C#;</code></pre>\n\n<p><br>\n&nbsp;</p>\n',0,287200745656053760,'2019-05-19 04:14:00','2019-05-13 08:58:10'),(287839131530063872,'<h1>提问2-MySQL</h1>','sys','待编辑','<p>数据表</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">表名</th>\n			<th scope=\"col\">名称</th>\n			<th scope=\"col\">字段</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>Student</td>\n			<td>学生表</td>\n			<td>S#：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别</td>\n		</tr>\n		<tr>\n			<td>Course</td>\n			<td>课程表</td>\n			<td>C#,课程编号；Cname：课程名字；T#：教师编号</td>\n		</tr>\n		<tr>\n			<td>SC</td>\n			<td>成绩表</td>\n			<td>S#：学号；C#,课程编号；score：成绩</td>\n		</tr>\n		<tr>\n			<td>Teacher</td>\n			<td>教师表</td>\n			<td>T#：教师编号； Tname：教师名字</td>\n		</tr>\n	</tbody>\n</table>\n\n<p><br>\n25、查询出只选修了一门课程的全部学生的学号和姓名</p>\n\n<pre><code class=\"language-sql\">select SC.S#,Student.Sname,count(C#) AS 选课数\nfrom SC ,Student\nwhere SC.S#=Student.S# group by SC.S# ,Student.Sname having count(C#)=1;</code></pre>\n\n<p><br>\n26、查询男生、女生人数</p>\n\n<pre><code class=\"language-sql\">Select count(Ssex) as 男生人数 \nfrom Student group by Ssex having Ssex=\'男\';\n\nSelect count(Ssex) as 女生人数 \nfrom Student group by Ssex having Ssex=\'女\'；</code></pre>\n\n<p><br>\n&nbsp;27、查询姓“张”的学生名单</p>\n\n<pre><code class=\"language-sql\">SELECT Sname \nFROM Student \nWHERE Sname like \'张%\';</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n28、查询同名同性学生名单，并统计同名人数</p>\n\n<pre><code class=\"language-sql\">select Sname,count(*) \nfrom Student group by Sname having &nbsp;count(*)&gt;1;;</code></pre>\n\n<p>&nbsp;&nbsp;<br>\n29、1981年出生的学生名单(注：Student表中Sage列的类型是datetime)</p>\n\n<pre><code class=\"language-sql\">select Sname, &nbsp;CONVERT(char (11),DATEPART(year,Sage)) as age\nfrom student\nwhere &nbsp;CONVERT(char(11),DATEPART(year,Sage))=\'1981\';</code></pre>\n\n<p>&nbsp; &nbsp;<br>\n30、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</p>\n\n<pre><code class=\"language-sql\">Select C#,Avg(score) \nfrom SC group by C# order by Avg(score),C# DESC ;</code></pre>\n\n<p><br>\n31、查询平均成绩大于85的所有学生的学号、姓名和平均成绩</p>\n\n<pre><code class=\"language-sql\">select Sname,SC.S# ,avg(score)\nfrom Student,SC\nwhere Student.S#=SC.S# group by SC.S#,Sname having avg(score)&gt;85;</code></pre>\n\n<p><br>\n32、查询课程名称为“数据库”，且分数低于60的学生姓名和分数</p>\n\n<pre><code class=\"language-sql\">Select Sname,isnull(score,0)\nfrom Student,SC,Course\nwhere SC.S#=Student.S# and SC.C#=Course.C# and &nbsp;Course.Cname=\'数据库\'and score &lt;60;</code></pre>\n\n<p><br>\n33、查询所有学生的选课情况；</p>\n\n<pre><code class=\"language-sql\">SELECT SC.S#,SC.C#,Sname,Cname\nFROM SC,Student,Course\nwhere SC.S#=Student.S# and SC.C#=Course.C# ;</code></pre>\n\n<p><br>\n34、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；</p>\n\n<pre><code class=\"language-sql\">SELECT &nbsp;distinct student.S#,student.Sname,SC.C#,SC.score\nFROM student,Sc\nWHERE SC.score&gt;=70 AND SC.S#=student.S#;</code></pre>\n\n<p><br>\n35、查询不及格的课程，并按课程号从大到小排列</p>\n\n<pre><code class=\"language-sql\">select c# \nfrom sc \nwhere scor e &lt;60 order by C# ;</code></pre>\n\n<p><br>\n36、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；</p>\n\n<pre><code class=\"language-sql\">select SC.S#,Student.Sname \nfrom SC,Student \nwhere SC.S#=Student.S# and Score&gt;80 and C#=\'003\';</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n37、求选了课程的学生人数</p>\n\n<pre><code class=\"language-sql\">select count(*) \nfrom sc;</code></pre>\n\n<p><br>\n38、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩</p>\n\n<pre><code class=\"language-sql\">select Student.Sname,score\nfrom Student,SC,Course C,Teacher\nwhere Student.S#=SC.S# and SC.C#=C.C# and C.T#=Teacher.T# and Teacher.Tname=\'叶平\' and SC.score=(\n    select max(score)\n    from SC \n    where C#=C.C# \n);</code></pre>\n\n<p><br>\n39、查询各个课程及相应的选修人数</p>\n\n<pre><code class=\"language-sql\">select count(*) \nfrom sc group by C#;</code></pre>\n\n<p><br>\n40、查询不同课程成绩相同的学生的学号、课程号、学生成绩</p>\n\n<pre><code class=\"language-sql\">select distinct &nbsp;A.S#,B.score \nfrom SC A &nbsp;,SC B \nwhere A.Score=B.Score and A.C# &lt;&gt;B.C# ;</code></pre>\n\n<p><br>\n41、查询每门功成绩最好的前两名</p>\n\n<pre><code class=\"language-sql\">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数\nFROM SC t1\nWHERE score IN (\n    SELECT TOP 2 score\n    FROM SC\n    WHERE t1.C#= C# ORDER BY score DESC\n)\nORDER BY t1.C#;</code></pre>\n\n<p><br>\n42、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列&nbsp;</p>\n\n<pre><code class=\"language-sql\">select &nbsp;C# as 课程号,count(*) as 人数\nfrom &nbsp;sc group &nbsp;by &nbsp;C# \norder &nbsp;by &nbsp;count(*) desc,c#&nbsp;</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n43、检索至少选修两门课程的学生学号&nbsp;</p>\n\n<pre><code class=\"language-sql\">select &nbsp;S#&nbsp;\nfrom &nbsp;sc group &nbsp;by &nbsp;s#\nhaving &nbsp;count(*) &nbsp;&gt; &nbsp;= &nbsp;2</code></pre>\n\n<p><br>\n44、查询全部学生都选修的课程的课程号和课程名</p>\n\n<pre><code class=\"language-sql\">select &nbsp;C#,Cname&nbsp;\nfrom &nbsp;Course&nbsp;\nwhere &nbsp;C# &nbsp;in &nbsp;(\n    select &nbsp;c# &nbsp;\n    from &nbsp;sc group &nbsp;by &nbsp;c#\n);</code></pre>\n\n<p><br>\n45、查询没学过“叶平”老师讲授的任一门课程的学生姓名</p>\n\n<pre><code class=\"language-sql\">select Sname \nfrom Student \nwhere S# not in (\n    select S# \n    from Course,Teacher,SC \n    where Course.T#=Teacher.T# and SC.C#=course.C# and Tname=\'叶平\'\n);</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n46、查询两门以上不及格课程的同学的学号及其平均成绩</p>\n\n<pre><code class=\"language-sql\">select S#,avg(isnull(score,0)) \nfrom SC \nwhere S# in (\n    select S# \n    from SC \n    where score &lt;60 group by S# having count(*)&gt;2\n)\ngroup by S#;</code></pre>\n\n<p>&nbsp; &nbsp;&nbsp;<br>\n47、检索“004”课程分数小于60，按分数降序排列的同学学号</p>\n\n<pre><code class=\"language-sql\">select S# \nfrom SC \nwhere C#=\'004\'and score &lt;60 \norder by score desc;</code></pre>\n\n<p><br>\n&nbsp;<br>\n48、删除“002”同学的“001”课程的成绩</p>\n\n<pre><code class=\"language-sql\">delete from Sc \nwhere S#=\'002\'and C#=\'001\';</code></pre>\n\n<p>&nbsp;</p>\n',0,287200745656053760,'2019-05-19 04:14:02','2019-05-13 08:58:30'),(287960738902732800,'<h1>自我介绍</h1>','sys','待编辑','<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 我叫阮剑达，来自中北大学，本科毕业。因兴趣爱好等原因，于3年前自学java。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在掌握了基本技能后，进入了一家小型信息技术公司，进行了2年具体项目的后台开发。这期间的主要工作，是接口文档编写、具体业务功能实现与测试。项目开发的其他环节也有不同程度参与，如需求分析，数据库设计，集成测试，上线部署，问题修复等。开发这些项目的过程中，我熟悉了SSM开发模式，并掌握了eclipse、tomcat、maven、svn等工具的使用。虽然在软件架构与底层方面涉及较少，但基本上掌握了的Java业务开发与问题处理的能力。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，我进入了深圳一家大型公司，对华为基站告警处理平台进行维护开发。工作主要是一线问题单处理、月度版本出包验证、平台功能需求开发三方面。使用的工具是华为内部的开发框架。虽然技术上没有太明显的进步，但与华为员工共同办公，面对不断而来的问题单，也锻炼了我应变、抗压、分工协作、问题处理等其他方面的能力。</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 离职之后，为防备遗忘，便自己搭了一个cms系统，用于自己所学的知识归纳总结。前端用的是HTML、CSS、JavaScript、jQuery、AJAX、Bootstrap，后端用的是spring、SpringMVC、MyBatis，并对以上技术重新熟悉了一遍。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我打算往分布式、大数据方向发展。框架技术方面，已完成MyBatis、Spring、SpringMVC、Spring Boot、MySQL的归纳学习，之后是Redis、Dubbo、ZooKeeper等。底层方面，计划学习Spring源码，Java 虚拟机、多线程等。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 总的情况，就是这样，谢谢！</p>\n',0,287957628796956672,'2019-06-30 02:04:23','2019-06-30 02:04:23'),(288132328202334208,'<h1>华为告警处理系统</h1>','sys','待编辑','<p>1、基本情况</p>\n\n<ul>\n	<li>持续时间：2018.05-2019.04</li>\n	<li>所属公司：华为技术有限公司</li>\n	<li>项目介绍：</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、告警删除规则</p>\n\n<ul>\n	<li>规则管理\n	<ul>\n		<li>作用：定义规则，规则增删改查</li>\n		<li>字段：规则名称、规则SQL过滤条件、告警保持时间</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>定时器管理\n	<ul>\n		<li>作用：定义定时器，定时器增删改查</li>\n		<li>字段：定时器名称、定时器周期</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>机制\n	<ul>\n		<li>定时服务：查询获取所有规则，解析得到SQL过滤条件。根据SQL条件，标记符合条件的活动告警。</li>\n		<li>启动定时服务：查询定时器，根据定时器信息，将定时服务，提交给定时管理服务进行周期性运行。</li>\n		<li>数据库trigger：当活动告警修改时，如果标记字段符合特定标记，则删除告警。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>3、告警过载删除规则</p>\n\n<ul>\n	<li>配置管理\n	<ul>\n		<li>作用：定义过载删除规则启动时机</li>\n		<li>字段：告警阈值</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>规则管理\n	<ul>\n		<li>作用：定义规则，规则增删改查</li>\n		<li>字段：规则名称、规则SQL过滤条件、告警保持时间</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>定时器管理\n	<ul>\n		<li>作用：定义定时器，定时器增删改查</li>\n		<li>字段：定时器名称、定时器周期</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>机制\n	<ul>\n		<li>定时服务：\n		<ul>\n			<li>查询活动告警，如果告警量超过阈值，则启动规则删除，否则返回</li>\n			<li>查询获取所有规则，解析得到SQL过滤条件。根据SQL条件，标记符合条件的活动告警。</li>\n		</ul>\n		</li>\n		<li>启动定时服务：查询定时器，根据定时器信息，将定时服务，提交给定时管理服务进行周期性运行。</li>\n		<li>数据库trigger：当活动告警修改时，如果标记字段符合特定标记，则删除告警。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,287960981564190720,'2019-06-11 00:16:01','2019-06-11 00:16:01'),(288669301501489152,'<h1>数据库引擎</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 数据库引擎是用于存储、处理和保护数据的核心服务</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、管理</strong></p>\n\n<pre><code class=\"language-sql\">-- 建表时指定\ncreate table mytbl(   \n    id int primary key,   \n    name varchar(50)   \n)type=MyISAM;\n\n\n-- 建表后修改\nalter table table_name type = InnoDB;\n\n\n-- 查看\nshow create table table_name;\nshow table status from table_name; </code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,287512265581555740,'2019-06-05 11:19:47','2019-05-15 16:19:05'),(288675413881679872,'<h1>InnoDB</h1>','sys','待编辑','<p><strong>1、概述</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB：是一个事务型的存储引擎，支持行级锁、外键约束、自动增长列。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的设计目标是处理大容量数据库系统，运行时，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、索引结构</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>InnoDB 是B+Tree索引结构，其将主键组织到一棵B+Tree中，而行数据储存在叶节点上（即聚集索引）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、检索算法</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若对主键列进行条件搜索，则按B+Tree的检索算法即可查找到对应的叶节点，获得行数据。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若对非主键列进行条件搜索，则先在辅助索引B+Tree中检索对应列，到达其叶节点获取对应的主键，在进行“对主键列进行条件搜索”。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、适用场景</strong></p>\n\n<ul>\n	<li>更新密集的表。</li>\n	<li>事务。</li>\n	<li>自动灾难恢复。</li>\n	<li>外键约束。</li>\n	<li>\n	<p>支持自动增加列属性。</p>\n	</li>\n</ul>\n',0,287512265581555740,'2019-06-05 11:19:49','2019-05-15 18:25:56'),(288680078249717760,'<h1>MyISAM<br></h1>','sys','待编辑','<p><strong>1、概述</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; MyISAM：极度强调快速读取操作，不支持数据库事务、行级锁、外键约束。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持3种存储格式：</p>\n\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">特点</th>\n			<th scope=\"col\">优点</th>\n			<th scope=\"col\">缺点</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>静态表</td>\n			<td>表中字段均固定长度</td>\n			<td>存储快，容易缓存</td>\n			<td>空间占用多</td>\n		</tr>\n		<tr>\n			<td>动态表</td>\n			<td>表中字段均长度可变</td>\n			<td>空间占用少</td>\n			<td>容易产生磁盘碎片</td>\n		</tr>\n		<tr>\n			<td>压缩表</td>\n			<td>单独压缩每个记录</td>\n			<td>访问开支小</td>\n			<td>需解压</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、索引结构</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyISAM 是B+Tree索引结构，其B+Tree的数据域存储的内容为实际数据的地址（即非聚集索引）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、检索算法</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先按B+Tree的检索算法搜索索引，取出其数据域的值，再以这个值为地址，去读取相应的数据记录。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、适用场景</strong></p>\n\n<ul>\n	<li>查询密集型表。\n	<ul>\n		<li>MyISAM&nbsp;存储引擎在筛选大量数据时非常快；</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>插入密集型表。\n	<ul>\n		<li>MyISAM 的并发插入特性允许同时选择、插入数据。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,287512265581555740,'2019-06-05 11:19:50','2019-05-30 06:36:35'),(288701608765583360,'<h1>InnoDB、MyISAM 对比</h1>','sys','待编辑','<p><strong>1、区别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">InnoDB</th>\n			<th scope=\"col\">MyISAM</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>锁级别</td>\n			<td>行级锁</td>\n			<td>表级锁</td>\n		</tr>\n		<tr>\n			<td>事务</td>\n			<td>支持</td>\n			<td>不支持</td>\n		</tr>\n		<tr>\n			<td>自增列</td>\n			<td>支持</td>\n			<td>不支持</td>\n		</tr>\n		<tr>\n			<td>外键</td>\n			<td>支持</td>\n			<td>不支持</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>全文索引</td>\n			<td>不支持</td>\n			<td>支持</td>\n		</tr>\n		<tr>\n			<td>主键</td>\n			<td>必须有</td>\n			<td>可以没有</td>\n		</tr>\n		<tr>\n			<td>存储空间</td>\n			<td>占用较多</td>\n			<td>占用较少</td>\n		</tr>\n		<tr>\n			<td>表的具体行数</td>\n			<td>不保存</td>\n			<td>保存</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、使用建议</strong></p>\n\n<ul>\n	<li>InnoDB\n	<ul>\n		<li>可靠性高或者要求事务处理的</li>\n		<li>表更新和查询都相当频繁的</li>\n	</ul>\n	</li>\n	<li>MyISAM\n	<ul>\n		<li>做很多count的计算的</li>\n		<li>插入修改不频繁，查询非常频繁的</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,287512265581555740,'2019-06-05 11:19:51','2019-05-15 18:30:57'),(288709171041169408,'<h1>引擎优化</h1>','sys','待编辑','<h3><strong>一、InnoDB</strong></h3>\n\n<p><strong>1、禁用唯一性检查</strong></p>\n\n<pre><code class=\"language-sql\"># 唯一性校验会降低插入记录的速度，\n# 可以在插入记录之前禁用唯一性检查，插入数据完成后再开启\n\n-- 禁用唯一性检查\nSET UNIQUE_CHECKS = 0;\n-- 开启唯一性检查\nSET UNIQUE_CHECKS = 1;</code></pre>\n\n<div>&nbsp;</div>\n\n<p><strong>2、禁用外键检查</strong></p>\n\n<pre><code class=\"language-sql\"># 插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提高插入速度。\n\n-- 禁用外键检查\nSET foreign_key_checks = 0;\n-- 开启外键检查\nSET foreign_key_checks = 1;</code></pre>\n\n<p><br>\n<strong>3、禁止自动提交</strong></p>\n\n<pre><code class=\"language-sql\"># 插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提高插入速度。\n\n-- 禁用自动提交\nSET autocommit = 0;\n-- 开启自动提交\nSET autocommit = 1;</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>二、MyISAM</strong></h3>\n\n<p><strong>1、禁用索引</strong></p>\n\n<pre><code class=\"language-sql\"># 插入大量数据，建立索引会降低插入数据速度。\n# 可以在批量插入数据之前禁用索引，数据插入完成后再开启\n\n-- 禁用索引\nALTER TABLE table_name DISABLE KEYS\n-- 开启索引\nALTER TABLE table_name ENABLE KEYS</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、禁用唯一性检查</strong></p>\n\n<p>同InnoDB&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、批量插入数据</strong></p>\n\n<pre><code class=\"language-sql\">#一次性插入多条数据较快\n\n-- 插入单条数据\ninsert into 表名 values(列值, ....);\n-- 插入多条数据\ninsert into 表名 values(列值, ....),(列值, ....),...;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、使用LOAD DATA INFILE</strong><br>\n当需要批量导入数据时，使用LOAD DATA INFILE语句比INSERT语句插入速度快很多。</p>\n\n<p>&nbsp;</p>\n',0,287512265581555740,'2019-06-05 11:19:54','2019-06-05 05:06:10'),(289377167459905530,'<h1>NoSQL</h1>','sys','待编辑','<p><strong>1、背景</strong></p>\n\n<ul>\n	<li>大数据时代的3V\n	<ul>\n		<li>海量Volume</li>\n		<li>多样Variety</li>\n		<li>实时Velocity</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>互联网需求的3高\n	<ul>\n		<li>高并发</li>\n		<li>高可扩</li>\n		<li>高性能</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoSQL，Not Only SQL ，泛指非关系型的数据库。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优缺点</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>高可扩展性</li>\n		<li>分布式计算</li>\n		<li>低成本</li>\n		<li>架构的灵活性，半结构化数据</li>\n		<li>没有复杂的关系</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>缺点:\n	<ul>\n		<li>没有标准化</li>\n		<li>有限的查询功能（到目前为止）</li>\n		<li>最终一致是不直观的程序</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、特征</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）不需要预定义模式：不需要事先定义数据模式，预定义表结构。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）无共享架构：&nbsp;NoSQL往往将数据划分后存储在各个本地服务器上，以提高性能。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）弹性可扩展：可以在系统运行的时候，动态增加或者删除结点</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 4）分区：&nbsp;NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 5）异步复制：NoSQL中的复制，往往是基于日志的异步复制。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 6）BASE特性：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性（最终一致性和软事务）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、分类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">部分代表</th>\n			<th scope=\"col\">特点</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>key-value存储</p>\n			</td>\n			<td>\n			<p>Tokyo&nbsp;Cabinet&nbsp;/&nbsp;Tyrant</p>\n\n			<p>Berkeley&nbsp;DB</p>\n\n			<p>MemcacheDB</p>\n\n			<p>Redis</p>\n			</td>\n			<td>\n			<p>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>文档存储</p>\n			</td>\n			<td>\n			<p>MongoDB</p>\n\n			<p>CouchDB</p>\n			</td>\n			<td>\n			<p>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>列存储</td>\n			<td>\n			<p>Hbase</p>\n\n			<p>Cassandra</p>\n\n			<p>Hypertable</p>\n			</td>\n			<td>\n			<p>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>图存储</p>\n			</td>\n			<td>\n			<p>Neo4J</p>\n\n			<p>FlockDB</p>\n			</td>\n			<td>\n			<p>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>对象存储</p>\n			</td>\n			<td>\n			<p>db4o</p>\n\n			<p>Versant</p>\n			</td>\n			<td>\n			<p>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>xml数据库</p>\n			</td>\n			<td>\n			<p>Berkeley&nbsp;DB&nbsp;XML</p>\n\n			<p>BaseX</p>\n			</td>\n			<td>\n			<p>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、RDBMS vs NoSQL</strong></p>\n\n<ul>\n	<li>RDBMS\n	<ul>\n		<li>高度组织化结构化数据</li>\n		<li>结构化查询语言（SQL）</li>\n		<li>数据和关系都存储在单独的表中。</li>\n		<li>数据操纵语言，数据定义语言</li>\n		<li>严格的一致性</li>\n		<li>基础事务</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>NoSQL\n	<ul>\n		<li>代表着不仅仅是SQL</li>\n		<li>没有声明性查询语言</li>\n		<li>没有预定义的模式</li>\n		<li>键值对存储，列存储，文档存储，图形数据库</li>\n		<li>最终一致性，而非ACID属性</li>\n		<li>非结构化和不可预知的数据</li>\n		<li>CAP定理</li>\n		<li>高性能，高可用性和可伸缩性</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289376422903836672,'2019-05-17 16:34:40','2019-05-17 16:34:40'),(289377167459905536,'<h1>一些概念</h1>','sys','待编辑','<p><strong>1、CAP</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）一致性：Consistency，所有节点在同一时间具有相同的数据。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）可用性：Availability，保证每个请求不管成功或者失败都有响应。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）分区容错：Partition tolerance，系统中任意信息的丢失或失败不会影响系统的继续运作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、CAP定理</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、BASE</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据库强一致性会降低可用性，BASE就是为了解决这一问题而提出的解决方案</p>\n\n<ul>\n	<li>基本可用，Basically Availble</li>\n	<li>软状态，Soft-state</li>\n	<li>最终一致，Eventual Consistency&nbsp;&nbsp;&nbsp;&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、分布式、集群</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）分布式：不同的多台服务器上，部署不同的服务模块，他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）集群：&nbsp; &nbsp;不同的多台服务器上，部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</p>\n',0,289376422903836672,'2019-05-17 16:39:03','2019-05-17 16:39:03'),(289408941783150592,'<h1>Redis</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis，<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver，是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、特点</strong></p>\n\n<ul>\n	<li>支持数据的持久化</li>\n	<li>不仅仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset，等数据结构的存储。</li>\n	<li>支持数据的备份</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优势</strong></p>\n\n<ul>\n	<li>性能极高&nbsp;</li>\n	<li>丰富的数据类型</li>\n	<li>所有操作都是原子性的</li>\n	<li>丰富的特性</li>\n</ul>\n',0,289408880953159680,'2019-05-17 21:24:40','2019-05-17 21:24:40'),(289410449488637952,'<h1>安装与配置</h1>','sys','待编辑','<p><strong>1、安装</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-install.html\">https://www.runoob.com/redis/redis-install.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、配置</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-conf.html\">https://www.runoob.com/redis/redis-conf.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、杂项</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）单进程</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）默认端口6379、16个数据库</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）Select：切换数据库、Dbsize：当前数据库的key的数量、Flushdb：清空当前库、Flushall：通杀全部库</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 4）统一密码管理，16个库都是同样密码</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289408880953159680,'2019-05-17 19:03:11','2019-05-17 19:03:11'),(289414442092752896,'<h1>数据类型</h1>','sys','待编辑','<p><strong>1、String（字符串）</strong></p>\n\n<ul>\n	<li>是 Redis 最基本的数据类型，最大能存储 512MB。</li>\n	<li>是二进制安全的，可以包含任何数据。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Hash（哈希）</strong></p>\n\n<ul>\n	<li>是一个键值(key=&gt;value)对集合。</li>\n	<li>是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、List（列表）</strong></p>\n\n<ul>\n	<li>是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Set（集合）</strong></p>\n\n<ul>\n	<li>是string类型的无序集合，通过HashTable实现</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、zset(sorted set：有序集合)</strong></p>\n\n<ul>\n	<li>是string类型元素的集合，且不允许重复的成员。</li>\n	<li>其每个元素都会关联一个double类型的分数。（Redis正是通过分数来为集合中的成员进行从小到大的排序）</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289408880953159680,'2019-05-17 17:31:00','2019-05-17 17:26:49'),(289417382983528448,'<h1>命令大全</h1>','sys','待编辑','<p><strong>命令大全</strong></p>\n\n<p><a href=\"https://redis.io/commands\">https://redis.io/commands</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>命令大全</strong></p>\n\n<p><a href=\"http://redisdoc.com/\">Http://redisdoc.com/</a></p>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:25:39','2019-05-17 18:25:39'),(289418506339774464,'<h1>键(key)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-keys.html\">https://www.runoob.com/redis/redis-keys.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>KEYS pattern</td>\n			<td>查找所有符合给定模式( pattern)的 key 。</td>\n		</tr>\n		<tr>\n			<td>EXISTS key</td>\n			<td>检查给定 key 是否存在。</td>\n		</tr>\n		<tr>\n			<td>MOVE key db</td>\n			<td>将当前数据库的 key 移动到给定的数据库 db 当中。</td>\n		</tr>\n		<tr>\n			<td>EXPIRE key seconds</td>\n			<td>为给定 key 设置过期时间，以秒计。</td>\n		</tr>\n		<tr>\n			<td>TTL key</td>\n			<td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>\n		</tr>\n		<tr>\n			<td>TYPE key</td>\n			<td>返回 key 所储存的值的类型。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p><br>\n&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:22:06','2019-05-17 18:22:06'),(289421619205402624,'<h1>字符串(String)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-strings.html\">https://www.runoob.com/redis/redis-strings.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>SET key value</td>\n			<td>设置指定 key 的值</td>\n		</tr>\n		<tr>\n			<td>GET key</td>\n			<td>获取指定 key 的值</td>\n		</tr>\n		<tr>\n			<td>DEL key [key ...]</td>\n			<td>删除指定 key&nbsp;</td>\n		</tr>\n		<tr>\n			<td>APPEND key value</td>\n			<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>\n		</tr>\n		<tr>\n			<td>STRLEN key</td>\n			<td>返回 key 所储存的字符串值的长度。</td>\n		</tr>\n		<tr>\n			<td>INCR key</td>\n			<td>将 key 中储存的数字值增一。</td>\n		</tr>\n		<tr>\n			<td>DECR key</td>\n			<td>将 key 中储存的数字值减一。</td>\n		</tr>\n		<tr>\n			<td>INCRBY key increment</td>\n			<td>将 key 所储存的值加上给定的增量值（increment） 。</td>\n		</tr>\n		<tr>\n			<td>DECRBY key decrement</td>\n			<td>key 所储存的值减去给定的减量值（decrement） 。</td>\n		</tr>\n		<tr>\n			<td>GETRANGE key start end</td>\n			<td>返回 key 中字符串值的子字符</td>\n		</tr>\n		<tr>\n			<td>SETRANGE key offset value</td>\n			<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>\n		</tr>\n		<tr>\n			<td>SETEX key seconds value</td>\n			<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>\n		</tr>\n		<tr>\n			<td>SETNX key value</td>\n			<td>只有在 key 不存在时设置 key 的值。</td>\n		</tr>\n		<tr>\n			<td>MGET key1 [key2..]</td>\n			<td>获取所有(一个或多个)给定 key 的值。</td>\n		</tr>\n		<tr>\n			<td>MSET key value [key value ...]</td>\n			<td>同时设置一个或多个 key-value 对。</td>\n		</tr>\n		<tr>\n			<td>MSETNX key value [key value ...]&nbsp;</td>\n			<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>\n		</tr>\n		<tr>\n			<td>GETSET key value</td>\n			<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-06-14 03:01:03','2019-06-14 03:01:03'),(289424056247021568,'<h1>哈希(Hash)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-hashes.html\">https://www.runoob.com/redis/redis-hashes.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>HGET key field&nbsp;</td>\n			<td>获取存储在哈希表中指定字段的值。</td>\n		</tr>\n		<tr>\n			<td>HSET key field value&nbsp;</td>\n			<td>将哈希表 key 中的字段 field 的值设为 value 。</td>\n		</tr>\n		<tr>\n			<td>HDEL key field1 [field2]&nbsp;</td>\n			<td>删除一个或多个哈希表字段</td>\n		</tr>\n		<tr>\n			<td>HMGET key field1 [field2]&nbsp;</td>\n			<td>获取所有给定字段的值</td>\n		</tr>\n		<tr>\n			<td>HMSET key field1 value1 [field2 value2 ]&nbsp;</td>\n			<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>\n		</tr>\n		<tr>\n			<td>HGETALL key&nbsp;</td>\n			<td>获取在哈希表中指定 key 的所有字段和值</td>\n		</tr>\n		<tr>\n			<td>HLEN key&nbsp;</td>\n			<td>获取哈希表中字段的数量</td>\n		</tr>\n		<tr>\n			<td>HEXISTS key field&nbsp;</td>\n			<td>查看哈希表 key 中，指定的字段是否存在。</td>\n		</tr>\n		<tr>\n			<td>HKEYS key&nbsp;</td>\n			<td>获取所有哈希表中的字段</td>\n		</tr>\n		<tr>\n			<td>HVALS key&nbsp;</td>\n			<td>获取哈希表中所有值</td>\n		</tr>\n		<tr>\n			<td>HINCRBY key field increment&nbsp;</td>\n			<td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>\n		</tr>\n		<tr>\n			<td>HINCRBYFLOAT key field increment&nbsp;</td>\n			<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>\n		</tr>\n		<tr>\n			<td>HSETNX key field value&nbsp;</td>\n			<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:37:39','2019-05-17 18:37:39'),(289424700320149504,'<h1>列表(List)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-lists.html\">https://www.runoob.com/redis/redis-lists.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>LPUSH key value1 [value2]&nbsp;</td>\n			<td>将一个或多个值插入到列表头部</td>\n		</tr>\n		<tr>\n			<td>RPUSH key value1 [value2]&nbsp;</td>\n			<td>在列表中添加一个或多个值</td>\n		</tr>\n		<tr>\n			<td>LRANGE key start stop&nbsp;</td>\n			<td>获取列表指定范围内的元素</td>\n		</tr>\n		<tr>\n			<td>LPOP key&nbsp;</td>\n			<td>移出并获取列表的第一个元素</td>\n		</tr>\n		<tr>\n			<td>RPOP key</td>\n			<td>移除列表的最后一个元素，返回值为移除的元素。</td>\n		</tr>\n		<tr>\n			<td>LINDEX key index&nbsp;</td>\n			<td>通过索引获取列表中的元素</td>\n		</tr>\n		<tr>\n			<td>LLEN key&nbsp;</td>\n			<td>获取列表长度</td>\n		</tr>\n		<tr>\n			<td>LREM key count value</td>\n			<td>移除列表元素</td>\n		</tr>\n		<tr>\n			<td>LTRIM key start stop&nbsp;</td>\n			<td>\n			<p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，</p>\n\n			<p>不在指定区间之内的元素都将被删除。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>BRPOPLPUSH source destination timeout&nbsp;</td>\n			<td>\n			<p>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；</p>\n\n			<p>如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>LSET key index value</td>\n			<td>通过索引设置列表元素的值</td>\n		</tr>\n		<tr>\n			<td>LINSERT key BEFORE|AFTER pivot value&nbsp;</td>\n			<td>在列表的元素前或者后插入元素</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:41:54','2019-05-17 18:41:54'),(289424734310789120,'<h1>集合(Set)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-sets.html\">https://www.runoob.com/redis/redis-sets.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>SADD key member1 [member2]&nbsp;</td>\n			<td>向集合添加一个或多个成员</td>\n		</tr>\n		<tr>\n			<td>SMEMBERS key&nbsp;</td>\n			<td>返回集合中的所有成员</td>\n		</tr>\n		<tr>\n			<td>SISMEMBER key member</td>\n			<td>判断 member 元素是否是集合 key 的成员</td>\n		</tr>\n		<tr>\n			<td>SCARD key&nbsp;</td>\n			<td>获取集合的成员数</td>\n		</tr>\n		<tr>\n			<td>SREM key member1 [member2]&nbsp;</td>\n			<td>移除集合中一个或多个成员</td>\n		</tr>\n		<tr>\n			<td>SRANDMEMBER key [count]&nbsp;</td>\n			<td>返回集合中一个或多个随机数</td>\n		</tr>\n		<tr>\n			<td>SPOP key&nbsp;</td>\n			<td>移除并返回集合中的一个随机元素</td>\n		</tr>\n		<tr>\n			<td>SMOVE source destination member&nbsp;</td>\n			<td>将 member 元素从 source 集合移动到 destination 集合</td>\n		</tr>\n		<tr>\n			<td>SDIFF key1 [key2]</td>\n			<td>返回给定所有集合的差集</td>\n		</tr>\n		<tr>\n			<td>SINTER key1 [key2]</td>\n			<td>返回给定所有集合的交集</td>\n		</tr>\n		<tr>\n			<td>SUNION key1 [key2]&nbsp;</td>\n			<td>返回所有给定集合的并集</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:45:19','2019-05-17 18:45:19'),(289424772835471360,'<h1>有序集合(sorted set)</h1>','sys','待编辑','<p><strong>1、基本命令</strong></p>\n\n<p><a href=\"https://www.runoob.com/redis/redis-sorted-sets.html\">https://www.runoob.com/redis/redis-sorted-sets.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>ZADD key score1 member1 [score2 member2]&nbsp;</td>\n			<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>\n		</tr>\n		<tr>\n			<td>ZRANGE key start stop [WITHSCORES]&nbsp;</td>\n			<td>通过索引区间返回有序集合成指定区间内的成员</td>\n		</tr>\n		<tr>\n			<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]&nbsp;</td>\n			<td>通过分数返回有序集合指定区间内的成员</td>\n		</tr>\n		<tr>\n			<td>ZREM key member [member ...]&nbsp;</td>\n			<td>移除有序集合中的一个或多个成员</td>\n		</tr>\n		<tr>\n			<td>ZCARD key&nbsp;</td>\n			<td>获取有序集合的成员数</td>\n		</tr>\n		<tr>\n			<td>ZCOUNT key min max</td>\n			<td>计算在有序集合中指定区间分数的成员数</td>\n		</tr>\n		<tr>\n			<td>ZREVRANK key member&nbsp;</td>\n			<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>\n		</tr>\n		<tr>\n			<td>ZREVRANGE key start stop [WITHSCORES]</td>\n			<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>\n		</tr>\n		<tr>\n			<td>ZREVRANGEBYSCORE key max min [WITHSCORES]&nbsp;</td>\n			<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289414388690874368,'2019-05-17 18:48:40','2019-05-17 18:48:40'),(289438229697818624,'<h1>常见配置</h1>','sys','待编辑','<p>1、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br>\n&nbsp; &nbsp; &nbsp; &nbsp; daemonize no</p>\n\n<p><br>\n2、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis、pid文件，可以通过pidfile指定<br>\n&nbsp; &nbsp; &nbsp; &nbsp; pidfile /var/run/redis、pid</p>\n\n<p><br>\n3、指定Redis监听端口，默认端口为6379<br>\n&nbsp; &nbsp; &nbsp; &nbsp; port 6379<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n4、绑定的主机地址<br>\n&nbsp; &nbsp; &nbsp; &nbsp; bind 127、0、0、1<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n5、当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能<br>\n&nbsp; &nbsp; &nbsp; &nbsp; timeout 300<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n6、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose<br>\n&nbsp; &nbsp; &nbsp; &nbsp; loglevel verbose<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n7、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null<br>\n&nbsp; &nbsp; &nbsp; &nbsp; logfile stdout<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n8、设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id<br>\n&nbsp; &nbsp; &nbsp; &nbsp; databases 16<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n9、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合<br>\n&nbsp; &nbsp; &nbsp; &nbsp; save &lt;seconds&gt; &lt;changes&gt;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; Redis默认配置文件中提供了三个条件：<br>\n&nbsp; &nbsp; &nbsp; &nbsp; save 900 1<br>\n&nbsp; &nbsp; &nbsp; &nbsp; save 300 10<br>\n&nbsp; &nbsp; &nbsp; &nbsp; save 60 10000<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。<br>\n&nbsp;<br>\n10、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<br>\n&nbsp; &nbsp; &nbsp; &nbsp; rdbcompression yes<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n11、指定本地数据库文件名，默认值为dump、rdb<br>\n&nbsp; &nbsp; &nbsp; &nbsp; dbfilename dump、rdb<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n12、指定本地数据库存放目录<br>\n&nbsp; &nbsp; &nbsp; &nbsp; dir 、/<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n13、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<br>\n&nbsp; &nbsp; &nbsp; &nbsp; slaveof &lt;masterip&gt; &lt;masterport&gt;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n14、当master服务设置了密码保护时，slav服务连接master的密码<br>\n&nbsp; &nbsp; &nbsp; &nbsp; masterauth &lt;master-password&gt;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n15、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭<br>\n&nbsp; &nbsp; &nbsp; &nbsp; requirepass foobared<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n16、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息<br>\n&nbsp; &nbsp; &nbsp; &nbsp; maxclients 128<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n17、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<br>\n&nbsp; &nbsp; &nbsp; &nbsp; maxmemory &lt;bytes&gt;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n18、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<br>\n&nbsp; &nbsp; &nbsp; &nbsp; appendonly no<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n19、指定更新日志文件名，默认为appendonly、aof<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;appendfilename appendonly、aof<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n20、指定更新日志条件，共有3个可选值：&nbsp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; no：表示等操作系统进行数据缓存同步到磁盘（快）&nbsp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）&nbsp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; everysec：表示每秒同步一次（折衷，默认值）<br>\n&nbsp; &nbsp; &nbsp; &nbsp; appendfsync everysec<br>\n&nbsp;<br>\n21、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-enabled no<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n22、虚拟内存文件路径，默认值为/tmp/redis、swap，不可多个Redis实例共享<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-swap-file /tmp/redis、swap<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n23、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-max-memory 0<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n24、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-page-size 32<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n25、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-pages 134217728<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n26、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vm-max-threads 4<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n27、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br>\n&nbsp; &nbsp; &nbsp; &nbsp; glueoutputbuf yes<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n28、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<br>\n&nbsp; &nbsp; &nbsp; &nbsp; hash-max-zipmap-entries 64<br>\n&nbsp; &nbsp; &nbsp; &nbsp; hash-max-zipmap-value 512<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n29、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<br>\n&nbsp; &nbsp; &nbsp; &nbsp; activerehashing yes<br>\n&nbsp;&nbsp; &nbsp;&nbsp;<br>\n30、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<br>\n&nbsp; &nbsp; &nbsp; &nbsp; include /path/to/local、conf</p>\n',0,289438180121145344,'2019-05-17 18:58:04','2019-05-17 18:58:04'),(289447002223046656,'<h1>RDB</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;持久化文件：dump.rdb</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、持久化过程</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）Redis 调用 fork() ，创建一个子进程。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）主进程继续处理client请求，且不进行任何IO操作，以保证性能。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）子进程会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 备注：fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是是一个全新的进程，并作为原进程的子进程</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置</strong></p>\n\n<pre><code># 时间策略\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 文件名称\ndbfilename dump.rdb\n\n# 文件保存路径\ndir /home/work/app/redis/data/\n\n# 如果持久化出错，主进程是否停止写入\nstop-writes-on-bgsave-error yes\n\n# 是否压缩\nrdbcompression yes\n\n# 导入时是否检查\nrdbchecksum yes</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、触发快照</strong></p>\n\n<ul>\n	<li>自动触发\n	<ul>\n		<li>根据&nbsp;<code>save m n</code>&nbsp;配置规则自动触发；</li>\n		<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发&nbsp;<code>bgsave</code>；</li>\n		<li>执行&nbsp;<code>debug reload</code>&nbsp;时；</li>\n		<li>执行&nbsp;<code>shutdown</code>时，如果没有开启aof，也会触发。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>手动触发\n	<ul>\n		<li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li>\n		<li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、恢复</strong></p>\n\n<ul>\n	<li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li>\n	<li>CONFIG GET dir获取目录</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、优缺点</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>方便备份</li>\n		<li>适合大规模的数据恢复</li>\n		<li>对数据完整性和一致性要求不高&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>缺点\n	<ul>\n		<li>如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>\n		<li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程。这可能会非常耗时，造成服务器暂时停止处理客户端。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289440211389018112,'2019-05-17 20:32:01','2019-05-17 20:32:01'),(289447095269486592,'<h1>AOF</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; AOF：Append Only File，以日志的形式来记录每个写操作，并追加到文件中。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当Redis重启时，会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 持久化文件：appendonly.aof</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、持久化过程</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）Redis 调用 fork() ，创建一个子进程。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）主进程处理client请求，把写命令写入到aof文件中，并把写命令缓存起来。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）子进程往临时文件中写入重建数据库状态的命令，之后通知主进程。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 4）主进程把缓存的写命令也写入到临时文件，然后用临时文件替换老aof文件。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置</strong></p>\n\n<pre><code># 是否开启aof\nappendonly yes\n\n# 文件名称\nappendfilename \"appendonly.aof\"\n\n# 同步方式\nappendfsync everysec\n\n# aof重写期间是否同步\nno-appendfsync-on-rewrite no\n\n# 重写触发配置\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# 加载aof时如果有错如何处理\naof-load-truncated yes\n\n# 文件重写策略\naof-rewrite-incremental-fsync yes</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、触发</strong></p>\n\n<ul>\n	<li>自动触发\n	<ul>\n		<li>根据配置规则自动触发；</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>手动触发\n	<ul>\n		<li>bgrewriteaof</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、优缺点</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>每修改同步：appendfsync always，同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>\n		<li>每秒同步：appendfsync everysec，异步操作，每秒记录，如果一秒内宕机，有数据丢失</li>\n		<li>不同步：appendfsync no &nbsp; 从不同步</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>缺点\n	<ul>\n		<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>\n		<li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289440211389018112,'2019-05-17 20:57:18','2019-05-17 20:57:18'),(289470094580281344,'<h1>RDB vs AOF</h1>','sys','待编辑','<p><strong>1、持久化</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、RDB持久化方式</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够在指定的时间间隔能对你的数据进行快照存储</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、AOF持久化方式</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p>\n',0,289440211389018112,'2019-05-17 22:20:46','2019-05-17 22:20:46'),(289471108880429056,'<h1>事务</h1>','sys','待编辑','<p><strong>1、常用命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">&nbsp;</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>DISCARD</td>\n			<td>取消事务，放弃执行事务块内的所有命令。</td>\n		</tr>\n		<tr>\n			<td>EXEC</td>\n			<td>执行所有事务块内的命令。</td>\n		</tr>\n		<tr>\n			<td>MULTI</td>\n			<td>标记一个事务块的开始。</td>\n		</tr>\n		<tr>\n			<td>UNWATCH</td>\n			<td>取消 WATCH 命令对所有 key 的监视。</td>\n		</tr>\n		<tr>\n			<td>WATCH key [key ...]&nbsp;</td>\n			<td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、阶段</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）开启：以MULTI开始一个事务</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）执行：由EXEC命令触发事务</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、特性</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）单独的隔离操作：事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）没有隔离级别的概念：事务提交前任何指令都不会被实际执行。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>\n\n<p>&nbsp;</p>\n',0,289471075917393920,'2019-05-17 21:08:05','2019-05-17 21:08:05'),(289472949500407808,'<h1>订阅发布</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发布订阅(pub/sub)是进程中的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、命令</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<td>PSUBSCRIBE pattern [pattern ...]&nbsp;</td>\n			<td>订阅一个或多个符合给定模式的频道。</td>\n		</tr>\n		<tr>\n			<td>PUBSUB subcommand [argument [argument ...]]&nbsp;</td>\n			<td>查看订阅与发布系统状态。</td>\n		</tr>\n		<tr>\n			<td>PUBLISH channel message&nbsp;</td>\n			<td>将信息发送到指定的频道。</td>\n		</tr>\n		<tr>\n			<td>PUNSUBSCRIBE [pattern [pattern ...]]&nbsp;</td>\n			<td>退订所有给定模式的频道。</td>\n		</tr>\n		<tr>\n			<td>SUBSCRIBE channel [channel ...]&nbsp;</td>\n			<td>订阅给定的一个或多个频道的信息。</td>\n		</tr>\n		<tr>\n			<td>UNSUBSCRIBE [channel [channel ...]]&nbsp;</td>\n			<td>指退订给定的频道。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289472917942464512,'2019-05-17 21:12:37','2019-05-17 21:12:37'),(289474454605426688,'<h1>Master/Slave</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 即主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、应用</strong></p>\n\n<ul>\n	<li>读写分离</li>\n	<li>容灾恢复</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>3、...</p>\n',0,289474290947878912,'2019-05-17 21:18:28','2019-05-17 21:18:28'),(289474469570703360,'<h1>Jedis</h1>','sys','待编辑','<p>1、Jedis</p>\n\n<p>&nbsp; &nbsp; Jedis是集成了redis的一些命令操作、封装了redis的java客户端。</p>\n',0,289474380475297792,'2019-05-17 21:20:39','2019-05-17 21:20:39'),(289477617634930688,'<h1>提问-Redis</h1>','sys','待编辑','<p><strong>1、Redis是什么？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis，<strong>Re</strong>mote&nbsp;<strong>Di</strong>ctionary&nbsp;<strong>S</strong>erver，是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Redis的好处？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 性能、并发</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Redis的缺点？</strong></p>\n\n<ul>\n	<li>缓存和数据库双写一致性问题</li>\n	<li>缓存雪崩问题</li>\n	<li>缓存击穿问题</li>\n	<li>缓存的并发竞争问题</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、单线程的redis为什么这么快？</strong></p>\n\n<ul>\n	<li>纯内存操作</li>\n	<li>单线程操作，避免了频繁的上下文切换</li>\n	<li>采用了非阻塞I/O多路复用机制</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Redis相比memcached有哪些优势？</strong></p>\n\n<ul>\n	<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>\n	<li>redis的速度比memcached快很多</li>\n	<li>redis可以持久化其数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、Redis的数据类型及使用场景？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">数据类型</th>\n			<th scope=\"col\">value</th>\n			<th scope=\"col\">使用场景</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>String</td>\n			<td>String、数字</td>\n			<td>常规key-value缓存应用、常规计数：微博数，粉丝数等</td>\n		</tr>\n		<tr>\n			<td>Hash</td>\n			<td>结构化的对象</td>\n			<td>比如可以存储用户信息，商品信息等等</td>\n		</tr>\n		<tr>\n			<td>List</td>\n			<td>链表</td>\n			<td>比如微博的关注列表，粉丝列表、消息队列</td>\n		</tr>\n		<tr>\n			<td>Set</td>\n			<td>不重复值的集合</td>\n			<td>比如共同关注、共同喜好</td>\n		</tr>\n		<tr>\n			<td>Sorted Set</td>\n			<td>不重复值的集合</td>\n			<td>比如排行榜，取TOP</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>7、Redis的过期策略</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis采用的是定期删除+惰性删除策略。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 定时删除：用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定期删除：redis默认每隔100ms随机抽取进行检查，是否有过期的key，有过期key则删除。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 惰性删除：当访问一个key时，才会判断该key是否已过期，过期则删除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>8、Redis内存淘汰机制&nbsp;</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 命令：maxmemory-policy allkeys-lru</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">内存淘汰机制</th>\n			<th scope=\"col\">当内存不足以容纳新写入数据时</th>\n			<th scope=\"col\">建议</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>noeviction</td>\n			<td>新写入操作会报错</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>allkeys-lru</td>\n			<td>在键空间中，移除最近最少使用的key</td>\n			<td>推荐</td>\n		</tr>\n		<tr>\n			<td>allkeys-random</td>\n			<td>在键空间中，随机移除某个key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-lru</td>\n			<td>在设置了过期时间的键空间中，移除最近最少使用的key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-random</td>\n			<td>在设置了过期时间的键空间中，随机移除某个key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-ttl</td>\n			<td>在设置了过期时间的键空间中，有更早过期时间的key优先移除</td>\n			<td>不推荐</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>9、redis和数据库双写一致性问题？</strong></p>\n\n<ul>\n	<li>采取正确更新策略，先更新数据库，再删缓存。</li>\n	<li>因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>10、缓存穿透？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 避免：1、对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、对一定不存在的key进行过滤。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>11、缓存雪崩？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 避免：1、在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 2、做二级缓存</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n\n<p>&nbsp;</p>\n',0,289404035772870656,'2019-06-02 13:00:59','2019-06-02 13:00:59'),(289675675027009536,'<h1>面试题</h1>','sys','待编辑','<h2>JavaSE</h2>\n\n<p><strong>1、Java 面向对象特性？</strong></p>\n\n<ul>\n	<li>封装：将属性和行为绑定起来，并隐藏部分实现的细节，对外只提供访问接口。</li>\n	<li>继承：指继承父类的状态和行为，创建子类的过程。</li>\n	<li>多态：指允许不同子类对象对同一消息作出不同的响应。</li>\n	<li>抽象：是将一类对象的共同特征总结出来构造类的过程。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常见异常错误？</strong></p>\n\n<ul>\n	<li>java.lang.NullPointerException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 空指针异常</li>\n	<li>java.lang.ClassNotFoundException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 指定的类找不到</li>\n	<li>java.lang.NumberFormatException &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 字符串转换为数字异常</li>\n	<li>java.lang.IndexOutOfBoundsException &nbsp;&nbsp; &nbsp;数组角标越界异常</li>\n	<li>java.lang.NoSuchMethodException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;方法不存在异常</li>\n	<li>java.sql.SQLException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SQL异常</li>\n</ul>\n\n<ul>\n	<li>java.lang.OutOfMemoryError&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;内存溢出</li>\n	<li>java.lang.StackOverflowError&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;栈内存溢出</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、数据类型转换</strong></p>\n\n<pre><code>//语句1\nshort s1 = 1;\ns1 = s1 + 1;\n\n\n//语句2\nshort s1 = 1;\ns1 += 1;\n\n\n\n//答案\n//语句1：s1+1 运算结果是 int 型，需要强制转换类型\n//语句2：可以正确编译\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、自动装箱、拆箱</strong></p>\n\n<pre><code>Integer a = new Integer(3);\nInteger b = 3;                  // 将3自动装箱成Integer类型\nint c = 3;\nSystem.out.println(a == b);     // false 两个引用没有引用同一对象\nSystem.out.println(a == c);     // true a自动拆箱成int类型再和c比较\n\n\nInteger f1=100,f2=100,f3=150,f4=150;\nSystem.out.println(f1==f2);\nSystem.out.println(f3==f4);\n\n\n//答案：\ntrue、false\n\n\n/** \n * 从jdk5开始引入了装箱、拆箱机制\n * 在Integer常量池中，Integer只对包装了int值在-128-127这个范围的Integer对象做了共享\n * 关于Integer中的==，源码如下：\n */\npublic static Integer valueOf(int i) {\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、字符串常量、字符串对象</strong></p>\n\n<pre><code>String s1 = \"Programming\"; \nString s2 = new String(\"Programming\");\nString s3 = \"Program\";\nString s4 = \"ming\";\nString s5 = \"Program\" + \"ming\";\nString s6 = s3 + s4;\n\nSystem.out.println(s1 == s2); \nSystem.out.println(s1 == s5);\nSystem.out.println(s1 == s6);\n\nSystem.out.println(s1 == s6.intern());\nSystem.out.println(s2 == s2.intern());\n\n\n//答案：\nfalse、true、false\ntrue、false\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、equals() 与 == 的区别？</strong></p>\n\n<ul>\n	<li>==\n	<ul>\n		<li>基本数据类型比较的是值</li>\n		<li>引用类型比较的是地址值</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>equals()\n	<ul>\n		<li>不能比较基本数据类型</li>\n		<li>如果没有重写equals方法，则等同 ==</li>\n		<li>如果已经重写equals方法，则按照自定义方式进行比较</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、&nbsp;volatile、synchronized&nbsp;的区别？</strong></p>\n\n<ul>\n	<li>volatile\n	<ul>\n		<li>仅能修饰变量</li>\n		<li>仅能保证变量的修改可见性，不能保证原子性</li>\n		<li>标记的变量不可被编译器优化</li>\n		<li>不可阻塞线程</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>synchronized\n	<ul>\n		<li>能够修饰变量、方法、类</li>\n		<li>能够保证变量的修改可见性和原子性</li>\n		<li>标记的变量可以被编译器优化</li>\n		<li>能够阻塞线程</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、final、finally、finalize 的区别？</strong></p>\n\n<ul>\n	<li>final： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li>\n	<li>finally：是异常处理语句结构的一部分，表示总是执行。</li>\n	<li>finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>9、sleep()、wait() 的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">sleep()</th>\n			<th scope=\"col\">wait()</th>\n		</tr>\n		<tr>\n			<th scope=\"row\">类</th>\n			<td>java.lang.Thread</td>\n			<td>java.lang.Object</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">效果</th>\n			<td>\n			<p>让调用线程进入睡眠状态，让出执行机会给其他线程</p>\n\n			<p>不会释放对象锁</p>\n			</td>\n			<td>\n			<p>让调用线程进入到一个和该对象相关的等待池，</p>\n\n			<p>同时释放对象的机锁，使得其他线程能够访问</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">唤醒</th>\n			<td>等到休眠时间结束后，线程自动进入就绪状态</td>\n			<td>通过notify，notifyAll方法来唤醒等待的线程</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>10、方法重载、&nbsp;方法重写</strong></p>\n\n<ul>\n	<li>重载&nbsp;overload\n	<ul>\n		<li>在一个类里面，方法名字相同，而参数不同</li>\n		<li>每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序）</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>重写 override\n	<ul>\n		<li>是子类对父类方法的实现进行重新编写</li>\n		<li>方法名、参数列表均相同</li>\n		<li>重写方法抛出的异常，需宽于被重写方法</li>\n		<li>构造方法不能被重写</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>区别</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th>区别点</th>\n			<th>重载方法</th>\n			<th>重写方法</th>\n		</tr>\n		<tr>\n			<td>参数列表</td>\n			<td>必须修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>返回类型</td>\n			<td>可以修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>异常</td>\n			<td>可以修改</td>\n			<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>\n		</tr>\n		<tr>\n			<td>访问</td>\n			<td>可以修改</td>\n			<td>一定不能做更严格的限制（可以降低限制）</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h2>JavaEE</h2>\n\n<p><strong>1、HTTP 请求 GET、POST 方式的区别？</strong></p>\n\n<ul>\n	<li>post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</li>\n	<li>post发送的数据更大（get有url长度限制）&nbsp;</li>\n	<li>post能发送更多的数据类型（get只能发送ASCII字符）&nbsp;</li>\n	<li>post比get慢&nbsp;</li>\n	<li>post一般用于修改和写入数据，get一般用于读取数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、cookie、session&nbsp;的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">cookie</th>\n			<th scope=\"col\">session</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<th scope=\"row\">数据存放位置</th>\n			<td>客户的浏览器</td>\n			<td>服务器</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">安全程度</th>\n			<td>可能会被篡改</td>\n			<td>安全</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">性能方面</th>\n			<td>只影响客户的浏览器</td>\n			<td>占用服务器性能</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">存储数据量</th>\n			<td>客户的浏览器对其有限制</td>\n			<td>不影响</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">存储结构</th>\n			<td>键值对形式的文本</td>\n			<td>哈希表结构</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<h2>Redis</h2>\n\n<p><strong>1、Redis是什么？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis，<strong>Re</strong>mote&nbsp;<strong>Di</strong>ctionary&nbsp;<strong>S</strong>erver，是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Redis的好处？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 性能、并发</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Redis的缺点？</strong></p>\n\n<ul>\n	<li>缓存和数据库双写一致性问题</li>\n	<li>缓存雪崩问题</li>\n	<li>缓存击穿问题</li>\n	<li>缓存的并发竞争问题</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、单线程的redis为什么这么快？</strong></p>\n\n<ul>\n	<li>纯内存操作</li>\n	<li>单线程操作，避免了频繁的上下文切换</li>\n	<li>采用了非阻塞I/O多路复用机制</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Redis相比memcached有哪些优势？</strong></p>\n\n<ul>\n	<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>\n	<li>redis的速度比memcached快很多</li>\n	<li>redis可以持久化其数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、Redis的数据类型及使用场景？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">数据类型</th>\n			<th scope=\"col\">value</th>\n			<th scope=\"col\">使用场景</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>String</td>\n			<td>String、数字</td>\n			<td>常规key-value缓存应用、常规计数：微博数，粉丝数等</td>\n		</tr>\n		<tr>\n			<td>Hash</td>\n			<td>结构化的对象</td>\n			<td>比如可以存储用户信息，商品信息等等</td>\n		</tr>\n		<tr>\n			<td>List</td>\n			<td>链表</td>\n			<td>比如微博的关注列表，粉丝列表、消息队列</td>\n		</tr>\n		<tr>\n			<td>Set</td>\n			<td>不重复值的集合</td>\n			<td>比如共同关注、共同喜好</td>\n		</tr>\n		<tr>\n			<td>Sorted Set</td>\n			<td>不重复值的集合</td>\n			<td>比如排行榜，取TOP</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>7、Redis的过期策略</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis采用的是定期删除+惰性删除策略。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 定时删除：用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定期删除：redis默认每隔100ms随机抽取进行检查，是否有过期的key，有过期key则删除。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 惰性删除：当访问一个key时，才会判断该key是否已过期，过期则删除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>8、Redis内存淘汰机制&nbsp;</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 命令：maxmemory-policy allkeys-lru</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">内存淘汰机制</th>\n			<th scope=\"col\">当内存不足以容纳新写入数据时</th>\n			<th scope=\"col\">建议</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>noeviction</td>\n			<td>新写入操作会报错</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>allkeys-lru</td>\n			<td>在键空间中，移除最近最少使用的key</td>\n			<td>推荐</td>\n		</tr>\n		<tr>\n			<td>allkeys-random</td>\n			<td>在键空间中，随机移除某个key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-lru</td>\n			<td>在设置了过期时间的键空间中，移除最近最少使用的key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-random</td>\n			<td>在设置了过期时间的键空间中，随机移除某个key</td>\n			<td>不推荐</td>\n		</tr>\n		<tr>\n			<td>volatile-ttl</td>\n			<td>在设置了过期时间的键空间中，有更早过期时间的key优先移除</td>\n			<td>不推荐</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>9、redis和数据库双写一致性问题？</strong></p>\n\n<ul>\n	<li>采取正确更新策略，先更新数据库，再删缓存。</li>\n	<li>因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>10、缓存穿透？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 避免：1、对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、对一定不存在的key进行过滤。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>11、缓存雪崩？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 避免：1、在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 2、做二级缓存</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<h2>Zookeeper</h2>\n\n<p><strong>1、ZooKeeper的选举机制？</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、ZooKeeper的监听原理？</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群最少需要几台机器？</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）部署方式单机模式、集群模式<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）角色：Leader和Follower<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）集群最少需要机器数：3</p>\n\n<p><br>\n<strong>4、 ZooKeeper的常用命令</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls create get delete set…</p>\n\n<p>&nbsp;</p>\n\n<h2><strong>SpringMVC</strong></h2>\n\n<p><strong>1、什么是 SpringMVC？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种基于 Java 的、实现了MVC 设计模式的、请求驱动类型的轻量级 Web 框架。，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便开发人员间的配合</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、SpringMVC 的流程？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）发起请求到前端控制器(DispatcherServlet)。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）前端控制器请求HandlerMapping查找 Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）HandlerMapping向前端控制器返回Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）前端控制器调用HandlerAdapter去执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）HandlerAdapter执行Handler。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）Handler执行完成后，向HandlerAdapter返回ModelAndView。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）HandlerAdapter将ModelAndView返回给前端控制器。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8）前端控制器将ModelAndView传给ViewReslover。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9）ViewReslover解析后，向前端控制器返回具体View。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10）前端控制器根据View进行渲染视图。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11）前端控制器响应用户。</p>\n\n<p><img alt=\"SpringMVC工作流程\" src=\"/furesky/images/spring/springmvc-flow.png\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、SpringMVC 的优点？</strong></p>\n\n<ul>\n	<li>清晰的角色划分，分工明确，可灵活扩展</li>\n	<li>功能强大的数据验证、格式化、绑定机制</li>\n	<li>和 Spring 其他框架无缝集成</li>\n	<li>支持各种请求资源的映射策略</li>\n	<li>支持各种视图技术</li>\n	<li>支持RESTful 风格</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、中文乱码问题？</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong> &nbsp; 1）get乱码</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案一：修改tomcat配置文件：</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案二：对参数进行重新编码：</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String userName=new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\");</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）post乱码：<strong>&nbsp;&nbsp;</strong>修改web.xml文件</p>\n\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;/param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、SpringMVC 与 Struts2 的区别？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1）SpringMVC 的入口是一个 servlet 即前端控制器，而 Struts2 入口是一个 filter 过虑器。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）SpringMVC&nbsp;基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;Struts2&nbsp;是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）参数传递方式不同</p>\n\n<p>&nbsp;</p>\n\n<h2>Spring</h2>\n\n<p><strong>1、Spring是什么?</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring是一个轻量级的IoC和AOP容器框架。目的是用于简化企业应用程序的开发。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring的优点？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）轻量、低侵入式： Spring 在代码量和透明度方面都很轻便。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）控制反转： Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）面向切面编程(AOP)： Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开，以实现高内聚。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）容器： Spring 负责创建和管理对象（Bean）的生命周期和配置。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）MVC框架 ：对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）事务管理： 提供了用于事务管理的通用抽象层。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）异常处理： Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring中的模块？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心容器、数据访问/集成、Web、AOP及其他</p>\n\n<ul>\n	<li>Spring Core</li>\n	<li>Spring Bean</li>\n	<li>SpEL&nbsp;</li>\n	<li>Spring Context</li>\n	<li>...</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Spring 中用到的设计模式？</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）单例模式：Bean默认为单例模式。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）模板方法：用来解决代码重复的问题。比如.&nbsp;RestTemplate,&nbsp;JmsTemplate,&nbsp;JpaTemplate。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、IOC？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; IOC，即控制反转，是一种设计思想。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 传统程序由调用者主动控制，去直接创建获取依赖对象。IoC中，则是由IoC容器，来控制创建获取依赖对象。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建被调用者的工作由spring来完成，然后注入调用者直接使用，从而实现程序的低耦合</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; DI，依赖注入，由容器动态的将某个依赖关系注入到组件之中。IoC和DI是同一个概念的不同角度描述。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、BeanFactory 和 ApplicationContext的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<thead>\n		<tr>\n			<th>BeanFactory</th>\n			<th>ApplicationContext</th>\n		</tr>\n		<tr>\n			<td>它使用懒加载</td>\n			<td>它使用即时加载</td>\n		</tr>\n		<tr>\n			<td>它使用语法显式提供资源对象</td>\n			<td>它自己创建和管理资源对象</td>\n		</tr>\n		<tr>\n			<td>不支持国际化</td>\n			<td>支持国际化</td>\n		</tr>\n		<tr>\n			<td>不支持基于依赖的注解</td>\n			<td>支持基于依赖的注解</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、构造函数注入和 setter 注入的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<thead>\n		<tr>\n			<th scope=\"col\">构造函数注入</th>\n			<th scope=\"col\">setter 注入</th>\n		</tr>\n		<tr>\n			<td>没有部分注入</td>\n			<td>有部分注入</td>\n		</tr>\n		<tr>\n			<td>不会覆盖 setter 属性</td>\n			<td>会覆盖 setter 属性</td>\n		</tr>\n		<tr>\n			<td>任意修改都会创建一个新实例</td>\n			<td>任意修改不会创建一个新实例</td>\n		</tr>\n		<tr>\n			<td>适用于设置很多属性</td>\n			<td>适用于设置少量属性</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Spring自动装配模式？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<thead>\n		<tr>\n			<th scope=\"col\">模式</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>no</td>\n			<td>默认模式，没有自动装配</td>\n		</tr>\n		<tr>\n			<td>byName</td>\n			<td>由属性名自动装配。</td>\n		</tr>\n		<tr>\n			<td>byType</td>\n			<td>由属性数据类型自动装配。</td>\n		</tr>\n		<tr>\n			<td>constructor</td>\n			<td>类似于 byType，但该类型适用于构造函数参数类型。</td>\n		</tr>\n		<tr>\n			<td>autodetect</td>\n			<td>首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>1、AOP？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义：面向切面编程，是一种编程范式。提供了与 OOP不同的抽象软件结构的视角。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：低耦合性、源代码无关性</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、AOP 两种动态代理方式？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）JDK动态代理</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：因为有接口，所以使系统更加松耦合</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：为每一个目标类创建接口</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CGLIB动态代理</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、AOP通知类型？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<thead>\n		<tr>\n			<th colspan=\"2\" rowspan=\"1\" scope=\"col\">通知</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>环绕通知</td>\n			<td>around</td>\n			<td>在建议方法调用之前和之后，执行通知。</td>\n		</tr>\n		<tr>\n			<td>前置通知</td>\n			<td>before</td>\n			<td>在一个方法执行之前，执行通知。</td>\n		</tr>\n		<tr>\n			<td>后置通知</td>\n			<td>after</td>\n			<td>在一个方法执行之后，不考虑其结果，执行通知。</td>\n		</tr>\n		<tr>\n			<td>正常返回通知</td>\n			<td>after-returning</td>\n			<td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>\n		</tr>\n		<tr>\n			<td>异常返回通知</td>\n			<td>after-throwing</td>\n			<td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>1、Spring Bean？</strong></p>\n\n<ul>\n	<li>它们是构成用户应用程序主干的对象。</li>\n	<li>Bean 由 Spring IoC 容器管理。</li>\n	<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>\n	<li>Bean 是基于用户提供给容器的配置元数据创建。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Bean的作用域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<thead>\n		<tr>\n			<th scope=\"col\">\n			<p>作用域</p>\n			</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>singleton</td>\n			<td>在spring&nbsp;IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值</td>\n		</tr>\n		<tr>\n			<td>prototype</td>\n			<td>每次从容器中调用Bean时，都返回一个新的实例。</td>\n		</tr>\n		<tr>\n			<td>request</td>\n			<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>session</td>\n			<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>\n		</tr>\n		<tr>\n			<td>global-session</td>\n			<td>一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring常见创建对象的注解？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<tbody>\n		<tr>\n			<td>@Component</td>\n			<td>将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。</td>\n		</tr>\n		<tr>\n			<td>@Controller</td>\n			<td>将一个类标记为 Spring Web MVC 控制器。</td>\n		</tr>\n		<tr>\n			<td>@Service</td>\n			<td>是@Component 注解的特化，它没有提供额外的行为，只是更好指定了意图。</td>\n		</tr>\n		<tr>\n			<td>@Repository</td>\n			<td>是@Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<h2>SpringBoot</h2>\n\n<p><strong>1.1、Spring Boot 是什么？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Spring Boot 是一个用来简化新 Spring 应用的初始搭建以及开发过程的框架。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1.2、Spring Boot 核心功能？</strong></p>\n\n<ul>\n	<li>可独立运行 Spring 项目</li>\n	<li>内嵌 servlet 容器</li>\n	<li>提供 starter 简化 Maven 配置</li>\n	<li>自动配置 Spring</li>\n	<li>准生产的应用监控</li>\n	<li>无代码生成和xml配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>1.3、Spring Boot 优点？</strong></p>\n\n<ul>\n	<li>快速搭建项目</li>\n	<li>对主流框架无配置集成</li>\n	<li>项目可独立运行，不依赖servlet容器</li>\n	<li>提供运行时的应用监控</li>\n	<li>极大提高开发、部署效率</li>\n	<li>与云计算天然集成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>1.4、Spring Boot 自动配置原理？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 spring 程序main方法中，添加@SpringBootApplication或者@EnableAutoConfiguration后，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 框架会自动去 maven 中读取每个 starter 中的 spring.factories 文件。该文件里配置了所有需要被创建的spring bean。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Boot 核心注解？</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</strong> @SpringBootApplication，主要组合以下注解：</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1）@SpringBootConfiguration：Spring Boot 项目的配置注解</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）@EnableAutoConfiguration：启用自动配置</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3）@ComponentScan：默认扫描@SpringBootApplication所在类的同级目录以及它的子目录</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring Boot 常用的starter？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n	<tbody>\n		<tr>\n			<td>spring-boot-starter</td>\n			<td>Spring Boot 核心 starter，包括自动配置、日志、yaml配置文件支持</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-web</td>\n			<td>\n			<p>对web项目开发的支持，包括Tomcat与spring-webmvc</p>\n			</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-test</td>\n			<td>测试工具支持</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-data-redis</td>\n			<td>集成redis缓存</td>\n		</tr>\n		<tr>\n			<td>spring-boot-starter-data-jpa</td>\n			<td>数据库支持</td>\n		</tr>\n		<tr>\n			<td>mybatis-spring-boot-starter</td>\n			<td>第三方的mybatis集成starter</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4.1、Spring Boot 读取配置文件的方式？</strong></p>\n\n<ul>\n	<li>application.properties</li>\n	<li>application.yml</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4.2、Spring Boot 读取配置属性的方式？</strong></p>\n\n<ul>\n	<li>@PropertySource</li>\n	<li>@Value</li>\n	<li>@Environment</li>\n	<li>@ConfigurationProperties</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4.3、Spring Boot 如何兼容老 Spring 项目？</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ImportResource 注解导入老 Spring 项目配置文件。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5.1、如何开启 Spring Boot？</strong></p>\n\n<ul>\n	<li>继承spring-boot-starter-parent项目</li>\n	<li>导入spring-boot-dependencies项目依赖</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5.2、如何运行 Spring Boot 项目？</strong></p>\n\n<ul>\n	<li>打包用命令或者放到容器中运行</li>\n	<li>用 Maven/ Gradle 插件运行</li>\n	<li>执行 main 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、Spring Boot 热启动方式？</strong></p>\n\n<ul>\n	<li>方式一：spring-boot-devtools</li>\n</ul>\n\n<pre><code>&lt;!-- pom.xml --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>方式二：springloaded</li>\n</ul>\n\n<pre><code>&lt;!-- pom.xml --&gt;\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;dependencies&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;\n                    &lt;version&gt;1.2.5.RELEASE&lt;/version&gt;\n                &lt;/dependency&gt;\n            &lt;/dependencies&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n\n&lt;!-- 以命令方式启动 --&gt;\nmvn spring-boot:run </code></pre>\n\n<p>&nbsp;</p>\n\n<h2>微服务架构</h2>\n\n<p><strong>1、微服务架构</strong></p>\n\n<ul>\n	<li>是一种架构风格</li>\n	<li>是一种将单个应用程序作为一套小型服务开发的方法，</li>\n	<li>每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。</li>\n	<li>这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。</li>\n	<li>这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、核心</strong></p>\n\n<ul>\n	<li>将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、特点</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<th scope=\"row\">\n			<p>通过服务实现应用的组件化</p>\n			</th>\n			<td>\n			<p>微服务架构中将组件定义为可被独立替换和升级的软件单元</p>\n\n			<p>在应用架构设计中通过将整体应用切分成可独立部署及升级的微服务方式进行组件化设计。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">围绕业务能力组织服务</th>\n			<td>\n			<p>微服务架构采取以业务能力为出发点组织服务的策略，</p>\n\n			<p>因此微服务团队的组织结构必须是跨功能的（如：既管应用，也管数据库）、强搭配的DevOps开发运维一体化团队。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">产品而非项目模式</th>\n			<td>\n			<p>微服务架构则倡导一个团队应该如开发产品般负责一个“微服务”完整的生命周期，</p>\n\n			<p>倡导“谁开发，谁运营”的开发运维一体化方法。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">智能端点与管道扁平化</th>\n			<td>\n			<p>微服务架构主张将组件间通讯的相关业务逻辑/智能放在组件端点侧而非放在通讯组件中，</p>\n\n			<p>通讯机制或组件应该尽量简单及松耦合。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">“去中心化”治理</th>\n			<td>\n			<p>服务架构鼓励使用合适的工具完成各自的任务，</p>\n\n			<p>每个微服务可以考虑选用最佳工具完成(如不同的编程语言)。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">“去中心化”数据管理</th>\n			<td>\n			<p>微服务架构倡导采用多样性持久化方法，让每个微服务管理其自有数据库，</p>\n\n			<p>并允许不同微服务采用不同的数据持久化技术。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">基础设施自动化</th>\n			<td>\n			<p>云化及自动化部署等技术极大地降低了微服务构建、部署和运维的难度，</p>\n\n			<p>通过应用持续集成和持续交付等方法有助于达到加速推出市场的目的。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">故障处理设计</th>\n			<td>\n			<p>微服务架构所带来的一个后果是必须考虑每个服务的失败容错机制。</p>\n\n			<p>因此，微服务非常重视建立架构及业务相关指标的实时监控和日志机制。</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">演进式的设计</th>\n			<td>微服务应用更注重快速更新，因此系统的设计会随时间不断变化及演进。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<h2>MyBatis</h2>\n\n<p><strong>1、#{}和${}的区别是什么？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#{}是预编译处理，${}是字符串替换。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mybatis在处理${}时，就是把${}替换成变量的值。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、mybatis的一级缓存、二级缓存</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）一级缓存：基于HashMap 的本地缓存，其存储作用域为 Session，默认打开一级缓存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）二级缓存：基于HashMap 的本地缓存，其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开启二级缓存：a、属性类实现Serializable序列化接口；b、其映射文件中配置&lt;cache/&gt;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）缓存数据更新机制：当某一个作用域内进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Mapper 接口的工作原理</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>Mapper&nbsp;接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、使用MyBatis的mapper接口调用时有哪些要求？</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp; &nbsp; 1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同；</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4） Mapper.xml文件中的namespace即是mapper接口的类路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></p>\n\n<p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 第1种： 通过在查询的sql语句中定义字段名的别名</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系</p>\n\n<p>&nbsp;</p>\n\n<p><strong>6、如何获取自动生成的(主)键值?&nbsp;</strong></p>\n\n<pre><code>&lt;insert id=”insertname” usegeneratedkeys=”true” keyproperty=”id”&gt;\n     insert into names (name) values (#{name})\n&lt;/insert&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 因为Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 而Hibernate可以根据对象关系模型直接获取，属于全自动ORM映射工具</p>\n\n<p>&nbsp;</p>\n\n<h2>消息中间件</h2>\n\n<p><strong>1、MQ优点?</strong></p>\n\n<ul>\n	<li>解耦</li>\n	<li>异步</li>\n	<li>削峰。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、MQ缺点？</p>\n\n<ul>\n	<li>系统可用性降低</li>\n	<li>系统复杂度提高</li>\n	<li>一致性问题</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289692097304227840,'2019-06-02 16:03:47','2019-06-02 16:03:47'),(289942982022295552,'<h1>参考资料</h1>','sys','待编辑','<p>参考文档</p>\n\n<p><a href=\"http://www.redis.cn/\" target=\"_blank\">http://www.redis.cn/</a></p>\n',0,289404035772870656,'2019-05-19 04:17:08','2019-05-19 04:17:08'),(290017034195857408,'<h1>简介</h1>','sys','待编辑','<p><strong>1、Zookeeper</strong></p>\n\n<ul>\n	<li>Zookeeper是一个开源的，分布式的，为分布式应用提供协调服务的框架。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、工作机制</strong></p>\n\n<ul>\n	<li>基于观察者模式设计，接受观察者的注册</li>\n	<li>负责存储和管理大家都关心的数据</li>\n	<li>当这些数据发现变化时，将会通知到已注册的观察者。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、特点</strong></p>\n\n<ul>\n	<li>由一个领导者（leader）和多个跟随者（follower）组成集群</li>\n	<li>集群只要有半数以上节点存活，就能正常服务</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>数据一致性</td>\n			<td>每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。</td>\n		</tr>\n		<tr>\n			<td>请求顺序性</td>\n			<td>来自同一个client的更新请求按其发送顺序依次执行。</td>\n		</tr>\n		<tr>\n			<td>原子性</td>\n			<td>一次数据更新要么成功，要么失败。</td>\n		</tr>\n		<tr>\n			<td>实时性</td>\n			<td>在一定时间范围内，client能读到最新数据。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、数据结构</strong></p>\n\n<ul>\n	<li>一颗由节点组成的树，每个节点都可以通过其路径唯一标识。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、应用场景</strong></p>\n\n<ul>\n	<li>统一命名服务</li>\n	<li>统一配置管理</li>\n	<li>统一集群管理</li>\n	<li>服务器节点动态上下线</li>\n	<li>软负载均衡等&nbsp; &nbsp;&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,290016907565625344,'2019-06-19 03:48:12','2019-06-19 03:48:12'),(290064828629676032,'<h1>参考资料</h1>','sys','待编辑','<p><strong>1、官网</strong></p>\n\n<p><a href=\"https://zookeeper.apache.org/\" target=\"_blank\">https://zookeeper.apache.org/</a></p>\n',0,290016802041131008,'2019-05-19 12:21:34','2019-05-19 12:21:34'),(290065654932729856,'<h1>安装</h1>','sys','待编辑','<p><strong>一、单机模式安装</strong></p>\n\n<p><strong>1、准备</strong>&nbsp; &nbsp;&nbsp;</p>\n\n<ul>\n	<li>安装JDK</li>\n	<li>拷贝Zookeeper安装包到Linux系统下</li>\n	<li>解压到指定目录\n	<ul>\n		<li>$ tar -zxvf zookeeper-3.4.10.tar.gz -C /opt/module/<br>\n		&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<p><strong>2、配置修改</strong></p>\n\n<ul>\n	<li>将/opt/module/zookeeper-3.4.10/conf这个路径下的zoo_sample.cfg修改为zoo.cfg；\n	<ul>\n		<li>$ mv zoo_sample.cfg zoo.cfg</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>打开zoo.cfg文件，修改dataDir路径\n	<ul>\n		<li>dataDir=/opt/module/zookeeper-3.4.10/zkData</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>在/opt/module/zookeeper-3.4.10/这个目录上创建zkData文件夹\n	<ul>\n		<li>$ mkdir zkData</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、操作Zookeeper</strong></p>\n\n<ul>\n	<li>查看进程是否启动\n	<ul>\n		<li>$ jps</li>\n	</ul>\n	</li>\n	<li>服务端\n	<ul>\n		<li>$ bin/zkServer.sh start/stop/status</li>\n	</ul>\n	</li>\n	<li>启动客户端\n	<ul>\n		<li>$ bin/zkCli.sh</li>\n	</ul>\n	</li>\n	<li>退出客户端\n	<ul>\n		<li>quit</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、配置参数</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">参数</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>tickTime =2000</td>\n			<td>通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒</td>\n		</tr>\n		<tr>\n			<td>initLimit =10</td>\n			<td>LF初始通信时限，10*2000毫秒</td>\n		</tr>\n		<tr>\n			<td>syncLimit =5</td>\n			<td>LF同步通信时限，5*2000毫秒</td>\n		</tr>\n		<tr>\n			<td>dataDir</td>\n			<td>数据文件目录+数据持久化路径</td>\n		</tr>\n		<tr>\n			<td>clientPort =2181</td>\n			<td>客户端连接端口</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>二、集群模式安装</strong></p>\n\n<p><strong>1、安装规划</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在hadoop102、hadoop103和hadoop104三个节点上部署Zookeeper。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、安装</strong></p>\n\n<ul>\n	<li>解压安装包，并同步到其他节点\n	<ul>\n		<li>$ tar -zxvf zookeeper-3.4.10.tar.gz -C /opt/module/</li>\n		<li>&nbsp;$ xsync zookeeper-3.4.10/</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>配置节点编号\n	<ul>\n		<li>创建 /opt/module/zookeeper-3.4.10/zkData/myid\n		<ul>\n			<li>$ mkdir -p zkData</li>\n			<li>$ touch myid</li>\n		</ul>\n		</li>\n		<li>设置节点id\n		<ul>\n			<li>&nbsp;$ vi myid</li>\n		</ul>\n		</li>\n		<li>将此文件同步到其他节点，并分别设置它们的节点id\n		<ul>\n			<li>$ xsync myid</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>配置zoo.cfg文件\n	<ul>\n		<li>重命名/opt/module/zookeeper-3.4.10/conf这个目录下的zoo_sample.cfg为zoo.cfg\n		<ul>\n			<li>$ mv zoo_sample.cfg zoo.cfg</li>\n		</ul>\n		</li>\n		<li>修改路径配置dataDir\n		<ul>\n			<li>$ vim zoo.cfg</li>\n			<li>修改数据存储路径配置<br>\n			dataDir=/opt/module/zookeeper-3.4.10/zkData<br>\n			增加如下配置<br>\n			#######################cluster##########################<br>\n			server.2=hadoop102:2888:3888<br>\n			server.3=hadoop103:2888:3888<br>\n			server.4=hadoop104:2888:3888</li>\n		</ul>\n		</li>\n		<li>同步zoo.cfg配置文件\n		<ul>\n			<li>&nbsp;$ xsync zoo.cfg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、集群操作</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）分别启动Zookeeper<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop102 zookeeper-3.4.10]$ bin/zkServer.sh start<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop103 zookeeper-3.4.10]$ bin/zkServer.sh start<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop104 zookeeper-3.4.10]$ bin/zkServer.sh start<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）查看状态<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop102 zookeeper-3.4.10]# bin/zkServer.sh status<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop103 zookeeper-3.4.10]# bin/zkServer.sh status<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atguigu@hadoop104 zookeeper-3.4.5]# bin/zkServer.sh status<br>\n<br>\n&nbsp;</p>\n',0,290016907565625344,'2019-06-19 15:17:15','2019-06-19 15:17:15'),(290071272838033408,'<h1>选举机制</h1>','sys','待编辑','<p><strong>1、半数机制</strong></p>\n\n<ul>\n	<li>集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、节点状态</strong></p>\n\n<ul>\n	<li>竞选者状态：LOOKING</li>\n	<li>领导者状态：LEADING</li>\n	<li>跟随者状态：FOLLOWING</li>\n	<li>观察者状态：OBSERVER</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、投票信息</strong></p>\n\n<ul>\n	<li>服务器id：myid</li>\n	<li>事务id：ZXID，每次修改server状态，都会变更事务id，代表所有修改总的次序。</li>\n	<li>逻辑时钟</li>\n	<li>节点状态</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、触发选举时机</strong></p>\n\n<ul>\n	<li>集群首次启动</li>\n	<li>集群在工作时Leader宕机</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、选举过程</strong></p>\n\n<ul>\n	<li>每个Server发出一个投票，并广播投票信息\n	<ul>\n		<li>初始情况下，Server都会自己为leader</li>\n	</ul>\n	</li>\n	<li>接受来自各个服务器的投票，验证投票有效性</li>\n	<li>处理投票\n	<ul>\n		<li>先比较 ZXID，后比较 myid，ZXID权重高于myid</li>\n		<li>将自己的投票与每一个其他服务器投票进行对比</li>\n		<li>如果他人的投票权重低于自己的票，则将他人的投票变更成自己的投票</li>\n	</ul>\n	</li>\n	<li>统计投票\n	<ul>\n		<li>判断是否已经有过半机器接受到相同的投票信息</li>\n	</ul>\n	</li>\n	<li>改变服务器状态\n	<ul>\n		<li>一旦确定了Leader，每个服务器就会更新自己的状态</li>\n		<li>后续服务器启动时，发现已经有Leader了，就直接变为FOLLOWING</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,290071254609588224,'2019-06-19 12:57:44','2019-06-19 12:57:44'),(290071272838033418,'<h1>内部原理</h1>','sys','待编辑','<p>1<strong>、节点类型</strong></p>\n\n<ul>\n	<li>短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自动删除</li>\n	<li>持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、目录节点</strong></p>\n\n<ul>\n	<li>持久化目录节点</li>\n	<li>持久化顺序编号目录节点</li>\n	<li>临时目录节点</li>\n	<li>临时顺序编号目录节点</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、监听器原理</strong></p>\n\n<ul>\n	<li>首先要有一个main()线程</li>\n	<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。</li>\n	<li>通过connect线程将注册的监听事件发送给Zookeeper。</li>\n	<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li>\n	<li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。</li>\n	<li>listener线程内部调用了process（）方法。</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-040.png\" style=\"height:210px; width:900px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、写数据流程</strong></p>\n\n<ul>\n	<li>Client 向 ZooKeeper 的某个 Server 发送一个写请求。</li>\n	<li>如果这个 Server 不是 Leader，则会将写请求转发给 Leader。由 Leader 将写请求广播给各个Server。</li>\n	<li>各个 Server 写成功后，就会通知 Leader。</li>\n	<li>当 Leader 收到半数以上的Server写成功消息，就说明数据写成功。</li>\n	<li>最后，Server 通知 Client 数据写成功。</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-041.png\" style=\"height:376px; width:450px\"></p>\n\n<p>&nbsp;</p>\n',0,290071254609588224,'2019-06-19 13:07:57','2019-06-19 13:07:57'),(290084205865365504,'<h1>操作命令</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>help</td>\n			<td>显示所有操作命令</td>\n		</tr>\n		<tr>\n			<td>ls path</td>\n			<td>查看节点信息</td>\n		</tr>\n		<tr>\n			<td>ls2 path</td>\n			<td>查看节点信息详细情况</td>\n		</tr>\n		<tr>\n			<td>create&nbsp;</td>\n			<td>创建节点，-s含有系列，-e临时节点</td>\n		</tr>\n		<tr>\n			<td>get path</td>\n			<td>获得节点的值</td>\n		</tr>\n		<tr>\n			<td>set</td>\n			<td>设置节点的具体值</td>\n		</tr>\n		<tr>\n			<td>stat</td>\n			<td>查看节点状态</td>\n		</tr>\n		<tr>\n			<td>delete</td>\n			<td>删除节点</td>\n		</tr>\n		<tr>\n			<td>rmr&nbsp;</td>\n			<td>递归删除节点</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,290084054585208832,'2019-06-19 15:23:32','2019-06-19 15:23:32'),(290084220717395968,'<h1>API应用</h1>','sys','待编辑','<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;version&gt;RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n        &lt;version&gt;2.8.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.4.10&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、log4j.properties</strong></p>\n\n<pre><code class=\"language-ini\">log4j.rootLogger=INFO, stdout  \nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender  \nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n  \nlog4j.appender.logfile=org.apache.log4j.FileAppender  \nlog4j.appender.logfile.File=target/spring.log  \nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、客户端操作</strong></p>\n\n<pre><code class=\"language-java\">// 创建ZooKeeper客户端\nprivate static String connectString =\"hadoop102:2181,hadoop103:2181,hadoop104:2181\";\nprivate static int sessionTimeout = 2000;\nprivate ZooKeeper zkClient = null;\n\n@Before\npublic void init() throws Exception {\n    zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {\n        @Override\n        public void process(WatchedEvent event) {\n            // 收到事件通知后的回调函数（用户的业务逻辑）\n            System.out.println(event.getType() + \"--\" + event.getPath());\n            // 再次启动监听\n            try {\n                zkClient.getChildren(\"/\", true);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\n\n// 创建子节点\n@Test\npublic void create() throws Exception {\n    // 参数1：要创建的节点的路径； 参数2：节点数据 ； 参数3：节点权限 ；参数4：节点的类型\n    String nodeCreated = zkClient.create(\"/atguigu\", \n        \"jinlian\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n}\n\n// 获取子节点\n@Test\npublic void getChildren() throws Exception {\n    List&lt;String&gt; children = zkClient.getChildren(\"/\", true);\n    for (String child : children) {\n        System.out.println(child);\n    }\n    // 延时阻塞\n    Thread.sleep(Long.MAX_VALUE);\n}\n\n\n// 判断znode是否存在\n@Test\npublic void exist() throws Exception {\n    Stat stat = zkClient.exists(\"/eclipse\", false);\n    System.out.println(stat == null ? \"not exist\" : \"exist\");\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,290084132502794240,'2019-06-19 15:33:12','2019-06-19 15:33:12'),(290084242733297664,'<h1>提问</h1>','sys','待编辑','<p><strong>1、ZooKeeper的选举机制？</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、ZooKeeper的监听原理？</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群最少需要几台机器？</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）部署方式单机模式、集群模式<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）角色：Leader和Follower<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）集群最少需要机器数：3</p>\n\n<p><br>\n<strong>4、 ZooKeeper的常用命令</strong><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls create get delete set…</p>\n',0,290016802041131008,'2019-06-02 13:02:08','2019-06-02 13:02:08'),(290122913628975104,'<h1>Java 概述</h1>','sys','待编辑','<p><strong>1、Java</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java是一种高级的面向对象的程序设计语言</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、版本</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaSE：&nbsp;Java Platform Standard Edition，标准版，是其他版本的基础，主要用于开发桌面应用程序。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaEE：&nbsp;Java Platform Enterprise Edition，企业版，主要用于开发企业级分布式网络程序。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaME：Java Platform Micro Edition，小型版，主要用于嵌入式系统开发。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、JVM、JDK、JRE</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM：Java Virtual Machine，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Java虚拟机<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK：&nbsp;Java Development Kit，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Java开发工具包<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JRE：&nbsp; Java Runtime Environment，&nbsp; &nbsp; &nbsp;Java运行环境</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、特性</strong></p>\n\n<ul>\n	<li>简单</li>\n	<li>面向对象</li>\n	<li>分布性</li>\n	<li>跨平台</li>\n	<li>解释型</li>\n	<li>安全性</li>\n	<li>健壮性</li>\n	<li>多线程</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-05-19 16:24:47','2019-05-19 16:24:47'),(290122929114345472,'<h1>入门程序</h1>','sys','待编辑','<p><strong>1、入门程序</strong></p>\n\n<pre><code class=\"language-java\">public class HelloWorld {\n    public static void main(String []args) {\n        // 打印 Hello World\n        System.out.println(\"Hello World\");\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、运行入门程序</strong></p>\n\n<ul>\n	<li>将以上代码，保存为文件HelloWorld.java</li>\n	<li>进入cmd 命令窗口，进入目标文件所在的位置</li>\n	<li>编译代码： javac HelloWorld.java</li>\n	<li>运行：java HelloWorld</li>\n</ul>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p><strong>3、基本规则</strong></p>\n\n<ul>\n	<li>大小写敏感</li>\n	<li>程序入口：main方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、标识符</strong></p>\n\n<ul>\n	<li>自定义的一些名称\n	<ul>\n		<li>由字母、数字、美元符（$）、下划线（_）组成</li>\n		<li>不可以数字开头</li>\n		<li>不可以使用关键字</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>命名规则\n	<ul>\n		<li>常量名：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XXX_YYY_ZZZ</li>\n		<li>函数名、变量名：&nbsp; &nbsp;xxxYyyZzz</li>\n		<li>类名、接口名：&nbsp; &nbsp; &nbsp; XxxYyyZzz</li>\n		<li>包名：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xxxyyyzzz</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、关键字&nbsp;</strong> &nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java语言里事先定义的、有特别意义的标识符，即保留字，均为小写。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>6、注释</strong></p>\n\n<pre><code class=\"language-java\">//单行注释	\n\n/*	\n多行注释\n多行注释\n*/\n\n/**\n *文档注释\n *能被javadoc解析\n */</code></pre>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-05-30 05:06:27','2019-05-30 05:06:27'),(290122943815380992,'<h1>数据类型</h1>','sys','待编辑','<p><strong>1、基本数据类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">字节</th>\n			<th scope=\"col\">范围</th>\n			<th scope=\"col\">默认值</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\" rowspan=\"4\">整数型</td>\n			<td>byte</td>\n			<td>1</td>\n			<td>-128 ~ 127</td>\n			<td>0</td>\n		</tr>\n		<tr>\n			<td>short</td>\n			<td>2</td>\n			<td>-32768 ~ 32767</td>\n			<td>0</td>\n		</tr>\n		<tr>\n			<td>int</td>\n			<td>4</td>\n			<td>-2^31 ~ 2^31-1</td>\n			<td>0</td>\n		</tr>\n		<tr>\n			<td>long</td>\n			<td>8</td>\n			<td>-2^63 ~ 2^63-1</td>\n			<td>0L</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"2\">浮点型</td>\n			<td>float</td>\n			<td>4</td>\n			<td>&nbsp;</td>\n			<td>0.0f</td>\n		</tr>\n		<tr>\n			<td>double</td>\n			<td>8</td>\n			<td>&nbsp;</td>\n			<td>0.0d</td>\n		</tr>\n		<tr>\n			<td>布尔型</td>\n			<td>boolean</td>\n			<td>1</td>\n			<td>（备注1字节 = 8二进制位）</td>\n			<td>false</td>\n		</tr>\n		<tr>\n			<td>字符型</td>\n			<td>char</td>\n			<td>2</td>\n			<td>&nbsp;</td>\n			<td>\\u0000</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、引用数据类型</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>Java语言中，除了基本类型其他都为引用类型</p>\n\n<ul>\n	<li>对象，class</li>\n	<li>接口，interface</li>\n	<li>数组，[]</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、类型转换</strong></p>\n\n<ul>\n	<li>不能对boolean类型进行类型转换</li>\n	<li>不能把对象类型转换成不相关类的对象</li>\n	<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换</li>\n	<li>转换过程中可能导致溢出或损失精度</li>\n	<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li>\n</ul>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p><strong>1）自动类型转换&nbsp; &nbsp;</strong></p>\n\n<ul>\n	<li>整型、浮点型、字符型可以混合运算。</li>\n	<li>运算中，不同类型的数据先转化为同一类型，然后进行运算</li>\n	<li>转换从低级到高级\n	<ul>\n		<li>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2）强制类型转换</strong></p>\n\n<ul>\n	<li>条件：转换的数据类型必须是兼容的</li>\n	<li>格式：(type)value</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3）隐藏强制类型转换</strong></p>\n\n<ul>\n	<li>整数的默认类型是 int</li>\n	<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-05-30 05:08:41','2019-05-30 05:08:41'),(290122957232959488,'<h1>常量、变量</h1>','sys','待编辑','<p><strong>1、常量</strong></p>\n\n<ul>\n	<li>常量在程序运行时是不能被修改的。</li>\n</ul>\n\n<pre><code class=\"language-java\">//常量用 final 来修饰\nfinal double PI = 3.1415927;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、变量</strong></p>\n\n<ul>\n	<li>定义：代表内存中的一个存储区域</li>\n	<li>注意：须先声明并初始化，才能使用</li>\n	<li>作用域：从定义位置开始，到变量所在{}结束</li>\n</ul>\n\n<pre><code class=\"language-java\">//变量声明格式\ntype variable [ = value][, variable [= value] ...] ;\n\n//变量类型\npublic class Variable{    \n    static int allClicks=0;    // 静态变量（类变量）\n    String str=\"hello world\";  // 实例变量 \n    public void method(){        \n        int i =0;              // 局部变量   \n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-05-19 19:05:56','2019-05-19 19:05:56'),(290122957232959500,'<h1>修饰符</h1>','sys','待编辑','<p><strong>1、访问修饰符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">修饰符</th>\n			<th scope=\"col\">当前类</th>\n			<th scope=\"col\">同包</th>\n			<th scope=\"col\">子类</th>\n			<th scope=\"col\">其他包</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>public</td>\n			<td>OK</td>\n			<td>OK</td>\n			<td>OK</td>\n			<td>OK</td>\n		</tr>\n		<tr>\n			<td>protected</td>\n			<td>OK</td>\n			<td>OK</td>\n			<td>OK</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>default</td>\n			<td>OK</td>\n			<td>OK</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>private</td>\n			<td>OK</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、非访问修饰符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">修饰符</th>\n			<th scope=\"col\">含义</th>\n			<th scope=\"col\">修饰</th>\n			<th scope=\"col\">备注</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>static</td>\n			<td>静态的</td>\n			<td>类方法、类变量</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>final</td>\n			<td>最终的</td>\n			<td>类、方法、变量</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>abstract</td>\n			<td>抽象的</td>\n			<td>类、方法</td>\n			<td>用来创建抽象类和抽象方法</td>\n		</tr>\n		<tr>\n			<td>synchronized</td>\n			<td>同步的</td>\n			<td>方法、代码块</td>\n			<td>其修饰的方法，同一时间只能被一个线程访问</td>\n		</tr>\n		<tr>\n			<td>volatile</td>\n			<td>易变的</td>\n			<td>成员变量</td>\n			<td>\n			<p>1、线程每次访问该变量，都强制从共享内存中重新读取值</p>\n\n			<p>2、当变量发生改变时，都强制线程将变化值回写到共享内存</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-06-02 21:38:58','2019-06-02 21:38:58'),(290122957232959550,'<h1>操作符</h1>','sys','待编辑','<p><strong>1、操作符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">操作符</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\" rowspan=\"7\">\n			<p style=\"text-align:center\"><span style=\"font-family:宋体\"><span style=\"font-size:16px\">算术</span></span></p>\n\n			<p style=\"text-align:center\"><span style=\"font-family:宋体\"><span style=\"font-size:16px\">运算符</span></span></p>\n			</td>\n			<td style=\"text-align:center\">+</td>\n			<td>加法</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-</td>\n			<td>减法</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">*</td>\n			<td>乘法&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">/</td>\n			<td>除法</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">％</td>\n			<td>取余 - 左操作数除以右操作数的余数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">++</td>\n			<td>自增: 操作数的值增加1</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">--</td>\n			<td>自减: 操作数的值减少1</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb; text-align:center\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"6\">\n			<p style=\"text-align:center\">关系</p>\n\n			<p style=\"text-align:center\">运算符</p>\n			</td>\n			<td style=\"text-align:center\">==</td>\n			<td>是否相等</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">!=</td>\n			<td>是否不相等</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&gt;&nbsp;</td>\n			<td>是否大于</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&lt;&nbsp;</td>\n			<td>是否小于</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&gt;=</td>\n			<td>是否大于或等于</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&lt;=</td>\n			<td>是否小于或等于</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb; text-align:center\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"7\">\n			<p style=\"text-align:center\">位</p>\n\n			<p style=\"text-align:center\">运算符</p>\n			</td>\n			<td style=\"text-align:center\">＆</td>\n			<td>按位与</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">|</td>\n			<td>按位或</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">^</td>\n			<td>按位异或，二进制比较，相同为0，不同为1.</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">〜</td>\n			<td>按位取反</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&lt;&lt;&nbsp;</td>\n			<td>按位左移</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&gt;&gt;&nbsp;</td>\n			<td>按位右移</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&gt;&gt;&gt;&nbsp;</td>\n			<td>按位右移补零</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb; text-align:center\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"3\">\n			<p style=\"text-align:center\">逻辑</p>\n\n			<p style=\"text-align:center\">运算符</p>\n			</td>\n			<td style=\"text-align:center\">&amp;&amp;</td>\n			<td>短路与</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">| |</td>\n			<td>短路或</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">！</td>\n			<td>非</td>\n		</tr>\n		<tr>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb; text-align:center\">&nbsp;</td>\n			<td style=\"background-color:#bbbbbb\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"3\">\n			<p style=\"text-align:center\">赋值</p>\n\n			<p style=\"text-align:center\">运算符</p>\n			</td>\n			<td style=\"text-align:center\">=</td>\n			<td>赋值</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">+=</td>\n			<td>加赋值</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">...</td>\n			<td>其他类似运算符-=、*=、...</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、三元运算符</strong></p>\n\n<pre><code class=\"language-java\">//格式\nvariable x = (expression) ? value if true : value if false\n\n//示例\nint a , b;\na = 10;\nb = (a == 1) ? 20 : 30;        // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、instanceof 运算符</strong></p>\n\n<ul>\n	<li>检查该对象是否是一个特定类型</li>\n</ul>\n\n<pre><code class=\"language-java\">//格式\n( Object reference variable ) instanceof  (class/interface type)\n\n//示例\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<pre><code class=\"language-java\">//在前则先自增(减)\nint a,b=2; \na=++b;		//a=3，b=3。\n\n//在后则后自增(减)\nint a,b=2;\na=b++;		//a=2，b=3。\n\n\n//值互换：不需要第三方变量\n//方式一\nint n=3,m=8;\nn=n+m;\nm=n-m;\nn=n-m;\n\n//方式二\nn=n^m;\nm=n^m;		//(n^m)^m\nn=n^m;		//(n^m)^n</code></pre>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-06-14 02:21:02','2019-06-14 02:21:02'),(290169054701711360,'<h1>流程控制</h1>','sys','待编辑','<p><strong>1、if 语句</strong></p>\n\n<pre><code class=\"language-java\">//格式\nif(布尔表达式){\n    //如果true,执行...\n}else{\n    //如果false,执行...\n}\n\n//示例\nint i = 30;\nif( i &lt; 20 ){\n    System.out.print(\"true\");\n}else{\n    System.out.print(\"false\");\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、for 语句</strong></p>\n\n<pre><code class=\"language-java\">//格式\nfor(初始化; 布尔表达式; 步进) {\n    //循环内容\n}\n\n//增强 for 循环\nfor(变量类型 变量 ：数组或集合){\n    //循环内容\n}\n\n\n//示例\nfor(int i = 0; i &lt; 10; i++) {\n    System.out.println(\"value of i : \" + i );\n}\n\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、while 语句</strong></p>\n\n<pre><code class=\"language-java\">//格式\nwhile( 布尔表达式 ) {\n  //循环内容\n}\n\n//示例\nint i = 10;\nwhile( i &lt; 20 ) {\n    i++;\n    System.out.println(\"value of i : \" + i );\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、do...while 语句</strong></p>\n\n<pre><code class=\"language-java\">//格式\ndo {\n    //循环内容\n}while(布尔表达式);\n\n//示例\nint i = 10;\ndo{\n    i++;\n    System.out.println(\"value of i : \" + i );\n}while( i &lt; 20 );</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、switch 语句</strong></p>\n\n<ul>\n	<li>支持的判断类型\n	<ul>\n		<li>byte、short、int 、char，JDK1.7 增加 String</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>可以有多个 case 语句</li>\n	<li>先执行 case 语句，无匹配才执行 default 语句</li>\n	<li>只有遇到&nbsp;break，才会跳出 switch 语句，否则会继续执行下去</li>\n</ul>\n\n<pre><code class=\"language-java\">//格式\nswitch(expression){\n    case value :\n        //语句\n        break; \n    case value :\n        //语句\n        break; \n    ...\n    default : \n        //语句\n}\n\n//示例\nint i = 5;\nswitch(i){\n    case 0:\n        System.out.println(\"0\");\n    case 1:\n        System.out.println(\"1\");\n    case 2:\n        System.out.println(\"2\");\n    default:\n        System.out.println(\"default\");\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、break、continue 语句</strong></p>\n\n<ul>\n	<li>break：跳出循环体</li>\n	<li>continue ：跳出本次循环，进入下次循环</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-06-16 01:20:43','2019-06-16 01:20:43'),(290169304707395584,'<h1>方法</h1>','sys','待编辑','<p><strong>1、方法的定义</strong></p>\n\n<ul>\n	<li>方法包含于类中</li>\n	<li>方法中不能定义方法</li>\n	<li>若无返回值，用 void 代替</li>\n</ul>\n\n<pre><code class=\"language-java\">//格式\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n//示例\npublic static int age(int birthday){\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、方法调用</strong></p>\n\n<pre><code class=\"language-java\">//格式\n对象名.函数名（实参列表）\n\n//示例\npublic int max(int a,int b){\n    if(a&gt;b){\n        return a;\n    }\n    return b;\n}\npublic static void main(String []args) {\n    int larger = max(30, 40);\n    //...\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、方法重载、&nbsp;方法重写</strong></p>\n\n<ul>\n	<li>重载&nbsp;overload\n	<ul>\n		<li>在一个类里面，方法名字相同，而参数不同</li>\n		<li>每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序）</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>重写 override\n	<ul>\n		<li>是子类对父类方法的实现进行重新编写</li>\n		<li>方法名、参数列表均相同</li>\n		<li>重写方法抛出的异常，需宽于被重写方法</li>\n		<li>构造方法不能被重写</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>区别</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th>区别点</th>\n			<th>重载方法</th>\n			<th>重写方法</th>\n		</tr>\n		<tr>\n			<td>参数列表</td>\n			<td>必须修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>返回类型</td>\n			<td>可以修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>异常</td>\n			<td>可以修改</td>\n			<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>\n		</tr>\n		<tr>\n			<td>访问</td>\n			<td>可以修改</td>\n			<td>一定不能做更严格的限制（可以降低限制）</td>\n		</tr>\n	</thead>\n	<tbody>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、可变参数</strong></p>\n\n<ul>\n	<li>在方法声明中，在指定参数类型后加一个省略号(...)&nbsp;</li>\n</ul>\n\n<pre><code class=\"language-java\">public static void max( double... numbers) {\n    //...\n}\npublic static void main(String []args) {\n    int larger = max(30, 40, 50, 60);\n    //...\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、finalize() 方法</strong></p>\n\n<ul>\n	<li>java.lang.Object类的方法，在 finalize() 方法里，必须指定在对象销毁时候要执行的操作</li>\n</ul>\n\n<pre><code class=\"language-java\">//格式\nprotected void finalize(){\n    // 在这里终结代码\n}\n\n//示例\nprotected void finalize() throws java.lang.Throwable {  \n    super.finalize();  \n    System.out.println(\"Cake Object \" + id + \"is disposed\");  \n}  </code></pre>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-06-14 02:55:47','2019-06-14 02:55:47'),(290312535000641536,'<h1>数组</h1>','sys','待编辑','<p><strong>1、数组</strong></p>\n\n<ul>\n	<li>数组元素类型是相同的</li>\n	<li>数组的大小是确定的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义数组</strong></p>\n\n<pre><code class=\"language-java\">//格式\ndataType[] arrayRefVar;\ndataType[] arrayRefVar = new dataType[arraySize];\ndataType[] arrayRefVar = {value0, value1, ..., valuek};\n\n\n//示例\nint[] myArr1;\nint[] myArr2 = new int[2];\nint[] myArr3 = {1, 2, 3}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、数组操作</strong></p>\n\n<pre><code class=\"language-java\">int[] myArr={0,1,2,3};\nint a,b;\n\na = myArr[0];       //元素引用\nb = myArr.length;   //数组长度\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、多维数组</strong></p>\n\n<pre><code class=\"language-java\">//格式\ndataType[][] arrayRefVar = new dataType[typeLength1][typeLength2];\ndataType[][] arrayRefVar = {{value0, value1, ..., valuek},{...},...};\n\n//示例\nint[][] myArr1 = new int[2][3];\nint[][] myArr2 = {{1, 2, 3},{4, 5},{6, 7, 8, 9}};</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、java.util.Arrays</strong></p>\n\n<ul>\n	<li>操作数组的静态类。</li>\n	<li>部分方法：</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>int binarySearch(Object[] a, Object key)</td>\n			<td>从数组中，二分查找给定值</td>\n		</tr>\n		<tr>\n			<td>boolean&nbsp;equals(long[] a, long[] a2)</td>\n			<td>比较两数组是否相等</td>\n		</tr>\n		<tr>\n			<td>void fill(int[] a, int val)</td>\n			<td>给数组所有元素赋指定值</td>\n		</tr>\n		<tr>\n			<td>void sort(Object[] a)</td>\n			<td>为数组排序，升序</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、排序</strong></p>\n\n<pre><code class=\"language-java\">//选择排序\npublic static void selectSort (int[] arr) {\n    for (int x=0; x&lt;arr.length-1; x++) {\n        for(int y=x+1; y&lt;arr.length; y++) {\n            if(arr[x]&gt;arr[y]) {    \n                int temp = arr[x];\n                arr[x] = arr[y];\n                arr[y] = temp;\n            }\n        }\n    }\n}\n\n//冒泡排序\npublic static void bubbleSort (int[] arr) {\n    for(int x=0; x&lt;arr.length-1; x++) {\n        for(int y=0; y&lt;arr.length-x-1; y++) {\n            if(arr[y]&lt;arr[y+1]) {\n                int temp = arr[y];\n                arr[y] = arr[y+1];\n                arr[y+1] = temp;\n            }\n        }\n    }\n}\n\n//二分查找\npublic static int halfSearch(int[] arr, int key) {\n    int min, max, mid;\n    min = 0;\n    max = arr.length-1;\n        \n    while(min&lt;=max) {\n        mid = (max+min)&gt;&gt;1;\n        if(key&gt;arr[mid])\n            min = mid + 1;\n        else if(key&lt;arr[mid])\n            max = mid - 1;\n        else\n            return mid;\n    }\n    return -1;\n}\n</code></pre>\n\n<p>&nbsp;</p>\n',0,283963875107172352,'2019-06-02 21:42:37','2019-06-02 21:42:37'),(290330205947326464,'<h1>类和对象</h1>','sys','待编辑','<p><strong>1、类</strong></p>\n\n<ul>\n	<li>类是一个模板，它描述一类对象的状态和行为。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、对象</strong></p>\n\n<ul>\n	<li>对象是类的一个实例，有状态和行为。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、构造方法</strong></p>\n\n<ul>\n	<li>每个类都有构造方法。</li>\n	<li>如果没有显式定义，Java编译器将会为该类提供一个默认构造方法。</li>\n	<li>在创建一个对象的时候，至少要调用一个构造方法。</li>\n	<li>构造方法的名称必须与类同名。</li>\n	<li>一个类可以有多个构造方法。</li>\n</ul>\n\n<pre><code class=\"language-java\">public class Puppy{\n    public Puppy(){\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、创建类、对象</strong></p>\n\n<pre><code class=\"language-java\">//创建类\nclass 类名{\n    //成员变量定义...\n    //方法定义...\n}\n\n//创建对象，调用类构造方法\nclassName myObject = new className();\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、对象操作</strong></p>\n\n<pre><code class=\"language-java\">public class Puppy{\n    private String name;\n    public Puppy(String name){\n        this.name=name;\n    }\n    public String getName(){\n        return this.name;\n    }\n\n    public static void main(String[] args){\n        Puppy myPuppy = new Puppy( \"tommy\" );   //创建对象\n        System.out.println(myPuppy.name);       //访问对象属性\n        System.out.println(myPuppy.getName());  //访问对象方法\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、内部类</strong></p>\n\n<ul>\n	<li>将一个类定义在另一个类的里面，称里面那个类为内部类\n	<ul>\n		<li>内部类的作用就是为了访问外部类中的成员变量（包括私有）</li>\n		<li>必须先有外部类对象才能生成内部类对象</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-java\">//外部类\nclass Out {\n    private int age = 12;     \n    //内部类\n    class In {\n        public void print() {\n            System.out.println(age);\n        }\n    }\n}\n \npublic class Demo {\n    public static void main(String[] args) {\n        //访问方式一\n        Out.In in = new Out().new In();\n        in.print();\n        \n        /*访问方式二\n        Out out = new Out();\n        Out.In in = out.new In();\n        in.print();\n        */\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、枚举类</strong></p>\n\n<ul>\n	<li>是一种特殊形式的Java类</li>\n	<li>每一个枚举值，代表一个实例对象</li>\n	<li><span style=\"font-size:12.0pt\"><span style=\"font-family:宋体\">构造函数必须为私有</span></span></li>\n</ul>\n\n<pre><code class=\"language-java\">//格式\nenum 枚举类名{\n    枚举对象实例1,\n    枚举对象实例2,\n    ...; \n}\n\n//示例\npublic enum Color{\n    RED(\"red\",\"红色\"),GREEN(\"green\",\"绿色\"),BLUE(\"blue\",\"蓝色\");\n\n    private final String key;\n    private final String value;\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522624,'2019-05-23 13:33:40','2019-05-23 13:33:40'),(290330222183477248,'<h1>封装</h1>','sys','待编辑','<p><strong>1、封装</strong></p>\n\n<ul>\n	<li>将属性和行为绑定起来，并隐藏部分实现的细节，对外只提供访问接口。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>降低耦合</li>\n	<li>隐藏细节</li>\n	<li>类内部可自由修改</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<ul>\n	<li>设为私有</li>\n	<li>对外提供公共访问方法</li>\n</ul>\n\n<pre><code class=\"language-java\">public class Person{\n    private String name;\n    public String getName(){\n      return name;\n    }\n​    public void setName(String name){\n      this.name = name;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522624,'2019-05-20 07:18:36','2019-05-20 07:18:36'),(290330237144559616,'<h1>继承</h1>','sys','待编辑','<p><strong>1、继承</strong></p>\n\n<ul>\n	<li>指继承父类的状态和行为，创建子类的过程。</li>\n	<li>不支持多继承。</li>\n</ul>\n\n<p><br>\n<strong>2、特性</strong></p>\n\n<ul>\n	<li>子类拥有父类非 private 的属性、方法</li>\n	<li>子类可以对父类进行扩展</li>\n	<li>子类可以重写父类方法</li>\n	<li>支持单继承、多重继承</li>\n	<li>提高类之间的耦合性</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、格式</strong></p>\n\n<pre><code class=\"language-java\">class 父类 {\n    //...\n}\n \nclass 子类 extends 父类 {\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、extends、implements&nbsp;</strong></p>\n\n<pre><code class=\"language-java\">public class Animal { \n    private String name;   \n    public Animal(String myName) { \n        this.name=myName;\n    } \n    public void eat() {\n        //...\n    }\n}\npublic class Dog  extends  Animal{ \n    //...\n}\n</code></pre>\n\n<pre><code class=\"language-java\">public interface A {\n    public void eat();\n} \npublic interface B {\n    public void sleep();\n} \npublic class C implements A,B {\n    //....\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、super、super</strong></p>\n\n<ul>\n	<li>this：指向自己的引用。\n	<ul>\n		<li>this()：调用自己的构造方法。</li>\n	</ul>\n	</li>\n	<li>super：指向父类的引用。\n	<ul>\n		<li>super()：调用父类的构造方法。</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-java\">class Animal {\n    public void eat() {\n        System.out.println(\"animal : eat\");\n    }\n}\n \nclass Dog extends Animal {\n    public void eat() {\n        System.out.println(\"dog : eat\");\n    }\n    public void eatTest() {\n        this.eat();     // this 调用自己的方法\n        super.eat();    // super 调用父类方法\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,288305142666522624,'2019-05-30 05:17:04','2019-05-30 05:17:04'),(290330250063015936,'<h1>多态</h1>','sys','待编辑','<p><strong>1、多态</strong></p>\n\n<ul>\n	<li>指允许不同子类对象对同一消息作出不同的响应</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、前提条件</strong></p>\n\n<ul>\n	<li>继承</li>\n	<li>重写</li>\n	<li>父类引用指向子类对象</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<pre><code class=\"language-java\">abstract class Animal {\n    public abstract void run();\n}\nclass Cat extends Animal {\n    public void run() {\n        System.out.println(\"猫跑了......\");\n    }\n}\nclass Dog extends Animal {\n    public void run() {\n        System.out.println(\"狗跑了......\");\n    }\n}\nclass Lady {\n    private Animal pet;\n    Lady(Animal pet) {\n        this.pet = pet;\n    }\n    public void myPetRun(){\n        pet.run();\n    }\n}\n\npublic class Test {\n    public static void main(String args[]){\n        Cat c = new Cat();\n        Dog d = new Dog();\n        Lady l1 = new Lady(c);\n        Lady l2 = new Lady(d);\n        l1.myPetRun();\n        l2.myPetRun();\n    }\n}\n\n//测试结果\n猫跑了......\n狗跑了......</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522624,'2019-05-30 05:18:11','2019-05-30 05:18:11'),(290350466004316160,'<h1>抽象</h1>','sys','待编辑','<p><strong>1、抽象</strong></p>\n\n<ul>\n	<li>是将一类对象的共同特征总结出来构造类的过程。</li>\n</ul>\n\n<p><br>\n<strong>2、抽象类</strong></p>\n\n<ul>\n	<li>抽象方法：只有方法声明，没有方法实现</li>\n	<li>抽象类：包含抽象方法的类</li>\n	<li>特征：\n	<ul>\n		<li>抽象类不能实例化。</li>\n		<li>抽象类的非抽象子类必须实现父类抽象方法</li>\n		<li>抽象方法、抽象类必须被abstract修饰</li>\n		<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li>\n		<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法&nbsp;&nbsp;&nbsp;&nbsp;</li>\n	</ul>\n\n	<pre><code class=\"language-java\">//示例\nabstract class Animal{\n    String name;\n    public abstract void run();\n}\nclass Dog extends Animal{\n    public void run(){\n        System.out.println(\"run\");\n    }\n}</code></pre>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、接口</strong></p>\n\n<ul>\n	<li>接口是一种特殊的抽象类，是抽象方法的集合。用 interface 定义。</li>\n	<li>特点\n	<ul>\n		<li>隐式抽象</li>\n		<li>支持多继承</li>\n		<li>没有构造方法</li>\n		<li>接口的方法都是公有的、隐式抽象的</li>\n		<li>接口的成员变量只能是public static final 的。</li>\n	</ul>\n\n	<pre><code class=\"language-java\">//示例\ninterface Animal{\n    public static final int id = 1;\n    public void run();\n    public void eat();\n}\n\n//接口继承接口\ninterface fish extends Animal{\n    //...\n}\n\n//类实现接口\npublic Dog implements Animal{\n    public void run(){\n        //具体实现...\n    }\n    public void eat(){\n        //具体实现...\n    }\n}</code></pre>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,288305142666522624,'2019-05-20 08:06:04','2019-05-20 08:06:04'),(290368252265000600,'<h1>数值</h1>','sys','待编辑','<p><strong>1、java.lang.Number</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 基本数据类型（数值型）都有其对应包装类，它们是抽象类Number的子类</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">基本数据类型</th>\n			<th scope=\"col\">包装类&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>byte</td>\n			<td>Byte</td>\n		</tr>\n		<tr>\n			<td>short</td>\n			<td>Short</td>\n		</tr>\n		<tr>\n			<td>int</td>\n			<td>Integer</td>\n		</tr>\n		<tr>\n			<td>long</td>\n			<td>Long</td>\n		</tr>\n		<tr>\n			<td>float</td>\n			<td>Float</td>\n		</tr>\n		<tr>\n			<td>double</td>\n			<td>Double</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java.lang.Math</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>min()</td>\n			<td>取最小值</td>\n			<td>toDegrees()</td>\n			<td>将参数转化为角度</td>\n		</tr>\n		<tr>\n			<td>max()</td>\n			<td>取最大值</td>\n			<td>toRadians()</td>\n			<td>将角度转换为弧度</td>\n		</tr>\n		<tr>\n			<td>random()</td>\n			<td>取随机值</td>\n			<td>xxxValue()</td>\n			<td>将 Number 对象转换为xxx数据类型的值</td>\n		</tr>\n		<tr>\n			<td>ceil()</td>\n			<td>向上取整</td>\n			<td>compareTo()</td>\n			<td>将number对象与参数比较</td>\n		</tr>\n		<tr>\n			<td>round()</td>\n			<td>四舍五入</td>\n			<td>equals()</td>\n			<td>判断number对象是否与参数相等</td>\n		</tr>\n		<tr>\n			<td>floor()</td>\n			<td>向下取整</td>\n			<td>valueOf()</td>\n			<td>返回一个 Number 对象指定的内置数据类型</td>\n		</tr>\n		<tr>\n			<td>abs()</td>\n			<td>求绝对值</td>\n			<td>toString()</td>\n			<td>以字符串形式返回值</td>\n		</tr>\n		<tr>\n			<td>sqrt()</td>\n			<td>求平方根</td>\n			<td>parseInt()</td>\n			<td>将字符串解析为int类型</td>\n		</tr>\n		<tr>\n			<td>cbrt()</td>\n			<td>求立方根</td>\n			<td>exp()</td>\n			<td>返回自然数底数e的参数次方</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>log()</td>\n			<td>返回参数的自然数底数的对数值</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>pow()</td>\n			<td>返回第一个参数的第二个参数次方</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,288305142666522700,'2019-05-20 17:43:21','2019-05-20 16:37:27'),(290368252265000960,'<h1>字符串</h1>','sys','待编辑','<p><strong>1、转义字符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<th>转义字符</th>\n			<th>描述</th>\n			<th>转义字符</th>\n			<th>描述</th>\n		</tr>\n		<tr>\n			<td>\\\'</td>\n			<td>单引号</td>\n			<td>\\t</td>\n			<td>tab键</td>\n		</tr>\n		<tr>\n			<td>\\\"</td>\n			<td>双引号</td>\n			<td>\\r</td>\n			<td>回车键</td>\n		</tr>\n		<tr>\n			<td>\\\\</td>\n			<td>反斜杠</td>\n			<td>\\b</td>\n			<td>后退键</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>\\n</td>\n			<td>换行符</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>\\f</td>\n			<td>换页符</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java.lang.Character</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>isLetter()</td>\n			<td>是否是一个字母</td>\n			<td>isUpperCase()</td>\n			<td>是否是大写字母</td>\n		</tr>\n		<tr>\n			<td>isDigit()</td>\n			<td>是否是一个数字字符</td>\n			<td>isLowerCase()</td>\n			<td>是否是小写字母</td>\n		</tr>\n		<tr>\n			<td>isWhitespace()</td>\n			<td>是否是一个空白字符</td>\n			<td>toUpperCase()</td>\n			<td>指定字母的大写形式</td>\n		</tr>\n		<tr>\n			<td>toString()</td>\n			<td>返回字符的字符串形式</td>\n			<td>toLowerCase()</td>\n			<td>指定字母的小写形式</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、JVM 创建 String 对象的机制</strong></p>\n\n<pre><code class=\"language-java\">/**\n * 在运行时常量池（JVM 方法区），查找是否存在相同的字面常量\n * 如果存在，则直接将引用指向已存在的字面常量\n * 否则，则在常量池新开辟空间来存储该字面常量，并将引用指向该字面常量。\n */\nString str1=\"Hello World\";\n\n\n/**\n * new关键字，是在堆区来生成对象，创建出的一定是不同的对象\n */\nString str2=new String(\"hello world\");</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Java 编译器对 String 拼接的优化</strong></p>\n\n<ul>\n	<li>情况一：仅包含字面常量</li>\n	<li>情况二：含有另外的 String 对象</li>\n</ul>\n\n<pre><code class=\"language-java\">//情况一：\nString s1 = \"This is only a\" + \"simple\" + \"test\";\n//编译成：\nString s1 = \"This is only a simple test\"; &nbsp;\n\n\n//情况二：\nstr = str0 + \"World\";\n//编译成：\nStringBuilder str = new StringBuilder();\nstr.append(str0);\nstr.append(\"World\");\nstr.toString();</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、String、StringBuffer 区别</strong></p>\n\n<ul>\n	<li>String：是字符串常量，是不可变的对象，每次对 String 的修改，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。</li>\n	<li>StringBuffer：是字符串变量，每次对 StringBuffer 的修改，都是对自身的修改。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、StringBuffer、StringBuilder 区别</strong></p>\n\n<ul>\n	<li>两者的的成员属性、成员方法基本相同，区别是 StringBuffer 类的成员方法前面多了一个关键字：synchronized</li>\n	<li>StringBuffer：线程安全，效率相对更低</li>\n	<li>StringBuilder：线程不安全，效率相对更高</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、面试题</strong></p>\n\n<pre><code class=\"language-java\">//问题1\nString a = \"hello2\";\nString b = \"hello\" + 2;\nSystem.out.println((a == b));\n\n//问题2\nString a = \"hello2\";\nString b = \"hello\";\nString c = b + 2;\nSystem.out.println((a == c));\n\n//问题3\nString a = \"hello2\";\nfinal String b = \"hello\";\nString c = b + 2;\nSystem.out.println((a == c));\n\n//问题4\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello2\";\n        final String b = getHello();\n        String c = b + 2;\n        System.out.println((a == c));\n    }\n     \n    public static String getHello() {\n        return \"hello\";\n    }\n}\n\n\n\n//答案\n问题1：true\n问题2：false\n问题3：true\n问题4：false\n\n//问题5\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello\";\n        String b =  new String(\"hello\");\n        String c =  new String(\"hello\");\n        String d = b.intern();\n         \n        System.out.println(a==b);\n        System.out.println(b==c);\n        System.out.println(b==d);\n        System.out.println(a==d);\n    }\n}\n\n//问题6：下面这段代码语句1 和语句2 的区别是什么？\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = \"I\";\n        //str1 += \"love\"+\"java\";        语句1\n        str1 = str1+\"love\"+\"java\";      //语句2         \n    }\n}\n\n//问题7\nString str = new String(\"abc\")创建了多少个对象？\n\n\n//答案\n问题5：false、false、false、true\n问题6：语句1比语句2的效率要高，语句1中的\"love\"+\"java\"在编译期间会被优化成\"lovejava\"，而语句2中的不会被优化（JDK1.8效率一样）\n问题7：在类加载的过程中，在运行时常量池中创建了一个\"abc\"对象，而在代码执行过程中，有创建了一个String对象\n\n\n/**\n * String.intern()方法：\n * 如果字符常量池中已经包含一个等于此String对象的字符串,则返回常量池中字符串的引用,\n * 否则,将新的字符串放入常量池,并返回新字符串的引用\n */</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522700,'2019-06-02 21:52:06','2019-06-02 21:52:06'),(290368281608351744,'<h1>日期时间</h1>','sys','待编辑','<p><strong>1、时间戳：java.time.Instant&nbsp;</strong></p>\n\n<pre><code class=\"language-java\">Instant now = Instant.now();\nSystem.out.println(now.toString());\n\n//毫秒\nSystem.out.println(now.get(ChronoField.MICRO_OF_SECOND));\n\n// 微秒\nSystem.out.println(now.get(ChronoField.MICRO_OF_SECOND));\n\n// 纳秒\nSystem.out.println(now.get(ChronoField.NANO_OF_SECOND));\n\n// 毫秒转Instant\nLocalDateTime localDateTime = LocalDateTime.ofInstant(now, ZoneId.systemDefault());\n\n// 2018-01-14T11:03:35.002\nSystem.out.println(localDateTime);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、日期：java.time.LocalDate</strong></p>\n\n<pre><code class=\"language-java\">// 获取当前日期(年月日)\nLocalDate localDate = LocalDate.now();\n\n// 根据年月日构建Date\nLocalDate localDate1 = LocalDate.of(2018, 01, 30);\n\n// 字符串转换日期,默认按照yyyy-MM-dd格式，也可以自定义格式\nLocalDate localDate2 = LocalDate.parse(\"2018-01-30\");\n\n// 获取本月第一天\nLocalDate firstDayOfMonth = localDate.with(TemporalAdjusters.firstDayOfMonth());\n\n// 获取本月第二天\nLocalDate secondDayOfMonth = localDate.withDayOfMonth(2);\n\n// 获取本月最后一天\nLocalDate lastDayOfMonth = localDate.with(TemporalAdjusters.lastDayOfMonth());\n\n// 日期加上1天\nLocalDate tomorrowDay = localDate.plusDays(1);\n\n// 日期减去1天\nLocalDate yesterday = localDate.minusDays(1);\n\n// 获取本年第12天\nLocalDate day = localDate.withDayOfYear(12);\n\n// 计算两个日期间的天数\nlong days = localDate.until(localDate1, ChronoUnit.DAYS);\n\n// 计算两个日期间的周数\nlong weeks = localDate.until(localDate1, ChronoUnit.WEEKS);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、时间：java.time.LocalTime</strong></p>\n\n<pre><code class=\"language-java\">// 获取当前时间，包含毫秒数\nLocalTime localTime = LocalTime.now();\n\n// 构建时间\nLocalTime localTime1 = LocalTime.of(12, 15, 30);\n\n// 获取当前时间，不包含毫秒数 \nLocalTime localTime2 = localTime.withNano(0);\n\n// 字符串转为时间，还可以有其他格式，比如12:15, 12:15:23.233\nLocalTime localTime3 = LocalTime.parse(\"12:15:30\");</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、日期时间：java.time.LocalDateTime</strong></p>\n\n<pre><code class=\"language-java\">// 获取当前年月日 时分秒\nLocalDateTime localDateTime = LocalDateTime.now();\n\n// 通过LocalDate和LocalTime构建\nLocalDateTime localDateTime1 = LocalDateTime.of(LocalDate.now(), LocalTime.now());\n\n// 构建年月日 时分秒\nLocalDateTime localDateTime2 = LocalDateTime.of(2018, 01, 29, 19, 23, 13);\n\n// 格式化当前时间\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\");\nSystem.out.println(formatter.format(localDateTime2));</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、java.time.Period</strong></p>\n\n<ul>\n	<li>包含的是两个日期之间的天、月、年数差值</li>\n</ul>\n\n<pre><code class=\"language-java\">LocalDate startDate = LocalDate.now();\nLocalDate endDate = startDate.plusDays(1);\n\nPeriod period = Period.between(startDate, endDate);\nSystem.out.println(\"间隔的天数\" + period.getDays());\nSystem.out.println(\"间隔的月数:\" + period.getMonths());\nSystem.out.println(\"间隔的年数:\" + period.getYears());\n\n// 直接使用日期类中的方法计算日期间隔\nlong days = startDate.until(endDate, ChronoUnit.DAYS);\nSystem.out.println(\"间隔的天数:\" + days);\nlong weeks = startDate.until(endDate, ChronoUnit.WEEKS);\nSystem.out.println(\"间隔的周数:\" + weeks);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、java.time.Duration</strong></p>\n\n<ul>\n	<li>包含是两个日期时间间隔的秒以及纳秒数</li>\n</ul>\n\n<pre><code class=\"language-java\">LocalDateTime start = LocalDateTime.now();\nLocalDateTime end = start.plusDays(1);\nDuration duration = Duration.between(start, end);\nSystem.out.println(\"间隔的秒数:\" + duration.get(ChronoUnit.SECONDS));\nSystem.out.println(\"间隔的纳秒数:\" + duration.get(ChronoUnit.NANOS));</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、java.time.temporal.TemporalAdjusters</strong></p>\n\n<pre><code class=\"language-java\">// 本月第一天\nLocalDate firstDayOfMonth = localDate.with(TemporalAdjusters.firstDayOfMonth());\n\n// 本月最后一天\nLocalDate lastDayOfMonth = localDate.with(TemporalAdjusters.lastDayOfMonth());\n\n// 本年第一天\nLocalDate firstDayOfYear = localDate.with(TemporalAdjusters.firstDayOfYear());\n\n// 下个月第一天\nLocalDate firstDayOfNextMonth = localDate.with(TemporalAdjusters.firstDayOfNextMonth());\n\n// 本年度最后一天\nLocalDate lastDayOfYear = localDate.with(TemporalAdjusters.lastDayOfYear());\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>8、转换</strong></p>\n\n<ul>\n	<li>java.util.Date 与 LocalDate，LocalTime，LocalDateTime</li>\n</ul>\n\n<pre><code class=\"language-java\">Date date = new Date();\nSystem.out.println(\"current date: \" + date);\n \n// Date -&gt; LocalDateTime\nLocalDateTime localDateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\nSystem.out.println(\"localDateTime by Instant: \" + localDateTime);\n \n// Date -&gt; LocalDate\nLocalDate localDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\nSystem.out.println(\"localDate by Instant: \" + localDate);\n\n// Date -&gt; LocalTime\nLocalTime localTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();\nSystem.out.println(\"localTime by Instant: \" + localTime);\n \n//2. Date -&gt; LocalDateTime\nlocalDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());\nSystem.out.println(\"localDateTime by ofInstant: \" + localDateTime);\n\n\n/*****************************************************************************/\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(\"localDateTime: \" + localDateTime);\n \n// LocalDateTime -&gt; Date\nDate date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());\nSystem.out.println(\"LocalDateTime -&gt; current date: \" + date);\n \n// LocalDate -&gt; Date，时间默认都是00\nLocalDate localDate = LocalDate.now();\ndate = Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\nSystem.out.println(\"LocalDate -&gt; current date: \" + date);\n</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>日期与字符串的转换</li>\n</ul>\n\n<pre><code class=\"language-java\">LocalDate localDate = LocalDate.parse(\"2018-09-09\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); \nLocalDateTime localDateTime = LocalDateTime.parse(\"2018-09-10 12:12:12\",\n    DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:ss:mm\"));\n\n\n/*********************************************************/\nString localDate = LocalDate.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"));\nString localDateTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:ss:mm\"));</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522700,'2019-05-20 17:42:09','2019-05-20 17:42:09'),(290513257742888960,'<h1>java.io.File</h1>','sys','待编辑','<p><strong>1、创建</strong></p>\n\n<pre><code class=\"language-java\">String dirname = \"/tmp/user/java/bin\";\nFile d = new File(dirname);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常用方法</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>createNewFile()</td>\n			<td>文件不存在时，创建空文件</td>\n			<td>isDirectory()</td>\n			<td>是否是目录</td>\n		</tr>\n		<tr>\n			<td>delete()</td>\n			<td>删除文件/目录</td>\n			<td>isFile()</td>\n			<td>是否是文件</td>\n		</tr>\n		<tr>\n			<td>exists()</td>\n			<td>文件/目录是否存在</td>\n			<td>length()</td>\n			<td>文件长度</td>\n		</tr>\n		<tr>\n			<td>getAbsolutePath()</td>\n			<td>获取 File 绝对路径</td>\n			<td>mkdir()</td>\n			<td>创建目录</td>\n		</tr>\n		<tr>\n			<td>getName()</td>\n			<td>获取 File 的名称</td>\n			<td>mkdirs()</td>\n			<td>创建目录（包括父目录）</td>\n		</tr>\n		<tr>\n			<td>getPath()</td>\n			<td>获取 File 的路径</td>\n			<td>renameTo()</td>\n			<td>重新命名 File</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,288305142666522700,'2019-05-20 18:25:39','2019-05-20 18:24:29'),(290513314667982848,'<h1>I/O 体系</h1>','sys','待编辑','<p><strong>1、I/O 体系</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-012.png\" style=\"height:777px; width:700px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、I/O 体系基类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>&nbsp;</td>\n			<td>字节流</td>\n			<td>字符流</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>输入流</td>\n			<td>InputStream</td>\n			<td>Reader</td>\n			<td colspan=\"1\" rowspan=\"2\">判断输入输出：<br>\n			以程序自身为参照物</td>\n		</tr>\n		<tr>\n			<td>输出流</td>\n			<td>OutputStream</td>\n			<td>Writer</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、I/O 体系分类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">分类</th>\n			<th scope=\"col\" style=\"text-align:right\">InputStream</th>\n			<th scope=\"col\" style=\"text-align:right\">OutputStream</th>\n			<th scope=\"col\" style=\"text-align:center\">分类</th>\n			<th scope=\"col\" style=\"text-align:right\">Reader</th>\n			<th scope=\"col\" style=\"text-align:right\">Writer</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">文件流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">File--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">File--</td>\n			<td colspan=\"1\" rowspan=\"4\" style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">&nbsp;</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">File--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">File--</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">管道流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Piped--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Piped--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Piped--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Piped--</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">缓冲流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Buffered--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Buffered--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Buffered--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Buffered--</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">打印流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">&nbsp;</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Print--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">&nbsp;</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Print--</td>\n		</tr>\n		<tr>\n			<td colspan=\"6\" style=\"background-color:#dddddd; height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">数据流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\"><span style=\"font-size:12.0pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">Data</span></span>--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\"><span style=\"font-size:12.0pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">Data</span></span>--</td>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">字符流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">String--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">String--</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">字节数组</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">ByteArray--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">ByteArray--</td>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">字符数组</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">CharArray--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">CharArray--</td>\n		</tr>\n		<tr>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">对象流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Object--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">Object--</td>\n			<td style=\"height:14.4pt; text-align:center; vertical-align:bottom; white-space:nowrap\">转换流</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">InputStream--</td>\n			<td style=\"height:14.4pt; text-align:right; vertical-align:bottom; white-space:nowrap\">OutputStream--</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、示例</strong></p>\n\n<pre><code class=\"language-java\">public class BufferedStreamTest {\n    public  static void main(String[] args)throws IOException {\n        FileInputStream fis=null;\n        FileOutputStream fos=null;\n        BufferedInputStream bis=null;\n        BufferedOutputStream bos=null;\n        try {\n            //创建字节输入流\n            fis=new FileInputStream(\"E:\\\\Test1.txt\");\n            //创建字节输出流\n            fos=new FileOutputStream(\"E:\\\\Test2.txt\");\n            //创建字节缓存输入流\n            bis=new BufferedInputStream(fis);\n            //创建字节缓存输出流\n            bos=new BufferedOutputStream(fos);\n\n            byte[] b=new byte[1024];\n            int hasRead=0;\n            //循环从缓存流中读取数据\n            while((hasRead=bis.read(b))&gt;0){\n                //向缓存流中写入数据，读取多少写入多少\n                bos.write(b,0,hasRead);\n            }\n        }catch (IOException e){\n            e.printStackTrace();\n        }finally {\n            bis.close();\n            bos.close();\n        }\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,288305142666522800,'2019-06-12 19:04:18','2019-06-12 19:04:18'),(290540066735812608,'<h1>文章1</h1>','sys','待编辑','<p>待编辑</p>\n',0,289700998506508288,'2019-05-30 04:46:33','2019-05-30 04:46:33'),(290540368872501248,'<h1>正则表达式<br></h1>','sys','待编辑','<p>&nbsp;&nbsp; &nbsp;正则表达式<br>\n正则表达式：&nbsp;&nbsp; &nbsp;全称Regular Expressions，&nbsp;&nbsp; &nbsp;用于的字符匹配、查找、替换<br>\n相关类：&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;java.lang.String&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\njava.util.regex.Pattern&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//匹配模式<br>\njava.util.regex.Matcher&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//匹配器</p>\n\n<p>规则：&nbsp;&nbsp; &nbsp;字符：&nbsp;&nbsp; &nbsp;[abc] &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;列举：abc中，任意一个字符<br>\n[^abc] &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;否定：abc外<br>\n[a-z]&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;范围：a到z&nbsp;<br>\n[a-z]│[A-Z] &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;并集：a到f<br>\n[a-z&amp;&amp;[^m-p]] &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;交集：a到z且除了m到p<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\n\\\\ &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;反斜线字符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;任意字符<br>\n\\t &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;制表符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\d&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;数字&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\D&nbsp;&nbsp; &nbsp;非数字<br>\n\\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;换行符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\s&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;空白字符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\S&nbsp;&nbsp; &nbsp;非空白字符<br>\n\\r &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;回车符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\w&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单词字符&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\\W&nbsp;&nbsp; &nbsp;非单词字符<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;数量：&nbsp;&nbsp; &nbsp;? &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0个或1个&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{n}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;n次<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0个或多个&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{n,}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;至少n次<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;+&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1个或多个&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{n,m}&nbsp;&nbsp; &nbsp;n到m 次<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;边界：&nbsp;&nbsp; &nbsp;^&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;行开头&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运算：&nbsp;&nbsp; &nbsp;XY &nbsp;&nbsp; &nbsp;X并Y<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;行结尾 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;X|Y &nbsp;&nbsp; &nbsp;X 或 Y<br>\n\\b &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单词边界&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(X) &nbsp;&nbsp; &nbsp;X，作为组<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\n方式：&nbsp;&nbsp; &nbsp;1、&nbsp;&nbsp; &nbsp;boolean b = \"java\".matches(\"[a-z]{4}\"); &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//String类的方法<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2、&nbsp;&nbsp; &nbsp;boolean b = Pattern.matches(\"[a-z]{4}\", \"java\");&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//Pattern类的方法</p>\n\n<p>3、&nbsp;&nbsp; &nbsp;Pattern p = Pattern.compile(\"[a-z]{4}\");&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//封装模式<br>\n&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Matcher m = p.matcher(\"java\");&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//创建匹配器<br>\nboolean b = m.matches();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//进行匹配<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//效率高且能调用Matcher类的方法</p>\n\n<p>示例：&nbsp;&nbsp; &nbsp;Pattern p = Pattern.compile(\"\\\\d{3,5}\");<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Matcher m = p.matcher(\"123-34345-234-00\");<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.matches();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//整个字符串是否匹配<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\nm.reset();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//重置匹配器<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.find();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//是否有下一个匹配的子串<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.start();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//符合匹配字符串的初始位置<br>\nm.end();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//符合匹配字符串的结束位置<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\nm.lookingAt();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//从字符串开头进行匹配<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>————————————————————————————<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Pattern p = Pattern.compile(\"java\", Pattern.CASE_INSENSITIVE);<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Matcher m = p.matcher(\"java Java JaVa IloveJAVA afasdfasdf\");<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\nint i=0;<br>\nStringBuffer buf = new StringBuffer();<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while(m.find()) {<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i++;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(i%2 == 0) {<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.appendReplacement(buf, \"java\");&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//替换缓冲区中的字符串<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} else {<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.appendReplacement(buf, \"JAVA\");<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m.appendTail(buf);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//添加尾巴<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(buf);<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;————————————————————————————<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Pattern p = Pattern.compile(\"(\\\\d{3,5})([a-z]{2})\");<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String s = \"123aa-34345bb-234cc-00\";<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Matcher m = p.matcher(s);<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while(m.find()) {<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(m.group(1));&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//分组<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\n',0,292547297379512320,'2019-05-26 08:46:06','2019-05-20 19:51:59'),(290540436400795648,'<h1>参考资料</h1>','sys','待编辑','待编辑',0,283963385795473408,'2019-05-26 10:14:24','2019-05-26 10:11:16'),(290540436400795700,'<h1>提问-Java 基础</h1>','sys','待编辑','<p><strong>1、Java 面向对象特性？</strong></p>\n\n<ul>\n	<li>封装：将属性和行为绑定起来，并隐藏部分实现的细节，对外只提供访问接口。</li>\n	<li>继承：指继承父类的状态和行为，创建子类的过程。</li>\n	<li>多态：指允许不同子类对象对同一消息作出不同的响应。</li>\n	<li>抽象：是将一类对象的共同特征总结出来构造类的过程。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常见异常错误？</strong></p>\n\n<ul>\n	<li>java.lang.NullPointerException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 空指针异常</li>\n	<li>java.lang.ClassNotFoundException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 指定的类找不到</li>\n	<li>java.lang.NumberFormatException &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 字符串转换为数字异常</li>\n	<li>java.lang.IndexOutOfBoundsException &nbsp;&nbsp; &nbsp;数组角标越界异常</li>\n	<li>java.lang.NoSuchMethodException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;方法不存在异常</li>\n	<li>java.sql.SQLException&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SQL异常</li>\n</ul>\n\n<ul>\n	<li>java.lang.OutOfMemoryError&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;内存溢出</li>\n	<li>java.lang.StackOverflowError&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;栈内存溢出</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、数据类型转换</strong></p>\n\n<pre><code class=\"language-java\">//语句1\nshort s1 = 1;\ns1 = s1 + 1;\n\n\n//语句2\nshort s1 = 1;\ns1 += 1;\n\n\n\n//答案\n//语句1：s1+1 运算结果是 int 型，需要强制转换类型\n//语句2：可以正确编译\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、自动装箱、拆箱</strong></p>\n\n<pre><code class=\"language-java\">Integer a = new Integer(3);\nInteger b = 3;                  // 将3自动装箱成Integer类型\nint c = 3;\nSystem.out.println(a == b);     // false 两个引用没有引用同一对象\nSystem.out.println(a == c);     // true a自动拆箱成int类型再和c比较\n\n\nInteger f1=100,f2=100,f3=150,f4=150;\nSystem.out.println(f1==f2);\nSystem.out.println(f3==f4);\n\n\n//答案：\ntrue、false\n\n\n/** \n * 从jdk5开始引入了装箱、拆箱机制\n * 在Integer常量池中，Integer只对包装了int值在-128-127这个范围的Integer对象做了共享\n * 关于Integer中的==，源码如下：\n */\npublic static Integer valueOf(int i) {\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、字符串常量、字符串对象</strong></p>\n\n<pre><code class=\"language-java\">String s1 = \"Programming\"; \nString s2 = new String(\"Programming\");\nString s3 = \"Program\";\nString s4 = \"ming\";\nString s5 = \"Program\" + \"ming\";\nString s6 = s3 + s4;\n\nSystem.out.println(s1 == s2); \nSystem.out.println(s1 == s5);\nSystem.out.println(s1 == s6);\n\nSystem.out.println(s1 == s6.intern());\nSystem.out.println(s2 == s2.intern());\n\n\n//答案：\nfalse、true、false\ntrue、false\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、equals() 与 == 的区别？</strong></p>\n\n<ul>\n	<li>==\n	<ul>\n		<li>基本数据类型比较的是值</li>\n		<li>引用类型比较的是地址值</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>equals()\n	<ul>\n		<li>不能比较基本数据类型</li>\n		<li>如果没有重写equals方法，则等同 ==</li>\n		<li>如果已经重写equals方法，则按照自定义方式进行比较</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、&nbsp;volatile、synchronized&nbsp;的区别？</strong></p>\n\n<ul>\n	<li>volatile\n	<ul>\n		<li>仅能修饰变量</li>\n		<li>仅能保证变量的修改可见性，不能保证原子性</li>\n		<li>标记的变量不可被编译器优化</li>\n		<li>不可阻塞线程</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>synchronized\n	<ul>\n		<li>能够修饰变量、方法、类</li>\n		<li>能够保证变量的修改可见性和原子性</li>\n		<li>标记的变量可以被编译器优化</li>\n		<li>能够阻塞线程</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、final、finally、finalize 的区别？</strong></p>\n\n<ul>\n	<li>final： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li>\n	<li>finally：是异常处理语句结构的一部分，表示总是执行。</li>\n	<li>finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>9、sleep()、wait() 的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">sleep()</th>\n			<th scope=\"col\">wait()</th>\n		</tr>\n		<tr>\n			<th scope=\"row\">类</th>\n			<td>java.lang.Thread</td>\n			<td>java.lang.Object</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">效果</th>\n			<td>\n			<p>让调用线程进入睡眠状态，让出执行机会给其他线程</p>\n\n			<p>不会释放对象锁</p>\n			</td>\n			<td>\n			<p>让调用线程进入到一个和该对象相关的等待池，</p>\n\n			<p>同时释放对象的机锁，使得其他线程能够访问</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">唤醒</th>\n			<td>等到休眠时间结束后，线程自动进入就绪状态</td>\n			<td>通过notify，notifyAll方法来唤醒等待的线程</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>10、方法重载、&nbsp;方法重写</strong></p>\n\n<ul>\n	<li>重载&nbsp;overload\n	<ul>\n		<li>在一个类里面，方法名字相同，而参数不同</li>\n		<li>每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序）</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>重写 override\n	<ul>\n		<li>是子类对父类方法的实现进行重新编写</li>\n		<li>方法名、参数列表均相同</li>\n		<li>重写方法抛出的异常，需宽于被重写方法</li>\n		<li>构造方法不能被重写</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>区别</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th>区别点</th>\n			<th>重载方法</th>\n			<th>重写方法</th>\n		</tr>\n		<tr>\n			<td>参数列表</td>\n			<td>必须修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>返回类型</td>\n			<td>可以修改</td>\n			<td>一定不能修改</td>\n		</tr>\n		<tr>\n			<td>异常</td>\n			<td>可以修改</td>\n			<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>\n		</tr>\n		<tr>\n			<td>访问</td>\n			<td>可以修改</td>\n			<td>一定不能做更严格的限制（可以降低限制）</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n',0,283963385795473408,'2019-06-14 02:57:48','2019-06-14 02:57:48'),(290540908410990592,'<h1>转换流</h1>','sys','待编辑','<p>&nbsp;&nbsp; &nbsp;转换流<br>\nInputStreamReader&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;读取：字节流——&gt;字符流&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//继承自Reader<br>\nOutputStreamWriter&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;写出：字符流——&gt;字节流&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//继承自Writer</p>\n\n<p>构造方法：&nbsp;&nbsp; &nbsp;程序一方均为字符流，参数均为字节流<br>\nInputStreamReader(InputStream in)&nbsp;<br>\nInputStreamReader(InputStream in, Charset cs)<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;OutputStreamWriter(OutputStream out)&nbsp;<br>\nOutputStreamWriter(OutputStream out, Charset cs)</p>\n\n<p>&nbsp;&nbsp; &nbsp;示例：&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FileOutputStream fos = new FileOutputStream(\"d:\\\\char.txt\");<br>\nOutputStreamWriter osw = new OutputStreamWriter(fos)<br>\n&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;osw.write(\"xxxxxxxxx\");<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;osw.close();<br>\n&nbsp;</p>\n',0,288305142666522800,'2019-05-20 19:52:48','2019-05-20 19:52:48'),(290668098427449344,'<h1>概述</h1>','sys','待编辑','<p><strong>1、异常</strong></p>\n\n<ul>\n	<li>就是程序在运行时出现不正常情况</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、异常分类</strong></p>\n\n<ul>\n	<li>错误\n	<ul>\n		<li>脱离程序员控制的问题。</li>\n		<li>无法处理</li>\n		<li>例：OutOfMemoryError</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>运行时异常\n	<ul>\n		<li>运行时异常是可能被程序员避免的异常。</li>\n		<li>不处理也可编译通过</li>\n		<li>例：NullPointerException</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>编译时异常\n	<ul>\n		<li>除了运行时异常，其他的都是编译时异常</li>\n		<li>必须处理，如果不处理，程序就不能编译通过</li>\n		<li>例：IOException\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、异常体系</strong></p>\n\n<ul>\n	<li>Throwable\n	<ul>\n		<li>Error--------------------------错误</li>\n		<li>Exception---------------------异常\n		<ul>\n			<li>RuntimeException----------运行时异常</li>\n			<li>......Exception----------------编译时异常</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,288305142666522900,'2019-06-02 21:54:43','2019-06-02 21:54:43'),(290668114458079232,'<h1>异常处理</h1>','sys','待编辑','<p><strong>1、java.lang.Throwable</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>getMessage()</td>\n			<td>获取异常详细信息</td>\n		</tr>\n		<tr>\n			<td>printStackTrace()</td>\n			<td>打印错误输出流</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、异常处理</strong></p>\n\n<ul>\n	<li>catch 语句\n	<ul>\n		<li>可以有多个</li>\n		<li>若未发生异常，则不会执行</li>\n		<li>若发生异常，异常对象会被传递到&nbsp;catch 参数中</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>finally 语句\n	<ul>\n		<li>不是必须的</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-java\">try{\n    //可能抛出异常的语句\n}catch(异常类 变量){\n    //处理异常的代码\n}finally{\n    //无论是否产生异常\n    //一定会执行的语句\n}\n\n\nfinally 与 return\n    情况一：return 语句在 finally 语句外\n        1、执行 return 后的表达式，将结果进行缓存\n        2、执行 finally 语句。\n        3、执行 return 指令，返回缓存结果\n\n    情况二：return 语句在 finally 语句内\n        1、执行 return(外) 后的表达式，将结果进行缓存\n        2、执行 finally 语句。\n        3、执行 return(内) 后的表达式，将结果进行缓存\n        4、执行 return 指令，返回缓存结果\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、</strong>throw、thorws</p>\n\n<ul>\n	<li>throw&nbsp;\n	<ul>\n		<li>声明异常</li>\n		<li>用在函数内，后面跟异常对象。</li>\n	</ul>\n	</li>\n	<li>thorws\n	<ul>\n		<li>抛出异常</li>\n		<li>用在函数上，后面跟异常类名。</li>\n		<li>可以跟多个，用逗号隔开。</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-java\">public class className{\n    public void methodName() throws NullPointerException{\n        //...\n        throw new NullPointerException(\"新异常\");\n    }\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、自定义异常</strong></p>\n\n<ul>\n	<li>1、继承 Exception 等异常类</li>\n	<li>2、在会产生该异常的方法上，用 throws 进行声明</li>\n	<li>3、在会产生该异常的方法内，用 throw 将异常抛给系统</li>\n</ul>\n\n<pre><code class=\"language-java\">public class MyException extends Exception {\n    MyException(String message) {\n        super(message);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,288305142666522900,'2019-05-21 06:57:00','2019-05-21 06:57:00'),(290709733026721792,'<h1>集合框架</h1>','sys','待编辑','<p><strong>1、特点</strong></p>\n\n<ul>\n	<li>高性能</li>\n	<li>易扩展、高适应性</li>\n	<li>集合之间有高度的互操作性</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、集合体系</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-013.png\" style=\"height:607px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289689056442216448,'2019-06-12 19:05:40','2019-06-12 19:05:40'),(290709749971709952,'<h1>Collection</h1>','sys','待编辑','<p><strong>1、Collection 体系</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-014.png\" style=\"height:639px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、一般规则</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">集合名称形式</th>\n			<th scope=\"col\">底层数据结构</th>\n			<th scope=\"col\">特点</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>Array...</td>\n			<td>数组</td>\n			<td>查询快，增删慢</td>\n		</tr>\n		<tr>\n			<td>Linked...</td>\n			<td>链表</td>\n			<td>查询慢，增删快</td>\n		</tr>\n		<tr>\n			<td>Hash...</td>\n			<td>哈希表</td>\n			<td>效率在数组与链表之间</td>\n		</tr>\n		<tr>\n			<td>Tree...</td>\n			<td>二叉树</td>\n			<td>自然排序和比较器排序</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、List、Set&nbsp;</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">存储的元素</th>\n			<th scope=\"col\">查询效率</th>\n			<th scope=\"col\">插入删除效率</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>List</td>\n			<td>有序、可重复</td>\n			<td>高</td>\n			<td>低</td>\n		</tr>\n		<tr>\n			<td>Set</td>\n			<td>无序、不重复</td>\n			<td>低</td>\n			<td>高</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、ArrayList、Vector</strong></p>\n\n<ul>\n	<li>底层结构都是动态数组</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">是否同步</th>\n			<th scope=\"col\">初始大小</th>\n			<th scope=\"col\">扩容</th>\n		</tr>\n		<tr>\n			<td>ArrayList</td>\n			<td>线程不安全</td>\n			<td>0，（第一次扩容时，默认10）</td>\n			<td>1.5 倍</td>\n		</tr>\n		<tr>\n			<td>Vector</td>\n			<td>线程安全</td>\n			<td>10</td>\n			<td>2 倍</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、LinkedList</strong></p>\n\n<ul>\n	<li>底层结构：带头/尾指针的双向链表</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289689056442216448,'2019-06-12 19:06:10','2019-06-12 19:06:10'),(290709763733221376,'<h1>Map</h1>','sys','待编辑','<p><strong>1、Map 体系</strong></p>\n\n<p><img alt=\"20190613-000000-015.png\" src=\"/furesky/images/201906/20190613-000000-015.png\" style=\"height:362px; width:650px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、遍历 Map&nbsp;</strong></p>\n\n<ul>\n	<li>有3种方式：keySet()、entrySet()、values()</li>\n	<li>每种方式，又分 for遍历、Iterator遍历&nbsp;</li>\n</ul>\n\n<pre><code class=\"language-java\">//11：keySet()的for遍历\nfor(String key : map.keySet()){\n    map.get(key);\n}\n\n//21：entrySet()的for遍历\nfor(Entry&lt;String,String&gt; entry : map.entrySet()){\n    entry.getKey();\n    entry.getValue();\n}\n\n//31：values()的for遍历\nCollection&lt;String&gt; values = map.values();\nfor(String value : values){\n    \n}\n\n/**************************************************************/\n \n//12：keySet()的Iterator遍历\nIterator&lt;String&gt; iterator = map.keySet().iterator();\nwhile(iterator.hasNext()){\n    String key = iterator.next();\n    map.get(key);\n}\n\n//22：entrySet()的Iterator遍历\nEntry&lt;String, String&gt; entry;\nIterator&lt;Entry&lt;String, String&gt;&gt; iterator2 = map.entrySet().iterator();\nwhile(iterator2.hasNext()){\n    entry = iterator2.next();\n    entry.getKey();\n    entry.getValue();\n}\n\n//32：values()的Iterator遍历\nString value;\nIterator&lt;String&gt; iterator3 = map.values().iterator();\nwhile(iterator3.hasNext()){\n    value=iterator3.next();\n}\n\n//效率：11 &lt; 12 &lt; 21 &lt; 22 &lt; 31 &lt;32</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Hashtable</strong></p>\n\n<ul>\n	<li>底层结构：数组+链表</li>\n	<li>键值不能为 null</li>\n	<li>线程安全，整体加锁，效率低</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、HashMap</strong></p>\n\n<ul>\n	<li>底层结构：数组+链表</li>\n	<li>键值可以为 null</li>\n	<li>线程不安全，效率高</li>\n	<li>扩容\n	<ul>\n		<li>整个Map扩容</li>\n		<li>插入元素后检测需不需要扩容，有可能无效扩容</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>JDK8 后，链表长度大于（默认）8时，转为红黑树，提高增删改查的性能</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、ConcurrentHashMap</strong></p>\n\n<ul>\n	<li>底层结构：数组+链表</li>\n	<li>键值不能为 null</li>\n	<li>线程安全，分段加锁，效率中</li>\n	<li>扩容\n	<ul>\n		<li>分段扩容</li>\n		<li>插入元素前检测需不需要扩容，能避免无效扩容</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289689056442216448,'2019-06-20 17:56:34','2019-06-20 17:56:34'),(290845961051074560,'<h1>Queue<br></h1>','sys','待编辑','<p><strong>1、Queue 体系</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-016.png\" style=\"height:482px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、队列</strong></p>\n\n<ul>\n	<li>队列是一种数据结构，它支持FIFO，即先进先出</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、阻塞队列</strong></p>\n\n<ul>\n	<li>当队列为空时，从队列中获取元素的操作，会被阻塞</li>\n	<li>当队列为满时，往队列里添加元素的操作，会被阻塞</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、有界队列、无界队列</strong></p>\n\n<ul>\n	<li>有界队列：有固定大小的队列</li>\n	<li>无界队列：没有设置固定大小的队列</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、队列类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">队列</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>ConcurrentLinkedQueue</td>\n			<td>基于链表的并发队列</td>\n		</tr>\n		<tr>\n			<td>PriorityQueue</td>\n			<td>优先级队列</td>\n		</tr>\n		<tr>\n			<td>ArrayDeque</td>\n			<td>数组双端队列</td>\n		</tr>\n		<tr>\n			<td>LinkedList</td>\n			<td>链表双端队列</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>DelayQueue</td>\n			<td>延期阻塞队列</td>\n		</tr>\n		<tr>\n			<td>SynchronousQueue</td>\n			<td>并发同步阻塞队列</td>\n		</tr>\n		<tr>\n			<td>ArrayBlockingQueue</td>\n			<td>基于数组的阻塞队列</td>\n		</tr>\n		<tr>\n			<td>LinkedBlockingQueue</td>\n			<td>基于链表的阻塞队列</td>\n		</tr>\n		<tr>\n			<td>PriorityBlockingQueue</td>\n			<td>带优先级的阻塞队列</td>\n		</tr>\n		<tr>\n			<td>LinkedBlockingDeque</td>\n			<td>基于链表的双端阻塞队列</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,289689056442216448,'2019-06-12 19:06:49','2019-06-12 19:06:49'),(291384739285069824,'<h1>集合工具</h1>','sys','待编辑','<p><strong>1、集合遍历</strong></p>\n\n<ul>\n	<li>java.util.<strong>Iterator</strong></li>\n	<li>java.util.<strong>ListIterator</strong></li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>boolean hasNext()&nbsp;</td>\n			<td>如果仍有元素可以迭代，则返回 true。</td>\n		</tr>\n		<tr>\n			<td>E next()</td>\n			<td>返回迭代的下一个元素。</td>\n		</tr>\n		<tr>\n			<td>void remove()&nbsp;</td>\n			<td>从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、集合比较</strong></p>\n\n<ul>\n	<li>java.util.<strong>Comparable </strong>内比较器</li>\n	<li>java.util.<strong>Comparator </strong>外比较器</li>\n</ul>\n\n<pre><code class=\"language-java\">//内比较器\nclass Node implements Comparable&lt;Node&gt;{\n    private String name;\n    private int age;\n    public int compareTo(Node other){\n        if(age &gt; other.getAge())\n            return -1;\n        if(age &lt; other.getAge())\n            return 1;\n        return 0;\n    }    \n    //setter、getter...\n}\n\n//外比较器\npublic class Test {\n    public static void main(String[] args){\n        List&lt;Node&gt; list = new ArrayList&lt;Node&gt;();\n        list.add(new Node(\"yguo\",25));\n        //....\n        Collections.sort(list, new Comparator&lt;Node&gt;() {\n            @Override\n            public int compare(Node o1, Node o2) {\n                return o1.getAge()-o2.getAge();\n            }\n        });\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、集合工具类</strong></p>\n\n<ul>\n	<li>java.util.<strong>Collections</strong></li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>addAll()</td>\n			<td>将多个元素，添加到 collection 中</td>\n			<td>max()</td>\n			<td>返回 collection 的最大元素</td>\n		</tr>\n		<tr>\n			<td>copy()</td>\n			<td>复制源 List，到目标 List</td>\n			<td>min()</td>\n			<td>返回 collection 的最小元素</td>\n		</tr>\n		<tr>\n			<td>disjoint()</td>\n			<td>两个 collection 是否有没有相同元素</td>\n			<td>replaceAll()</td>\n			<td>替换 List 中的全部指定元素</td>\n		</tr>\n		<tr>\n			<td>enumeration()</td>\n			<td>返回 collection 的枚举</td>\n			<td>reverse()</td>\n			<td>反转 List 的元素顺序</td>\n		</tr>\n		<tr>\n			<td>fill()</td>\n			<td>用一个元素替换整个 List 的所有元素</td>\n			<td>sort()</td>\n			<td>对 List 进行排序</td>\n		</tr>\n		<tr>\n			<td>list()</td>\n			<td>返回枚举的ArrayList</td>\n			<td>synchronizedList()</td>\n			<td>返回线程安全的List（Set、Map类似）</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>java.util.<strong>Arrays</strong></li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>asList()</td>\n			<td>返回数组的 List</td>\n			<td>equals()</td>\n			<td>比较数组</td>\n		</tr>\n		<tr>\n			<td>binarySearch()</td>\n			<td>二分查找</td>\n			<td>fill()</td>\n			<td>填充数组</td>\n		</tr>\n		<tr>\n			<td>copyOf()</td>\n			<td>复制数组</td>\n			<td>sort()</td>\n			<td>排序</td>\n		</tr>\n		<tr>\n			<td>copyOfRange()</td>\n			<td>复制数组（指定范围）</td>\n			<td>toString()</td>\n			<td>转换为字符串</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n',0,289689056442216448,'2019-05-23 04:29:30','2019-05-23 04:29:30'),(291416703337656320,'<h1>网络基础</h1>','sys','待编辑','<p><strong>1、网络分层</strong></p>\n\n<ul>\n	<li>应用层</li>\n	<li>传输层</li>\n	<li>网络层</li>\n	<li>物理层</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、逻辑端口</strong></p>\n\n<ul>\n	<li>用于标识进程的逻辑地址，是一个数字标识</li>\n	<li>有效端口：0～65535，其中0～1024系统使用或保留端口</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、IP 协议</strong></p>\n\n<ul>\n	<li>网络中的设备提供了独一无二的标识</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Socket</strong></p>\n\n<ul>\n	<li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、TCP、UDP</strong></p>\n\n<ul>\n	<li>TCP\n	<ul>\n		<li>Transmission Control Protocol，传输控制协议</li>\n		<li>需要建立连接，不丢包。</li>\n		<li>效率低，可靠性高</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>UDP\n	<ul>\n		<li>User Data Protocol，用户数据报协议</li>\n		<li>不需建立连接，会丢包</li>\n		<li>效率高，可靠性低</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289689675425017856,'2019-05-30 06:00:17','2019-05-30 06:00:17'),(291416717795422208,'<h1>TCP</h1>','sys','待编辑','<p><strong>1、报文字段</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">字段</th>\n			<th colspan=\"2\" rowspan=\"1\" scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>序号，seq</td>\n			<td colspan=\"2\" rowspan=\"1\">报文序号</td>\n		</tr>\n		<tr>\n			<td>确认号，ask</td>\n			<td colspan=\"2\" rowspan=\"1\">期望的报文序号</td>\n		</tr>\n		<tr>\n			<td>URG</td>\n			<td>紧急</td>\n			<td>当URG=1时，表明报文段有紧急数据，应当尽快传送。</td>\n		</tr>\n		<tr>\n			<td>ACK</td>\n			<td>确认</td>\n			<td>当ACK=1时，上面的确认号才管用。</td>\n		</tr>\n		<tr>\n			<td>PSH</td>\n			<td>&nbsp;</td>\n			<td>当PSH=1时，接收端应当将缓冲区中的数据尽快交付上层。</td>\n		</tr>\n		<tr>\n			<td>RST</td>\n			<td>&nbsp;</td>\n			<td>当RST=1时，表示TCP连接出现严重差错，必须释放连接，再重新建立连接。</td>\n		</tr>\n		<tr>\n			<td>SYN</td>\n			<td>同步</td>\n			<td>当SYN=1时，表示请求建立连接。</td>\n		</tr>\n		<tr>\n			<td>FIN</td>\n			<td>终止</td>\n			<td>当FIN=1时，表示要求释放连接。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-018.png\" style=\"height:397px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、建立连接</strong></p>\n\n<ul>\n	<li>第一次握手：客户端的应用进程主动打开，并向客户端发出请求报文段</li>\n	<li>第二次握手：服务器应用进程被动打开。若同意客户端的请求，则发回确认报文</li>\n	<li>第三次握手：客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。</li>\n</ul>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<ul>\n	<li>A：你听清楚么？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 请求建立连接</li>\n	<li>B：能听清楚，你呢？&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// A发送正常，B接收正常</li>\n	<li>A：也能听清楚。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// B发送正常，A接收正常</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-019.png\" style=\"height:387px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、断开连接</strong></p>\n\n<ul>\n	<li>第一次挥手：数据传输结束以后，客户端的应用进程发出连接释放报文段，并停止发送数据。</li>\n	<li>第二次挥手：服务器端收到连接释放报文段之后，发出确认报文。</li>\n	<li>第三次挥手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放TCP连接</li>\n	<li>第四次挥手：客户端收到连接释放报文段之后，必须发出确认</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>A：我要挂电话了？&nbsp; &nbsp; &nbsp; &nbsp; //请求断开连接</li>\n	<li>B：挂吧。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //B收到请求，同意断开连接</li>\n	<li>B：我也没有话要说了。&nbsp; //B确认断开连接</li>\n	<li>A：挂断电话。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//A收到确认，断开连接</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-020.png\" style=\"height:426px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,289689675425017856,'2019-06-20 18:26:45','2019-06-20 18:26:45'),(291416731821174784,'<h1>Socket 编程</h1>','sys','待编辑','<p><strong>1、java.net.ServerSocket</strong></p>\n\n<ul>\n	<li>服务端Socket</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th colspan=\"3\" scope=\"col\">方法摘要</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:right\">int</td>\n			<td>getLocalPort()</td>\n			<td>返回此套接字在其上侦听的端口</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">Socket</td>\n			<td>accept()</td>\n			<td>侦听并接受到此套接字的连接</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">void</td>\n			<td>setSoTimeout()</td>\n			<td>设置服务器套接字在accept()期间等待客户端的时间的超时值，毫秒</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">void</td>\n			<td>bind()</td>\n			<td>将套接字绑定到指定服务器和端口</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java.net.Socket</strong></p>\n\n<ul>\n	<li>客户端端Socket</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th colspan=\"3\" scope=\"col\">方法摘要</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">void</td>\n			<td>connect()</td>\n			<td>将此套接字连接到服务器</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">InetAddress</td>\n			<td>getInetAddress()</td>\n			<td>返回套接字连接的地址</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">int</td>\n			<td>getPort()&nbsp;</td>\n			<td>返回此套接字连接到的远程端口</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">int</td>\n			<td>getLocalPort()</td>\n			<td>返回此套接字绑定到的本地端口</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">SocketAddress</td>\n			<td>getRemoteSocketAddress()</td>\n			<td>返回远程套接字的地址</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">InputStream</td>\n			<td>getInputStream()</td>\n			<td>返回套接字的输入流，输入流连接到远程套接字的输出流</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">OutputStream</td>\n			<td>getOutputStream()</td>\n			<td>返回套接字的输出流，输出流连接到远程套接字的输入流。</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">void</td>\n			<td>close()</td>\n			<td>关闭套接字</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、java.net.InetAddress</strong></p>\n\n<ul>\n	<li>表示 Internet 协议( IP )地址</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th colspan=\"3\" scope=\"col\">方法摘要</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">static InetAddress</td>\n			<td>getByAddress()</td>\n			<td>根据给定地址，返回InetAddress对象</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">static InetAddress</td>\n			<td>getByName()</td>\n			<td>根据主机名称确定主机的IP地址</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">static InetAddress</td>\n			<td>getLocalHost()</td>\n			<td>返回本地主机</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">String</td>\n			<td>getHostAddress()</td>\n			<td>返回文本表示中的IP地址字符串</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">String</td>\n			<td>getHostName()</td>\n			<td>获取此IP地址的主机名</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:right\">String</td>\n			<td>toString()</td>\n			<td>将此IP地址转换为String</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、TCP</strong></p>\n\n<ul>\n	<li>服务端</li>\n</ul>\n\n<pre><code class=\"language-java\">// 监听指定端口\nServerSocket server = new ServerSocket(6666);\n\n// 接受连接\nSocket socket = server.accept(); \n\n// 获取此Socket的输入流、输出流\nInputStream in = socket.getInputStream(); \nOutputStream out = socket.getOutputStream();\n\n// 流处理\nbyte[] buf = new byte[1024];\nint len = in.read(buf);\nSystem.out.println(new String(buf, 0, len));\nout.write(\"服务端说：你好！\".getBytes(\"UTF-8\"));\n\n// 关闭资源\nsocket.close();\nserver.close();</code></pre>\n\n<ul>\n	<li>客户端</li>\n</ul>\n\n<pre><code class=\"language-java\">// 服务端IP与端口\nSocket socket = new Socket(\"127.0.0.1\",6666);\n\n// 获取socket的输入流、输出流\nInputStream in = socket.getInputStream();\nOutputStream out = socket.getOutputStream();\n\n// 流处理\nout.write(\"客户端说：你好！\".getBytes(\"UTF-8\"));\nbyte[] buf = new byte[1024];\nint len = in.read(buf);\nSystem.out.println(new String(buf,0,len));\n\n//关闭资源\nsocket.close();</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、UDP</strong></p>\n\n<pre><code class=\"language-java\">//发送端\nbyte[] buf = \"Hello\".getBytes();\nDatagramPacket dp = new DatagramPacket(buf, buf.length,       //打包数据，\n        new InetSocketAddress(\"127.0.0.1\", 5678));            //指定接收端IP地址、端口号\nDatagramSocket ds = new DatagramSocket(9999);                 //可指定发送端端口号\nds.send(dp);\nds.close();\n\n\n//接收端\nDatagramSocket ds = new DatagramSocket(5678);                 //监听5678端口\nbyte buf[] = new byte[1024];\nDatagramPacket dp = new DatagramPacket(buf, buf.length);      //定义数据包\nwhile(true) {\n	ds.receive(dp);\n	System.out.println(new String(buf,0,dp.getLength()));\n}\n</code></pre>\n\n<p>&nbsp;</p>\n',0,289689675425017856,'2019-06-18 22:56:51','2019-06-18 22:56:51'),(291445775602184192,'<h1>URL 处理</h1>','sys','待编辑','<p><strong>1、URL 路径</strong></p>\n\n<p>http://www.runoob.com/index.html?language=cn#j2se</p>\n\n<ul>\n	<li>协议：http</li>\n	<li>主机：www.runoob.com</li>\n	<li>端口号：80 ，以上URL实例并未指定端口，因为 HTTP 协议默认的端口号为 80。</li>\n	<li>文件路径：/index.html</li>\n	<li>请求参数：language=cn</li>\n	<li>定位位置：j2se，定位到网页中 id 属性为 j2se 的 HTML 元素位置 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、URL、URI</strong></p>\n\n<ul>\n	<li>URL：具体的统一资源标志符</li>\n	<li>URI：抽象的统一资源标志符。高层次的概念，它包含URL。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、URL 解析</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"3\">示例：URL url = new URL(\"http://192.168.1.254:8080/myweb/demo.html?name=li\");</td>\n		</tr>\n		<tr>\n			<td>getProtocol()</td>\n			<td>获取协议名</td>\n			<td>http</td>\n		</tr>\n		<tr>\n			<td>getHost()</td>\n			<td>获取主机名</td>\n			<td>192.168.1.254</td>\n		</tr>\n		<tr>\n			<td>getPort()</td>\n			<td>获取端口号</td>\n			<td>8080</td>\n		</tr>\n		<tr>\n			<td>getPath()</td>\n			<td>获取路径</td>\n			<td>/myweb/demo.html</td>\n		</tr>\n		<tr>\n			<td>getFile()</td>\n			<td>获取文件名</td>\n			<td>/myweb/demo.html?name=li</td>\n		</tr>\n		<tr>\n			<td>getQuery()</td>\n			<td>获取查询部</td>\n			<td>name=li</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289689675425017856,'2019-05-23 08:10:57','2019-05-23 08:10:57'),(291456122807545856,'<h1>反射</h1>','sys','待编辑','<p><strong>1、反射机制</strong></p>\n\n<ul>\n	<li>动态获取信息以及动态调用对象方法的功能</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优缺点</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。&nbsp;</li>\n		<li>与Java动态编译相结合，可以实现无比强大的功能 。</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>使用反射的性能较低&nbsp;</li>\n		<li>使用反射相对来说不安全&nbsp;</li>\n		<li>破坏了类的封装性，可以通过反射获取这个类的私有方法和属性&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、反射 API</strong></p>\n\n<p><strong>3.1、获取 Class 对象</strong></p>\n\n<pre><code class=\"language-java\">//1、通过类\nPerson p = new Person();\nClass clazz = p.getClass();\n        \n//2、通过实例对象\nClass clazz = Person.class;\n        \n//3、通过类名，最常用\nClass clazz = Class.forName(\"com.test.Person\");</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.2、java.lang.Class</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>getConstructor()</td>\n			<td>获取 Constructor 对象</td>\n			<td>getClassLoader()</td>\n			<td>获取类加载器</td>\n		</tr>\n		<tr>\n			<td>getConstructors()</td>\n			<td>获取所有Constructor 对象</td>\n			<td>getSuperclass()</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getField()</td>\n			<td>获取指定 Field 对象</td>\n			<td>getInterfaces()</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getFields()</td>\n			<td>获取所有 Field 对象</td>\n			<td>getAnnotation()</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getDeclaredField()</td>\n			<td>获取指定&nbsp;Field 对象（包括私有）</td>\n			<td>getAnnotations()</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getDeclaredFields()</td>\n			<td>获取所有 Field 对象（包括私有）</td>\n			<td>...</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getMethod(</td>\n			<td>获取指定 Method 对象</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>getMethods()</td>\n			<td>获取所有&nbsp;Method 对象</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>newInstance()</td>\n			<td>创建Class对象所代表类的实例</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3.3、java.lang.reflect.Constructor</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>getName()</td>\n			<td>获取构造方法名称</td>\n		</tr>\n		<tr>\n			<td>newInstance()</td>\n			<td>创建对象实例</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3.4、java.lang.reflect.Field</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>getName()</td>\n			<td>获取成员变量名称</td>\n		</tr>\n		<tr>\n			<td>get()&nbsp;</td>\n			<td>获取成员变量的值</td>\n		</tr>\n		<tr>\n			<td>set()</td>\n			<td>设置成员变量的值</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3.5、java.lang.reflect.Method</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td>getName()</td>\n			<td>获取方法的名称</td>\n		</tr>\n		<tr>\n			<td>invoke()&nbsp;</td>\n			<td>调用方法</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,289689726427754496,'2019-05-23 13:41:22','2019-05-23 13:41:22'),(291532895889027072,'<h1>泛型</h1>','sys','待编辑','待编辑',0,289689726427754496,'2019-05-23 13:34:29','2019-06-05 22:06:06'),(292312078424633344,'<h1>JVM</h1>','sys','待编辑','<p><strong>1、JRE</strong></p>\n\n<ul>\n	<li>Java Runtime Environment，Java运行环境，即Java平台。所有的Java 程序都要在JRE下才能运行。</li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、JDK</strong></p>\n\n<ul>\n	<li>Java Development Kit，是程序开发者用来编译、调试java程序用的开发工具包。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、JVM</strong></p>\n\n<ul>\n	<li>Java Virtual Machine，Java虚拟机，是JRE的一部分。</li>\n	<li>它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</li>\n	<li>使用 JVM 就是为了实现 Java 的跨平台性。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Java 运行</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-001.png\" style=\"height:379px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、JVM 体系结构</strong></p>\n\n<ul>\n	<li>类加载器、运行时数据区、执行引擎、本地方法接口</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-002.png\" style=\"height:455px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,291585438186893312,'2019-06-12 18:52:26','2019-06-12 18:52:26'),(292312103301050368,'<h1>JVM 内存结构</h1>','sys','待编辑','<p><strong>1、总览</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-003.png\" style=\"height:416px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、方法区</strong></p>\n\n<ul>\n	<li>类信息、常量、静态变量、即时编译后的代码</li>\n	<li>运行时常量池</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、堆内存</strong></p>\n\n<ul>\n	<li>存储对象实例和数组</li>\n	<li>垃圾收集器管理的主要区域</li>\n	<li>内部划分\n	<ul>\n		<li>新生代：伊甸园区、幸存0区、幸存1区</li>\n		<li>老年代</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-004.png\" style=\"height:260px; width:700px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Java 虚拟机栈</strong></p>\n\n<ul>\n	<li>即栈内存，是Java方法执行的内存模型。</li>\n	<li>存储局部变量表、动态链接、操作数栈、方法出口\n	<ul>\n		<li>每个方法被执行时会产生一个<strong>栈帧</strong>，方法的执行过程就是栈帧在JVM中出栈和入栈的过程。</li>\n		<li>生命周期与线程一致</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、本地方法栈</strong></p>\n\n<ul>\n	<li>与虚拟机栈类似，区别：\n	<ul>\n		<li>虚拟机栈：为虚拟机执行&nbsp;Java 方法服务</li>\n		<li>本地方法栈：为虚拟机执行 Native 方法服务</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、程序计数器</strong></p>\n\n<ul>\n	<li>一块小空间，存储当前线程正在执行字节码指令的地址值。</li>\n	<li>Java 虚拟机规范中，唯一没有规定任何 OutOfMemoryError 的区域。</li>\n	<li>值\n	<ul>\n		<li>如果线程正执行的是 Native 方法，则计数器值为&nbsp;Undefined</li>\n		<li>如果线程正执行的是 Java 方法，则计数器值为正在执行的虚拟机字节码指令的地址。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,291585637458276352,'2019-06-20 17:15:02','2019-06-20 17:15:02'),(292312117507158016,'<h1>Java GC</h1>','sys','待编辑','<p><strong>1、垃圾回收机制</strong></p>\n\n<ul>\n	<li>GC，Garbage Collections，释放无用对象所占内存空间的机制。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、作用区域</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-005.png\" style=\"height:309px; width:450px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、意义</strong></p>\n\n<ul>\n	<li>可以有效的防止内存泄露，有效的使用空闲的内存。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、优缺点</strong></p>\n\n<ul>\n	<li>提高编程效率、保护程序的完整性</li>\n	<li>影响程序性能</li>\n</ul>\n',0,291585682601570304,'2019-06-12 18:55:02','2019-06-12 18:55:02'),(292350246171602944,'<h1>概述</h1>','sys','待编辑','<p><strong>1、类加载机制</strong></p>\n\n<ul>\n	<li>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的Class对象。\n	<ul>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,292350110464897024,'2019-06-05 03:09:41','2019-06-05 03:09:41'),(292359718688419840,'<h1>判定算法</h1>','sys','待编辑','<p><strong>1、引用计数法</strong></p>\n\n<ul>\n	<li>即判断对象的引用数量。</li>\n	<li>不能解决对象间循环引用的问题</li>\n	<li>实现方式\n	<ul>\n		<li>给对象添加一个引用计数器，记录引用该对象的次数</li>\n		<li>当有地方引用该对象时，计数器加1。当引用失效时，计数器减1。</li>\n		<li>当计数器值为0时，代表为垃圾对象，就会被gc进行回收。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、可达性分析法</strong></p>\n\n<ul>\n	<li>通过判断对象的引用链是否可达来决定对象是否可以被回收\n	<ul>\n		<li>程序把所有的引用关系看作一张图，</li>\n		<li>通过一系列的名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。</li>\n		<li>当从 GC Roots 到这个对象不可达时，则证明此对象是不可用的。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>可作为&nbsp;GC Roots 的对象\n	<ul>\n		<li>方法区中静态属性、常量引用的对象</li>\n		<li>Java 虚拟机栈、本地方法栈中引用的对象</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,291585682601570304,'2019-05-30 04:57:01','2019-05-30 04:57:01'),(292360818388791296,'<h1>回收算法</h1>','sys','待编辑','<p><strong>1、标记-清除算法</strong>（Mark-Sweep）</p>\n\n<ul>\n	<li>原理：\n	<ul>\n		<li>标记：扫描内存空间，对存活的对象进行标记</li>\n		<li>清除：扫描内存空间，回收未标记的对象。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>缺点\n	<ul>\n		<li>两次扫描，效率低</li>\n		<li>会产生内存碎片</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、复制算法</strong>（Copying）</p>\n\n<ul>\n	<li>原理\n	<ul>\n		<li>从 From 区找到存活的对象，复制到 To 区。</li>\n		<li>From、To区交互身份，进行下一轮垃圾收集。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>优缺点\n	<ul>\n		<li>没有标记清除过程，效率高</li>\n		<li>没有内存碎片，能进行快速内存分配</li>\n		<li>内存利用率较低</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-006.png\" style=\"height:144px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、标记-整理算法</strong>（Mark-Compact）</p>\n\n<ul>\n	<li>原理\n	<ul>\n		<li>标记：扫描内存空间，对存活的对象进行标记</li>\n		<li>压缩：再次扫描，并整理存活的对象</li>\n	</ul>\n	</li>\n	<li>优缺点\n	<ul>\n		<li>没有内存碎片</li>\n		<li>移动对象需要成本</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-007.png\" style=\"height:82px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、分代收集算法</strong></p>\n\n<ul>\n	<li>并不是一个新的算法，而是之前几种算法的结合。现代商用虚拟机基本都采用<strong>分代收集算法</strong>来进行垃圾回收</li>\n	<li>原理\n	<ul>\n		<li>根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。</li>\n		<li>对于大批对象死去、少量对象存活的区域，使用复制算法</li>\n		<li>对于对象存活率高、没有额外空间进行分配担保的区域，采用标记-清除算法或者标记-整理算法。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,291585682601570304,'2019-06-20 17:25:38','2019-06-20 17:25:38'),(292402396964745216,'<h1>垃圾回收器</h1>','sys','待编辑','<p><strong>1、术语</strong></p>\n\n<ul>\n	<li>串行 vs 并行</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-008.png\" style=\"height:162px; margin-left:50px; margin-right:50px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>STW vs 并发</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-009.png\" style=\"height:167px; margin-left:50px; margin-right:50px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、垃圾回收器</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">垃圾回收器</th>\n			<th scope=\"col\">特点</th>\n			<th scope=\"col\">算法</th>\n			<th scope=\"col\">区域</th>\n		</tr>\n		<tr>\n			<td>Serial</td>\n			<td>单线程</td>\n			<td colspan=\"1\" rowspan=\"3\">复制算法</td>\n			<td rowspan=\"3\">新生代</td>\n		</tr>\n		<tr>\n			<td>ParNew</td>\n			<td>多线程</td>\n		</tr>\n		<tr>\n			<td>Parallel Scavenge</td>\n			<td>\n			<p>多线程，可控制的吞吐量</p>\n			</td>\n		</tr>\n		<tr>\n			<td>Serial Old</td>\n			<td>\n			<p>单线程，暂停所有用户线程</p>\n			</td>\n			<td colspan=\"1\" rowspan=\"2\">标记整理算法</td>\n			<td colspan=\"1\" rowspan=\"3\">老年代</td>\n		</tr>\n		<tr>\n			<td>Parallel Old</td>\n			<td>多线程</td>\n		</tr>\n		<tr>\n			<td>CMS</td>\n			<td>多线程，低停顿</td>\n			<td colspan=\"1\">标记清除算法</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、CMS、G1</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">垃圾回收器</th>\n			<th scope=\"col\">CMS</th>\n			<th scope=\"col\">G1</th>\n		</tr>\n		<tr>\n			<td>概念</td>\n			<td>\n			<p>Concurrent Mark Sweep</p>\n\n			<p>一种获取最短停顿时间为目标的回收器</p>\n			</td>\n			<td>是面向服务端应用的垃圾收集器</td>\n		</tr>\n		<tr>\n			<td>特点</td>\n			<td>多线程<br>\n			标记清除算法<br>\n			对CPU资源敏感<br>\n			尽可能小的缩短停顿时间<br>\n			无法处理浮动垃圾<br>\n			产生内存碎片</td>\n			<td>并行与并发<br>\n			分代收集<br>\n			空间整合<br>\n			可预测的停顿</td>\n		</tr>\n		<tr>\n			<td>步骤</td>\n			<td>\n			<p>1、初始标记</p>\n\n			<p>2、并发标记<br>\n			3、重新标记<br>\n			4、并发清除</p>\n			</td>\n			<td>\n			<p>1、初始标记<br>\n			2、并发标记</p>\n\n			<p>3、最终标记</p>\n\n			<p>4、筛选回收</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n',0,291585682601570304,'2019-06-12 18:58:31','2019-06-12 18:58:31'),(292419214836133888,'<h1>jps</h1>','sys','待编辑','<p>待编辑</p>\n',0,292419127003213824,'2019-05-26 00:18:38','2019-05-26 00:18:38'),(292419542927175680,'<h1>jstat</h1>','sys','待编辑','<p>待编辑</p>\n',0,292419127003213824,'2019-05-26 00:20:10','2019-05-26 00:20:10'),(292419565303787520,'<h1>jinfo</h1>','sys','待编辑','<p>待编辑</p>\n',0,292419127003213824,'2019-05-26 00:20:40','2019-05-26 00:20:40'),(292420311650824192,'<h1>jmap</h1>','sys','待编辑','<p>待编辑</p>\n',0,292419127003213824,'2019-05-26 00:21:03','2019-05-26 00:21:03'),(292420442617966592,'<h1>jhat</h1>','sys','待编辑','待编辑',0,292419127003213824,'2019-05-26 00:21:16','2019-06-05 22:06:06'),(292420553746051072,'<h1>jstack</h1>','sys','待编辑','待编辑',0,292419127003213824,'2019-05-26 00:21:43','2019-06-05 22:06:06'),(292420635807608832,'<h1>jconsole</h1>','sys','待编辑','待编辑',0,292419127003213824,'2019-05-26 00:22:02','2019-06-05 22:06:06'),(292420824689700864,'<h1>VisualVM</h1>','sys','待编辑','待编辑',0,292419127003213824,'2019-05-26 00:22:47','2019-06-05 22:06:06'),(292420990557646848,'<h1>MAT</h1>','sys','待编辑','<p>Eclipse Memory Analyzer Tool</p>\n',0,292419127003213824,'2019-05-26 00:23:37','2019-05-26 00:23:37'),(292569779314520064,'<h1>参考资料</h1>','sys','待编辑','待编辑',0,292569194980864000,'2019-05-26 10:14:41','2019-06-05 22:06:06'),(292569822889144320,'<h1>提问</h1>','sys','待编辑','<p><strong>1、HTTP 请求 GET、POST 方式的区别？</strong></p>\n\n<ul>\n	<li>post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</li>\n	<li>post发送的数据更大（get有url长度限制）&nbsp;</li>\n	<li>post能发送更多的数据类型（get只能发送ASCII字符）&nbsp;</li>\n	<li>post比get慢&nbsp;</li>\n	<li>post一般用于修改和写入数据，get一般用于读取数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、cookie、session&nbsp;的区别？</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">cookie</th>\n			<th scope=\"col\">session</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<th scope=\"row\">数据存放位置</th>\n			<td>客户的浏览器</td>\n			<td>服务器</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">安全程度</th>\n			<td>可能会被篡改</td>\n			<td>安全</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">性能方面</th>\n			<td>只影响客户的浏览器</td>\n			<td>占用服务器性能</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">存储数据量</th>\n			<td>客户的浏览器对其有限制</td>\n			<td>不影响</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">存储结构</th>\n			<td>键值对形式的文本</td>\n			<td>哈希表结构</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、forward、redirect 的区别？</strong></p>\n\n<ul>\n	<li>转发是服务器行为，重定向是客户端行为</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">请求转发</th>\n			<th scope=\"col\">请求重定向</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>服务器内部跳转，所有地址栏上的路径不会改变</td>\n			<td>是浏览器再次发送请求，地址栏上的路径会发生改变</td>\n		</tr>\n		<tr>\n			<td>只发送一次请求</td>\n			<td>会发送两次请求</td>\n		</tr>\n		<tr>\n			<td>只能在当前应用内部跳转</td>\n			<td>可以在内部跳转，也可以跳出当前应用</td>\n		</tr>\n		<tr>\n			<td>可以共享reqeust</td>\n			<td>不能可以共享reqeust</td>\n		</tr>\n		<tr>\n			<td>\n			<p>通过reqeust发起</p>\n\n			<p>request.getRequestDispatcher().forward();</p>\n			</td>\n			<td>\n			<p>response发起</p>\n\n			<p>response.sendRedirect();</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,292569194980864000,'2019-07-02 13:42:48','2019-07-02 13:42:48'),(292643513765359616,'<h1>架构风格</h1>','sys','待编辑','<p><strong>1、单体架构</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-032.png\" style=\"height:324px; width:429px\"></p>\n\n<ul>\n	<li>特点\n	<ul>\n		<li>所有的功能集成在一个项目工程中。</li>\n		<li>所有的功能打一个war包部署到服务器。</li>\n		<li>应用与数据库分开部署。</li>\n		<li>通过部署应用集群和数据库集群来提高系统的性能。</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>项目架构简单，前期开发成本低，周期短，小型项目的首选。</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。</li>\n		<li>系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。</li>\n		<li>技术栈受限。\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、垂直架构</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-033.png\" style=\"height:352px; width:649px\"></p>\n\n<ul>\n	<li>特点\n	<ul>\n		<li>以单体结构规模的项目为单位进行垂直划分项目即将一个大项目拆分成一个一个单体结构项目。</li>\n		<li>项目与项目之间的存在数据冗余，耦合性较大，比如上图中三个项目都存在客户信息。</li>\n		<li>项目之间的接口多为数据同步功能，如：数据库之间的数据库，通过网络接口进行数据库同步。</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>项目架构简单，前期开发成本低，周期短，小型项目的首选</li>\n		<li>通过垂直拆分，原来的单体项目不至于无限扩大</li>\n		<li>不同的项目可采用不同的技术</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。</li>\n		<li>系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、SOA （面向服务）架构</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-034.png\" style=\"height:276px; width:479px\"></p>\n\n<ul>\n	<li>特点\n	<ul>\n		<li>基于SOA的架构思想将重复公用的功能抽取为组件，以服务的方式给各各系统提供服务。</li>\n		<li>各各项目（系统）与服务之间采用webservice、rpc等方式进行通信。</li>\n		<li>ESB企业服务总线作为项目与服务之间通信的桥梁。</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>将重复的功能抽取为服务，提高开发效率，提高系统的可重用性、可维护性。</li>\n		<li>可以针对不同服务的特点制定集群及优化方案。</li>\n		<li>采用ESB减少系统中的接口耦合。</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>系统与服务的界限模糊，不利于开发及维护。</li>\n		<li>虽然使用了ESB，但是服务的接口协议不固定，种类繁多，不利于系统维护。</li>\n		<li>抽取的服务的粒度过大，系统与服务之间耦合性高。\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、微服务架构</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-035.png\" style=\"height:356px; width:562px\"></p>\n\n<ul>\n	<li>特点\n	<ul>\n		<li>将系统服务层完全独立出来，并将服务层抽取为一个一个的微服务。</li>\n		<li>微服务遵循单一原则。</li>\n		<li>微服务之间采用RESTful等轻量协议传输。</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>服务拆分粒度更细，有利于资源重复利用，提高开发效率。</li>\n		<li>可以更加精准的制定每个服务的优化方案，提高系统可维护性。</li>\n		<li>微服务架构采用去中心化思想，服务之间采用RESTful等轻量协议通信，相比ESB更轻量。</li>\n		<li>适用于互联网时代，产品迭代周期更短。</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>微服务过多，服务治理成本高，不利于系统维护。</li>\n		<li>分布式系统开发的技术成本高（容错、分布式事务等），对团队挑战大。</li>\n	</ul>\n	</li>\n</ul>\n',0,292643476800958464,'2019-06-12 19:35:56','2019-06-12 19:35:56'),(292676663115673600,'<h1>参考资料</h1>','sys','待编辑','<p><strong>1、官网</strong></p>\n\n<p><a href=\"http://projects.spring.io/spring-cloud/\" target=\"_blank\">http://projects.spring.io/spring-cloud/</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、官网（中文）</strong></p>\n\n<p><a href=\"https://springcloud.cc/\" target=\"_blank\">https://springcloud.cc/</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、中文社区</strong></p>\n\n<p><a href=\"http://springcloud.cn/\" target=\"_blank\">http://springcloud.cn/</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、API</strong></p>\n\n<p><a href=\"http://cloud.spring.io/spring-cloud-static/Dalston.SR1/\">http://cloud.spring.io/spring-cloud-static/Dalston.SR1/</a></p>\n\n<p><a href=\"https://springcloud.cc/spring-cloud-dalston.html\" target=\"_blank\">https://springcloud.cc/spring-cloud-dalston.html</a></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、中文参考资料</strong></p>\n\n<p><a href=\"https://springcloud.cc/spring-cloud-netflix.html\" target=\"_blank\">https://springcloud.cc/spring-cloud-netflix.html</a></p>\n',0,292643413399859200,'2019-05-27 00:42:21','2019-05-27 00:42:21'),(292676702722486272,'<h1>提问</h1>','sys','待编辑','待编辑',0,292643413399859200,'2019-05-26 17:19:33','2019-06-05 22:06:06'),(292758436990316544,'<h1>微服务架构</h1>','sys','待编辑','<p><strong>1、微服务架构</strong></p>\n\n<ul>\n	<li>是一种架构风格</li>\n	<li>是一种将单个应用程序作为一套小型服务开发的方法，</li>\n	<li>每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。</li>\n	<li>这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。</li>\n	<li>这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、核心</strong></p>\n\n<ul>\n	<li>将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、特点</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">\n			<p>通过服务实现应用的组件化</p>\n			</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构中将组件定义为可被独立替换和升级的软件单元</span></p>\n\n			<p><span style=\"font-size:12px\">在应用架构设计中通过将整体应用切分成可独立部署及升级的微服务方式进行组件化设计。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">围绕业务能力组织服务</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构采取以业务能力为出发点组织服务的策略，</span></p>\n\n			<p><span style=\"font-size:12px\">因此微服务团队的组织结构必须是跨功能的（如：既管应用，也管数据库）、强搭配的DevOps开发运维一体化团队。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">产品而非项目模式</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构则倡导一个团队应该如开发产品般负责一个“微服务”完整的生命周期，</span></p>\n\n			<p><span style=\"font-size:12px\">倡导“谁开发，谁运营”的开发运维一体化方法。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">智能端点与管道扁平化</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构主张将组件间通讯的相关业务逻辑/智能放在组件端点侧而非放在通讯组件中，</span></p>\n\n			<p><span style=\"font-size:12px\">通讯机制或组件应该尽量简单及松耦合。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">“去中心化”治理</th>\n			<td>\n			<p><span style=\"font-size:12px\">服务架构鼓励使用合适的工具完成各自的任务，</span></p>\n\n			<p><span style=\"font-size:12px\">每个微服务可以考虑选用最佳工具完成(如不同的编程语言)。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">“去中心化”数据管理</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构倡导采用多样性持久化方法，让每个微服务管理其自有数据库，</span></p>\n\n			<p><span style=\"font-size:12px\">并允许不同微服务采用不同的数据持久化技术。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">基础设施自动化</th>\n			<td>\n			<p><span style=\"font-size:12px\">云化及自动化部署等技术极大地降低了微服务构建、部署和运维的难度，</span></p>\n\n			<p><span style=\"font-size:12px\">通过应用持续集成和持续交付等方法有助于达到加速推出市场的目的。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">故障处理设计</th>\n			<td>\n			<p><span style=\"font-size:12px\">微服务架构所带来的一个后果是必须考虑每个服务的失败容错机制。</span></p>\n\n			<p><span style=\"font-size:12px\">因此，微服务非常重视建立架构及业务相关指标的实时监控和日志机制。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\" style=\"vertical-align:middle\">演进式的设计</th>\n			<td><span style=\"font-size:12px\">微服务应用更注重快速更新，因此系统的设计会随时间不断变化及演进。</span></td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,292643476800958464,'2019-06-02 13:05:19','2019-06-02 13:05:19'),(292771686008123392,'<h1>Spring Cloud</h1>','sys','待编辑','<p><strong>1、Spring Cloud</strong></p>\n\n<ul>\n	<li>分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Spring Cloud 与 Spring Boot</strong></p>\n\n<ul>\n	<li>SpringBoot 专注于快速、方便的开发单个微服务个体</li>\n	<li>SpringCloud 是关注全局的微服务协调治理框架，它将 SpringBoot 开发的一个个单体微服务整合并管理起来。</li>\n	<li>SpringBoot 可以离开 SpringCloud 独立使用开发项目，但是 SpringCloud 离不开 SpringBoot，属于依赖的关系.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Spring Cloud 与 Dubbo</strong></p>\n\n<ul>\n	<li>背景\n	<ul>\n		<li>SpringCloud是Apache旗下的Spring体系下的微服务解决方案</li>\n		<li>Dubbo是阿里系的分布式服务治理框架</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>通信机制\n	<ul>\n		<li>SpringCloud是基于HTTP的REST方式</li>\n		<li>Dubbo是RPC通信</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>技术维度\n	<ul>\n		<li>SpringCloud覆盖了微服务架构下的方方面面</li>\n		<li>Dubbo本身只是实现了服务治理</li>\n		<li>类似品牌机与组装机的区别</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>社区活跃度\n	<ul>\n		<li>SpringCloud优于Dubbo</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>文档质量\n	<ul>\n		<li>Dubbo略优于SpringCloud</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、RPC vs REST</strong></p>\n\n<ul>\n	<li>RPC ：服务提供方与调用方接口依赖方式太强、服务对平台敏感，难以简单复用。</li>\n	<li>REST ：牺牲了服务调用的性能，但避免了RPC带来的问题</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,292643476800958464,'2019-05-28 13:40:18','2019-05-28 13:40:18'),(293086708718530560,'<h1>入门示例</h1>','sys','待编辑','待编辑',0,292643476800958464,'2019-05-27 20:28:46','2019-06-05 22:06:06'),(293086982711439360,'<h1>Eureka 服务注册与发现</h1>','sys','待编辑','<p><strong>1、Eureka</strong></p>\n\n<ul>\n	<li>是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、服务注册与发现</strong></p>\n\n<ul>\n	<li>服务注册与发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了。Eureka功能类似于dubbo的注册中心，比如Zookeeper。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、原理</strong></p>\n\n<ul>\n	<li>Eureka 采用了 C-S 的设计架构。</li>\n	<li>Eureka Server 作为服务注册功能的服务器，是服务注册中心。</li>\n	<li>而系统中的其他微服务，使用 Eureka Client 连接到 Eureka Server并维持心跳连接。</li>\n	<li>这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</li>\n	<li>SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-036.png\" style=\"height:298px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、核心组件</strong></p>\n\n<ul>\n	<li>Eureka Server\n	<ul>\n		<li>提供服务注册服务</li>\n		<li>各个节点启动后，会在 Eureka Server 中进行注册，这样 Eureka Server 中将会存储所有可用服务的节点信息。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Eureka Client\n	<ul>\n		<li>是一个Java客户端，用于简化与 Eureka Server的交互。</li>\n		<li>作为轮询负载均衡器，并提供服务的故障切换支持。</li>\n		<li>在应用启动后，将会向 Eureka Server 周期性发送心跳。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Eureka 角色</strong></p>\n\n<ul>\n	<li>Eureka Server：提供服务注册和发现</li>\n	<li>Service Provider：服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到</li>\n	<li>Service Consumer：服务消费方，从 Eureka 获取注册服务列表，从而能够消费服务</li>\n</ul>\n',0,293086936796393472,'2019-06-12 19:40:14','2019-06-12 19:40:14'),(293086997429252096,'<h1>创建注册中心</h1>','sys','待编辑','<p>以创建&nbsp;microservicecloud-eureka-7001 为例&nbsp;</p>\n\n<p><br>\n<strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!--eureka-server服务端 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">server: \n  port: 7001\n \neureka:\n  instance:\n    hostname: localhost               #eureka服务端的实例名称\n  client:    \n    register-with-eureka: false       #false表示不向注册中心注册自己。    \n    fetch-registry: false             #false表示自己就是注册中心\n    service-url:                      #设置Eureka Server交互地址\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/  </code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableEurekaServer//EurekaServer服务器端启动类,接受其它微服务注册进来\npublic class EurekaServer7001_App{\n    public static void main(String[] args){\n        SpringApplication.run(EurekaServer7001_App.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,293086936796393472,'2019-05-27 22:28:55','2019-05-27 22:28:55'),(293111621722468352,'<h1>注册微服务</h1>','sys','待编辑','<p>以 microservicecloud-provider-dept-8001 为例</p>\n\n<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- 将微服务provider侧注册进eureka --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">eureka:\n  client: #客户端注册进eureka服务列表内\n    service-url: \n      defaultZone: http://localhost:7001/eureka </code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableEurekaClient //本服务启动后会自动注册进eureka服务中\npublic class DeptProvider8001_App{\n    public static void main(String[] args){\n        SpringApplication.run(DeptProvider8001_App.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、注册中心页面，完善微服务显示信息</strong></p>\n\n<ul>\n	<li>自定义微服务名称</li>\n	<li>微服务访问路径，增加IP信息提示</li>\n</ul>\n\n<pre><code class=\"language-ini\">#微服务工程application.yml\neureka:\n  client:\n    service-url: \n      defaultZone: http://localhost:7001/eureka\n  instance:\n    instance-id: microservicecloud-dept8001     #自定义微服务名称\n    prefer-ip-address: true                     #微服务访问路径，增加IP信息提示\n</code></pre>\n\n<ul>\n	<li>微服务info内容详细信息</li>\n</ul>\n\n<pre><code class=\"language-xml\">//1、总的父工程pom.xml\n&lt;build&gt;\n    &lt;finalName&gt;microservicecloud&lt;/finalName&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n            &lt;configuration&gt;\n                 &lt;delimiters&gt;\n                  &lt;delimit&gt;$&lt;/delimit&gt;\n                 &lt;/delimiters&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n\n\n//2、微服务工程pom.xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n\n//3、微服务工程application.yml\ninfo:\n  app.name: atguigu-microservicecloud\n  company.name: www.atguigu.com\n  build.artifactId: $project.artifactId$\n  build.version: $project.version$</code></pre>\n\n<p>&nbsp;</p>\n',0,293086936796393472,'2019-05-27 22:44:06','2019-05-27 22:44:06'),(293125824982183800,'<h1>集群配置</h1>','sys','待编辑','<p>以 microservicecloud-eureka-7002/microservicecloud-eureka-7003 为例</p>\n\n<p><strong>1、新建注册中心</strong></p>\n\n<ul>\n	<li>略</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、修改 hosts 文件</strong></p>\n\n<ul>\n	<li>C:\\Windows\\System32\\drivers\\etc 下的 hosts 文件</li>\n	<li>添加配置\n	<ul>\n		<li>127.0.0.1 &nbsp;eureka7001.com</li>\n		<li>127.0.0.1 &nbsp;eureka7002.com</li>\n		<li>127.0.0.1 &nbsp;eureka7003.com</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、各 eureka 的 yml 配置</strong></p>\n\n<pre><code class=\"language-ini\">server: \n  port: <span class=\"hljs-number\">7001</span>\n \neureka:\n  instance:\n    hostname: localhost               <span class=\"hljs-preprocessor\">#eureka服务端的实例名称</span>\n  client:    \n    <span class=\"hljs-keyword\">register</span>-with-eureka: <span class=\"hljs-keyword\">false</span>       <span class=\"hljs-preprocessor\">#false表示不向注册中心注册自己。    </span>\n    fetch-registry: <span class=\"hljs-keyword\">false</span>             <span class=\"hljs-preprocessor\">#false表示自己就是注册中心</span>\n    service-url:                      <span class=\"hljs-preprocessor\">#设置Eureka Server交互地址</span>\n      <span class=\"hljs-preprocessor\">#7001</span>\n      defaultZone: http:<span class=\"hljs-comment\">//eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span>\n      <span class=\"hljs-preprocessor\">#7002</span>\n      <span class=\"hljs-preprocessor\">#defaultZone: http:<span class=\"hljs-comment\">//eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/</span></span>\n      <span class=\"hljs-preprocessor\">#7003</span>\n      <span class=\"hljs-preprocessor\">#defaultZone: http:<span class=\"hljs-comment\">//eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span>\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、各微服务的 yml 配置</strong></p>\n\n<pre><code class=\"language-ini\"><span class=\"hljs-comment\">#微服务的application.yml</span>\n<span class=\"hljs-symbol\">eureka:</span>\n  <span class=\"hljs-symbol\">client:</span> \n    service-<span class=\"hljs-symbol\">url:</span> \n      <span class=\"hljs-function\">defaultZone: </span><span class=\"hljs-symbol\">http:</span>/<span class=\"hljs-regexp\">/eureka7001.com:7001/eureka</span><span class=\"hljs-regexp\">/,http:/</span><span class=\"hljs-regexp\">/eureka7002.com:7002/eureka</span><span class=\"hljs-regexp\">/,http:/</span><span class=\"hljs-regexp\">/eureka7003.com:7003/eureka</span><span class=\"hljs-regexp\">/</span></code></pre>\n\n<p>&nbsp;</p>\n',0,293086936796393472,'2019-05-28 01:25:17','2019-05-28 01:25:17'),(293125824982183937,'<h1>Eureka 与 Zookeeper</h1>','sys','待编辑','<p><strong>1、CAP</strong></p>\n\n<ul>\n	<li>一致性：<strong>C</strong>onsistency，所有节点在同一时间具有相同的数据。</li>\n	<li>可用性：<strong>A</strong>vailability，保证每个请求不管成功或者失败都有响应。</li>\n	<li>分区容错：<strong>P</strong>artition tolerance，系统中任意信息的丢失或失败不会影响系统的继续运作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、CAP定理</strong></p>\n\n<ul>\n	<li>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Eureka 自我保护模式</strong></p>\n\n<ul>\n	<li>当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。</li>\n	<li>一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。</li>\n	<li>当网络故障恢复后，该 Eureka Server 节点会自动退出自我保护模式。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Zookeeper 保证 CP</strong></p>\n\n<ul>\n	<li>zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余的节点要重新进行leader选举。</li>\n	<li>选举的时间太长，30-120s，选举期间整个zk集群式不可用，这导致注册服务瘫痪。</li>\n	<li>在云部署的环境下，由于网络问题使得zk集群失去master节点是较大概率发生的事情，注册服务长期不可用是不能接受的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Eureka 保证 AP</strong></p>\n\n<ul>\n	<li>Eureka 优先保证高可用性，其各个节点都是平等的。只要有一台Eureka Server在，就能保证注册服务可用，只不过查到的信息可能不是最新的。</li>\n	<li>Eureka 自我保护机制，当15分钟内超过85%的节点都没有正常的心跳时\n	<ul>\n		<li>Eureka不再从注册列表中移除因为长时间没接收到心跳而应该过期的服务。</li>\n		<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步在其他节点上</li>\n		<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点上。</li>\n	</ul>\n	</li>\n</ul>\n',0,293086936796393472,'2019-05-27 23:31:48','2019-05-27 23:31:48'),(293133207724781568,'<h1>Ribbon 负载均衡</h1>','sys','待编辑','<p><strong>1、Ribbon</strong></p>\n\n<ul>\n	<li>SpringCloud Ribbon 是一个基于HTTP和TCP的<strong>客户端负载均衡工具</strong>，它基于Netflix Ribbon实现。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>Ribbon 是Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。</li>\n	<li>Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。</li>\n	<li><a href=\"https://github.com/Netflix/ribbon/wiki/Getting-Started\" target=\"_blank\">官网资料</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、LB</strong></p>\n\n<ul>\n	<li>Load Balance，即负载均衡，是在微服务或分布式集群中经常用的一种应用。</li>\n	<li>就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、LB 分类</strong></p>\n\n<ul>\n	<li>集中式LB：在服务的消费方和提供方之间使用独立的LB设施, 由该设施负责把访问请求通过某种策略转发至服务的提供方</li>\n	<li>进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Ribbon 运行</strong></p>\n\n<ul>\n	<li>1、先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server</li>\n	<li>2、再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-037.png\" style=\"height:322px; width:500px\"></p>\n',0,293133096366010368,'2019-06-12 19:41:13','2019-06-12 19:41:13'),(293158762939576320,'<h1>Ribbon 构建</h1>','sys','待编辑','<h4><strong>一、配置统一对外服务</strong></h4>\n\n<p>以 microservicecloud-consumer-dept-80 为例</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- Ribbon相关 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<ul>\n	<li>Ribbon 本身是一个微服务，需注册到 Eureka</li>\n</ul>\n\n<pre><code class=\"language-ini\">server:\n  port: 80\n \neureka:\n  client:\n    register-with-eureka: false\n    service-url: \n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置类</strong></p>\n\n<pre><code class=\"language-java\">@Configuration\npublic class ConfigBean{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableEurekaClient\npublic class DeptConsumer80_App{\n    public static void main(String[] args){\n        SpringApplication.run(DeptConsumer80_App.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、访问类</strong></p>\n\n<pre><code class=\"language-java\">@RestController\npublic class DeptController_Consumer{\n    //private static final String REST_URL_PREFIX = \"http://localhost:8001\";\n\n    //统一用微服务名访问\n    private static final String REST_URL_PREFIX = \"http://MICROSERVICECLOUD-DEPT\";\n    \n    @Autowired\n    private RestTemplate restTemplate;\n    \n    @RequestMapping(value=\"/consumer/dept/add\")\n    public boolean add(Dept dept){\n        return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\", dept, Boolean.class);\n    }\n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>二、微服务实例配置</strong></h4>\n\n<ul>\n	<li>提供服务的各个微服务，对外暴露<strong>统一</strong>的服务实例名</li>\n</ul>\n\n<pre><code class=\"language-ini\">spring:\n   application:\n    name: microservicecloud-dept</code></pre>\n\n<p>&nbsp;</p>\n',0,293133096366010368,'2019-05-28 02:09:48','2019-05-28 02:09:48'),(293166106033418240,'<h1>LB 策略</h1>','sys','待编辑','<p><strong>1、Ribbon 自带 LB 策略</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">策略类</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>RandomRule</td>\n			<td>随机</td>\n			<td>随机选择 Server</td>\n		</tr>\n		<tr>\n			<td>RoundRobinRule</td>\n			<td>轮询</td>\n			<td>按顺序循环选择 Server</td>\n		</tr>\n		<tr>\n			<td>RetryRule</td>\n			<td>重试</td>\n			<td>在一个配置时问段内当选择 Server 不成功，则一直尝试选择一个可用的 Server</td>\n		</tr>\n		<tr>\n			<td>BestAvailableRule</td>\n			<td>最低并发</td>\n			<td>逐个考察 Server，如果 Server 断路器打开，则忽略，再选择其中并发连接最低的 Server</td>\n		</tr>\n		<tr>\n			<td>AvailabilityFilteringRule</td>\n			<td>可用过滤</td>\n			<td>过滤掉一直连接失败并被标记为 circuit tripped 的 Server，过滤掉那些高并发连接的 Server</td>\n		</tr>\n		<tr>\n			<td>ResponseTimeWeightedRule</td>\n			<td>响应时间加权</td>\n			<td>\n			<p>根据 Server 的响应时间分配权重。响应时间越长，权重越低，被选择到的概率就越低；</p>\n\n			<p>响应时间越短，权重越高，被选择到的概率就越高。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>ZoneAvoidanceRule</td>\n			<td>区域权衡</td>\n			<td>\n			<p>综合判断 Server 所在区域的性能和 Server 的可用性轮询选择 Server，</p>\n\n			<p>并且判定一个 AWS Zone 的运行性能是否可用，剔除不可用的 Zone 中的所有 Server</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、自定义 LB 策略</strong></p>\n\n<pre><code class=\"language-java\">//1、自定义的轮写规则类\n//注意：该类不能和主程序类在同一层目录结构或者在子包下\npublic class MyRule extends AbstractLoadBalancerRule {\n    public Server choose(ILoadBalancer lb, Object key) {\n        //重写该方法\n    }\n\n    @Override\n    public Server choose(Object key) {\n        return choose(getLoadBalancer(), key);\n    }\n\n    @Override\n    public void initWithNiwsConfig(IClientConfig clientConfig) {\n        // TODO Auto-generated method stub\n    }\n}\n\n\n//2、将自定义的轮写规则类，注入到IOC容器\n@Configuration\npublic class MyRuleConfig {\n    @Bean\n    public IRule iRule(){\n        return new MyRule();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,293133096366010368,'2019-05-28 02:08:58','2019-05-28 02:08:58'),(293177579849805824,'<h1>Feign 负载均衡</h1>','sys','待编辑','<p><strong>1、Feign</strong></p>\n\n<ul>\n	<li>Feign是一个<strong>声明式</strong>的Web服务客户端</li>\n	<li>使得编写Web服务客户端变得非常容易，只需要创建一个接口，然后在上面添加注解即可。</li>\n	<li>Feign 集成了 Ribbon</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,293177554998554624,'2019-05-28 02:41:44','2019-05-28 02:41:44'),(293180649321164800,'<h1>Feign 构建</h1>','sys','待编辑','<h4><strong>一、公共子模块修改</strong></h4>\n\n<p>以 microservicecloud-api 为例</p>\n\n<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xhtml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、客户端类</strong></p>\n\n<pre><code class=\"language-java\">@FeignClient(value = \"MICROSERVICECLOUD-DEPT\")\npublic interface DeptClientService{\n    @RequestMapping(value = \"/dept/get/{id}\",method = RequestMethod.GET)\n    public Dept get(@PathVariable(\"id\") long id);\n    \n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、重新编译</strong></p>\n\n<pre><code class=\"language-ini\">mvn clean\nmvn install</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>二、Feign 服务</strong></h4>\n\n<p>以创建 microservicecloud-consumer-dept-feign 为例</p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xhtml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、实现类</strong></p>\n\n<pre><code class=\"language-java\">@RestController\npublic class DeptController_Feign{\n    @Autowired\n    private DeptClientService service = null;\n \n    @RequestMapping(value = \"/consumer/dept/get/{id}\")\n    public Dept get(@PathVariable(\"id\") Long id){\n        return this.service.get(id);\n    }\n \n    //...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableEurekaClient\n@EnableFeignClients(basePackages= {\"com.atguigu.springcloud\"})\n@ComponentScan(\"com.atguigu.springcloud\")\npublic class DeptConsumer80_Feign_App{\n    public static void main(String[] args)    {\n        SpringApplication.run(DeptConsumer80_Feign_App.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,293177554998554624,'2019-05-28 02:58:41','2019-05-28 02:58:41'),(293274618684141568,'<h1>Hystrix 熔断器</h1>','sys','待编辑','<p><strong>1、扇入、扇出</strong></p>\n\n<ul>\n	<li>扇入：表示一个模块被多个模块调用</li>\n	<li>扇出：表示一个模块调用多个模块。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、雪崩效应</strong></p>\n\n<ul>\n	<li>分布式系统环境下，应用程序有众多依赖关系。某些情况下，许多依赖不可避免的会调用失败。</li>\n	<li>如果扇出链路上某个微服务不可用，对其的调用就会占用越来越多的系统资源，进而引起系统崩溃。</li>\n	<li>这种因“服务提供者的不可用”导致“服务调用者不可用”，并将不可用逐渐放大的现象，即“雪崩效应”。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Hystrix</strong></p>\n\n<ul>\n	<li>是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库。</li>\n	<li>能保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</li>\n	<li><a href=\"https://github.com/Netflix/Hystrix/wiki/How-To-Use\" target=\"_blank\">官网资料</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Hystrix 原理</strong></p>\n\n<ul>\n	<li>当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</li>\n</ul>\n',0,293274311803695104,'2019-05-28 09:21:49','2019-05-28 09:21:49'),(293274638359621632,'<h1>服务熔断</h1>','sys','待编辑','<h4><strong>1、服务熔断</strong></h4>\n\n<ul>\n	<li>当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h4><strong>2、示例</strong></h4>\n\n<p>以 microservicecloud-provider-dept-hystrix-8001 为例</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2.1、pom.xml</strong></p>\n\n<div>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>2.2、带熔断的Controller</strong></p>\n\n<pre><code class=\"language-java\">@RestController\npublic class DeptController{\n    @Autowired\n    private DeptService service = null;\n\n    @RequestMapping(value = \"/dept/get/{id}\", method = RequestMethod.GET)\n    //一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法\n    @HystrixCommand(fallbackMethod = \"processHystrix_Get\")\n    public Dept get(@PathVariable(\"id\") Long id){\n        Dept dept = this.service.get(id);        \n        if (null == dept) {\n            throw new RuntimeException(\"该ID：\" + id + \"没有没有对应的信息\");\n        }        \n        return dept;\n    }\n\n    public Dept processHystrix_Get(@PathVariable(\"id\") Long id){\n        return new Dept().setDeptno(id).setDname(\"该ID：\" + id + \"没有没有对应的信息,null--@HystrixCommand\")\n                .setDb_source(\"no this database in MySQL\");\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2.3、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker//对hystrixR熔断机制的支持\npublic class DeptProvider8001_Hystrix_App{\n    public static void main(String[] args){\n        SpringApplication.run(DeptProvider8001_Hystrix_App.class, args);\n    }\n}</code></pre>\n',0,293274311803695104,'2019-05-28 09:55:10','2019-05-28 09:55:10'),(293282988967227392,'<h1>服务降级</h1>','sys','待编辑','<p><strong>1、服务降级</strong></p>\n\n<ul>\n	<li>从整个系统的负荷情况考虑，对某些负荷会比较高的某些功能（业务场景），当其熔断后将不再被调用。</li>\n	<li>此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。达到虽服务水平下降但还可用的目的。</li>\n	<li>服务降级处理是在客户端实现完成的，与服务端没有关系</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、熔断 vs 降级</strong></p>\n\n<ul>\n	<li>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<p><strong>3.1、服务降级处理类，并注册</strong></p>\n\n<p>修改服务接口的提供者项目(microservicecloud-api)</p>\n\n<pre><code class=\"language-java\">//1、服务降级处理类\n@Component//不要忘记添加，不要忘记添加\npublic class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;{\n    @Override\n    public DeptClientService create(Throwable throwable){\n     return new DeptClientService() {\n         @Override\n         public Dept get(long id){\n             return new Dept().setDeptno(id).setDb_source(\"no this database in MySQL\")\n                    .setDname(\"该ID：\"+id+\"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭\")\n         }\n \n         //...\n     };\n    }\n}\n\n//2、注册\n@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class)\npublic interface DeptClientService {\n    @RequestMapping(value = \"/dept/get/{id}\", method = RequestMethod.GET)\n    public Dept get(@PathVariable(\"id\") long id);\n    @RequestMapping(value = \"/dept/list\", method = RequestMethod.GET)\n    public List&lt;Dept&gt; list();\n    @RequestMapping(value = \"/dept/add}\", method = RequestMethod.POST)\n    public boolean add(Dept dept);\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3.2、打开服务降级</strong></p>\n\n<p>统一对外服务(microservicecloud-consumer-dept-feign)</p>\n\n<pre><code class=\"language-ini\">feign:\n  hystrix:\n    enabled: true</code></pre>\n\n<p>&nbsp;</p>\n',0,293274311803695104,'2019-05-28 10:09:53','2019-05-28 10:09:53'),(293293404594270208,'<h1>服务监控</h1>','sys','待编辑','<p><strong>1、Hystrix Dashboard</strong></p>\n\n<ul>\n	<li>对请求的准实时可视化监控</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<p><strong>2.1 创建监控微服务</strong></p>\n\n<p>以 microservicecloud-consumer-hystrix-dashboard 为例</p>\n\n<pre><code class=\"language-java\">//1、pom.xml\n&lt;!--    hystrix和    hystrix-dashboard相关--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;\n&lt;/dependency&gt; \n\n\n//2、application.yml\nserver:\n  port: 9001\n\n\n//3、启动类\n@SpringBootApplication\n@EnableHystrixDashboard\npublic class DeptConsumer_DashBoard_App{\n    public static void main(String[] args){\n        SpringApplication.run(DeptConsumer_DashBoard_App.class,args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2.2、被监控者配置</strong></p>\n\n<p>所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置</p>\n\n<pre><code class=\"language-xml\">//pom.xml\n&lt;!-- actuator监控信息完善 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2.3、查看监控页面</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-038.png\" style=\"height:268px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,293274311803695104,'2019-06-12 19:42:20','2019-06-12 19:42:20'),(293302056776527872,'<h1>Zuul 服务网关</h1>','sys','待编辑','<p><strong>1、Zuul</strong></p>\n\n<ul>\n	<li>路由：将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础</li>\n	<li>过滤：对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础</li>\n	<li><a href=\"https://github.com/Netflix/zuul/wiki/Getting-Started\" target=\"_blank\">官网资料</a></li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293301929030610944,'2019-05-28 10:49:54','2019-05-28 10:49:54'),(293302071943131136,'<h1>Zuul 构建</h1>','sys','待编辑','<p>以 microservicecloud-zuul-gateway-9527 为例</p>\n\n<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">server: \n  port: 9527\n \nspring: \n  application:\n    name: microservicecloud-zuul-gateway\n \neureka: \n  client: \n    service-url: \n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka  \n  instance:\n    instance-id: gateway-9527.com\n    prefer-ip-address: true \n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、hosts修改</strong></p>\n\n<pre><code class=\"language-ini\">127.0.0.1  myzuul.com</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableZuulProxy\npublic class Zuul_9527_StartSpringCloudApp{\n    public static void main(String[] args){\n        SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,293301929030610944,'2019-05-28 10:53:25','2019-05-28 10:53:25'),(293304436268101632,'<h1>访问映射规则</h1>','sys','待编辑','<p>application.yml</p>\n\n<pre><code class=\"language-ini\">zuul: \n  prefix: /atguigu                                 #统一映射前缀\n  ignored-services: \"*\"                            #忽略真实映射的访问\n  routes: \n    mydept.serviceId: microservicecloud-dept       #真实映射\n    mydept.path: /mydept/**                        #虚拟映射\n</code></pre>\n\n<p>&nbsp;</p>\n',0,293301929030610944,'2019-05-28 10:59:44','2019-05-28 10:59:44'),(293344020385394688,'<h1>Config 分布式配置中心</h1>','sys','待编辑','<p><strong>1、Spring Cloud Config</strong></p>\n\n<ul>\n	<li>为微服务框架中的微服务提供统一的外部配置支持。</li>\n	<li>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、原理</strong></p>\n\n<ul>\n	<li>Config Server：分布式配置中心，它是一个独立的微服务，用来连接配置服务器并为客户端提供配置信息</li>\n	<li>Config Client：通过配置中心，获取对应的配置来管理应用。</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-039.png\" style=\"height:242px; width:600px\"></p>\n\n<p>&nbsp;</p>\n',0,293343993759952896,'2019-06-12 19:42:35','2019-06-12 19:42:35'),(293344041545658368,'<h1>Config 服务端</h1>','sys','待编辑','<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">server:&nbsp;\n&nbsp; port: 3344&nbsp;\n&nbsp;&nbsp;\nspring:\n&nbsp; application:\n&nbsp; &nbsp; name: &nbsp;microservicecloud-config\n&nbsp; cloud:\n&nbsp; &nbsp; config:\n&nbsp; &nbsp; &nbsp; server:\n&nbsp; &nbsp; &nbsp; &nbsp; git:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uri: git@github.com:zhou920786312/microservicecloud-config.git #GitHub上面的git仓库名字</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableConfigServer\npublic class Config_3344_StartSpringCloudApp{\n    public static void main(String[] args){\n        SpringApplication.run(Config_3344_StartSpringCloudApp.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,293343993759952896,'2019-05-28 14:09:36','2019-05-28 14:09:36'),(293352385199108096,'<h1>Config 客户端</h1>','sys','待编辑','<p><strong>1、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">spring:\n  application:\n    name: microservicecloud-config-client</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、bootstrap.yml</strong></p>\n\n<pre><code class=\"language-ini\">#通过uri获取配置中心的所有内容，通过name获取具体的内容，通过profile获取哪个环境的内容\nspring:\n  cloud:\n    config:\n      #name实际内容是github的文件：microservicecloud-config-client.yml\n      name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名\n      profile: test   #本次访问的配置项\n      label: master   \n      uri: http://config-3344.com:3344  \n      #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、启动类</strong></p>\n\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class ConfigClient_3355_StartSpringCloudApp{\n    public static void main(String[] args){\n        SpringApplication.run(ConfigClient_3355_StartSpringCloudApp.class, args);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、获取配置</strong></p>\n\n<ul>\n	<li>与获取本地配置的方式一样</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293343993759952896,'2019-05-28 14:20:08','2019-05-28 14:20:08'),(293467308054966272,'<h1>工厂模式</h1>','sys','待编辑','<h4><strong>一、工厂模式（Factory）</strong></h4>\n\n<p><strong>1、分类</strong></p>\n\n<ul>\n	<li>简单工厂模式</li>\n	<li>工厂方法模式</li>\n	<li>抽象工厂模式</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>使代码结构清晰，有效地封装变化。</li>\n	<li>对调用者屏蔽具体的产品类。</li>\n	<li>降低耦合度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、使用场景</strong></p>\n\n<ul>\n	<li>作为一种创建型模式，在任何需要生成<strong>复杂对象</strong>的地方，都可以使用工厂方法模式。</li>\n	<li>工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。</li>\n	<li>由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h4><strong>二、简单工厂模式</strong></h4>\n\n<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>即静态工厂模式，定义一个专门的工厂类，来负责创建产品类的实例</li>\n	<li>违背开闭原则，不属于 GoF 的 23 种经典设计模式</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象产品\nabstract class AbsProduct {\n    public abstract void operate();\n}\n\n//具体产品：A、B、C...\nclass ProductA extends AbsProduct {\n    public void operate() {\n        System.out.println(\"ProductA\");\n    }\n}\n\n//简单工厂\nclass Factory {\n    public static AbsProduct createProduct(String type){\n        //获取产品A、B、C...\n        if(type==\"A\"){\n            return new ProductA();\n        }\n        if(type==\"B\"){\n            return new ProductB();\n        }\n        return null;\n    }\n}\n\n//情景类\npublic class Client {\n     public static void main(String[] args){\n            AbsProduct productA=Factory.createProduct(\"A\");\n            AbsProduct productB=Factory.createProduct(\"B\");\n            productA.operate();\n            productB.operate();\n     }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>三、工厂方法模式</strong></h4>\n\n<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象产品\nabstract class AbsProduct {\n    public abstract void operate();\n}\n\n//具体产品：A、B、C...\nclass ProductA extends AbsProduct {\n    public void operate() {\n        System.out.println(\"ProductA\");\n    }\n}\n\n//抽象工厂\ninterface class AbsFactory{\n    public &lt;T extends AbsProduct&gt; T createProduct();\n}\n\n//具体工厂：A、B、C...\nclass FactoryA implements AbsFactory{\n    @Override\n    public AbsProduct createProduct(){\n        return new ProductA();\n    }\n}\n\n//情景类\npublic class Client{\n    public static void main(String[] args){\n        FactoryA factoryA = new FactoryA();\n        AbsProduct productA = factoryA.createProduct();\n        productA.operate();\n\n        FactoryB factoryB = new FactoryB();\n        AbsProduct productB = factoryB.createProduct();\n        productB.operate();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>四、抽象工厂方法</strong></h4>\n\n<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象产品：Plant、Animal\ninterface Plant {\n    public void info();\n}\n\n//具体产品：PlantA、PlantB...AnimalA、AnimalB...\nclass PlantA implements Plant {       \n    public void info() {      \n        System.out.println(\"PlantA\");      \n    }      \n}\n\n//抽象工厂：Plant、Animal\ninterface AbsFactory {\n    public Plant createPlant();      \n    public Animal createAnimal();      \n}  \n\n//具体工厂：A、B、C...\nclass FactoryA implements AbsFactory {      \n    public Plant createPlant() {      \n        return new PlantA();      \n    }      \n    public Animal createAnimal() {\n        return new AnimalA();\n    }      \n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Plant p;\n        Animal a;\n        \n        FactoryA factoryA = new FactoryA(); \n        p=factoryA.createPlant();\n        a=factoryA.createAnimal();\n        p.info();\n        a.info();\n        \n        FactoryB factoryB = new FactoryB(); \n        p=factoryB.createPlant();\n        a=factoryB.createAnimal();\n        p.info();\n        a.info();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>3、缺点</strong></p>\n\n<ul>\n	<li>产品族扩展困难。&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>工厂方法模式：针对的是一个产品等级结构</li>\n	<li>抽象工厂模式：针对的是多个产品等级结构，即产品簇</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466724669222912,'2019-05-31 09:47:36','2019-05-31 09:47:36'),(293467404075167744,'<h1>单例模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Singleton</li>\n	<li>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//单例类\nclass Singleton {\n    //1、私有化实例\n    private static volatile Singleton instance = null;\n    \n    //2、私有化构造函数\n    private Singleton(){}\n    \n    //3、对外提供获取实例的方法\n    public static Singleton getInstance(){\n        //加同步锁，双重判定\n        if(instance == null){\n            synchronized(Singleton.class){\n                if(instance == null){\n                    return  new Singleton();\n                }\n            }\n        }\n        return instance;        \n    }\n    \n    public void info() {\n        System.out.println(\"只有一个实例！\");\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Singleton s = Singleton.getInstance();\n        s.info();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、分类</strong></p>\n\n<pre><code class=\"language-java\">//饿汉式：在类初始化时，已经自行实例化   \npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton(){}\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n\n//懒汉式：在第一次调用的时候实例化自己\npublic class Singleton {  \n    private static Singleton single=null; \n    private Singleton() {}  \n    public static Singleton getInstance() {  \n         if (single == null) {    \n             single = new Singleton();  \n         }    \n        return single;  \n    }  \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、优点</strong></p>\n\n<ul>\n	<li>在内存中只有一个对象，节省内存空间。</li>\n	<li>避免频繁的创建销毁对象，可以提高性能。</li>\n	<li>避免对共享资源的多重占用。</li>\n	<li>可以全局访问。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、适用场景</strong></p>\n\n<ul>\n	<li>需要频繁实例化然后销毁的对象。</li>\n	<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</li>\n	<li>有状态的工具类对象。</li>\n	<li>频繁访问数据库或文件的对象。</li>\n	<li>以及其他要求只有一个对象的场景。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、注意事项</strong></p>\n\n<ul>\n	<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>\n	<li>不要做断开单例类对象与类中静态引用的危险操作。</li>\n	<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>\n	<li>单例类不要实现Cloneable接口。</li>\n</ul>\n\n<p><br>\n&nbsp;</p>\n',0,293466724669222912,'2019-05-31 09:47:53','2019-05-31 09:47:53'),(293467432965533696,'<h1>建造者模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Builder</li>\n	<li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//产品：被构造的复杂对象\nclass Product {\n    private String part1;\n    private String part2;\n    //set、get、toString...\n}\n\n//抽象建造者：规定产品所需零件，并建造产品\ninterface AbsBuilder {\n    void setPart1();\n    void setPart2();\n    Product build();\n}\n\n//具体建造者：A、B、C...\nclass BuilderA implements AbsBuilder {\n    private Product product= new Product();\n\n    @Override\n    public void setPart1() {\n        product.setPart1(\"A1\");  \n    }\n    @Override\n    public void setPart2() {\n        product.setPart2(\"A2\");  \n    }\n    @Override\n    public Product build() {\n        return product;\n    }\n}\n\n//导演类：调用建造者，指导产品零件的组装流程\nclass Director{\n    public Product getProduct(AbsBuilder builder){\n        builder.setPart1();\n        builder.setPart2();\n        return builder.build();\n    }\n}\n\n//情景类\npublic class Client{\n    public static void main(String[] args){\n        Director director=new Director();\n        Product a=director.getProduct(new BuilderA());\n        Product b=director.getProduct(new BuilderB());\n        System.out.println(a.toString());\n        System.out.println(b.toString());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>封装性很好，便于控制细节风险</li>\n	<li>建造者独立，易扩展</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>建造者模式关注的是零件类型和装配顺序，即产品的建造过程&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466724669222912,'2019-05-31 09:26:30','2019-05-31 09:26:30'),(293467459939102720,'<h1>原型模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Prototype</li>\n	<li>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//原型类：1、实现Cloneable接口\nclass Prototype implements Cloneable{\n    //2、覆写clone方法\n    @Override\n    public Prototype clone(){\n        Prototype p = null;\n        try {\n            p = (Prototype)super.clone();\n        } catch (CloneNotSupportedException e) {\n            System.out.println(\"克隆失败...\");\n        }\n        return p;\n    }\n    \n    private String value;\n    //setter、getter...\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Prototype p1=new Prototype();\n        p1.setValue(\"张三\");\n        \n        //以p1为原型，克隆得到p2\n        Prototype p2=p1.clone();\n        System.out.println(\"p2：\"+p2.getValue());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优缺点</strong></p>\n\n<ul>\n	<li>性能优良（内存二进制流的拷贝）</li>\n	<li>避开了构造函数的约束</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、主要事项</strong></p>\n\n<ul>\n	<li>克隆过程中，不会执行被克隆类的构造方法</li>\n	<li>浅拷贝：Object类的clone()只拷贝类方法、类成员（基本数据类型+String类型）</li>\n	<li>深拷贝：对引用数据类型的类成员也进行拷贝</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466724669222912,'2019-05-31 09:48:15','2019-05-31 09:48:15'),(293467521217884160,'<h1>设计原则</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">原则</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">重要性</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<th scope=\"row\">开闭原则</th>\n			<td>对扩展开放，对修改封闭</td>\n			<td>★★★★★</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">依赖倒转</th>\n			<td>面向接口编程，依赖于抽象而不依赖于具体。</td>\n			<td>★★★★★</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">单一职责</th>\n			<td>一个类的职责要单一，不能将太多的职责放到一个类中</td>\n			<td>★★★★☆</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">里式替换</th>\n			<td>一个可以接受父类对象的地方，必然可以接受其子类对象</td>\n			<td>★★★★☆</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">合成复用</th>\n			<td>尽量使用组合而不是继承，来达到软件复用的目的</td>\n			<td>★★★★☆</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">迪米特法则</th>\n			<td>一个类对自己依赖的类知道的越少越好</td>\n			<td>★★★☆☆</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">接口隔离</th>\n			<td>使用多个专门的接口来取代一个统一的接口</td>\n			<td>★★☆☆☆</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,293465793894445056,'2019-05-30 09:20:40','2019-05-30 09:20:40'),(294276387694342144,'<h1>适配器模式<br></h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Adapter</li>\n	<li>将一个类的接口变换成客户端所期待的另一种接口，从而使两个不匹配的类能在一起工作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//源角色：已存在、不符合既有接口的类\nclass Adaptee {\n    public void get220v(){\n        System.out.println(\"220v电压...\"); \n    }    \n}\n\n//抽象目标角色  \ninterface AbsTarget {\n    public void get110v();\n}\n\n//具体目标角色\nclass Target implements AbsTarget {\n    @Override\n    public void get110v() {\n        System.out.println(\"110v电压...\"); \n    }\n}\n\n//类适配器\nclass AdapterClass extends Adaptee implements AbsTarget{\n    @Override\n    public void get110v() {\n        super.get220v();\n    }\n}\n\n//对象适配器\nclass AdapterObject implements AbsTarget{\n     //源角色  \n    private Adaptee adaptee;    \n        \n    //构造函数传递对象  \n    public AdapterObject(Adaptee adaptee) {    \n        this.adaptee = adaptee;    \n    }    \n    \n    @Override\n    public void get110v() {\n        this.adaptee.get220v();\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        AbsTarget target;\n        //原有业务逻辑  \n        target = new Target();  \n        target.get110v(); \n        \n        //类适配器\n        target = new AdapterClass();  \n        target.get110v(); \n        \n        //对象适配器\n        target = new AdapterObject(new Adaptee());  \n        target.get110v(); \n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>&nbsp;可以让任何两个没有关联的类一起运行。</li>\n	<li>提高了类的复用。</li>\n	<li>增加了类的透明度。</li>\n	<li>灵活性好。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>适配器模式是一个“补救”模式，是解决正在服役项目的问题，设计阶段不要考虑它。&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466805917085696,'2019-05-31 09:25:10','2019-05-31 09:25:10'),(294276402097582080,'<h1>装饰器模式<br></h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Decorator</li>\n	<li>不改变原类结构、不使用继承的情况下，动态地给一个对象添加一些额外的职责。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标类\ninterface AbsTarget {\n    public void method();\n}\n\n//具体目标类\nclass Target implements AbsTarget {\n    public void method() {\n        System.out.println(\"吃饭...\");\n    }\n}\n\n//装饰者：A、B、C...\nclass DecoratorA implements AbsTarget{\n    //1、定义被修饰者 \n    private AbsTarget absTarget = null;  \n\n    //2、传递被修饰者\n    public DecoratorA(AbsTarget absTarget) {\n        this.absTarget=absTarget;\n    }\n\n    //3、增强被修饰者的行为\n    @Override\n    public void method() {\n        this.before();\n        absTarget.method();\n        this.after();\n    }\n    \n    private void before() {\n        System.out.println(\"饭前去洗手，长寿到白首...\");\n    }\n    private void after() {\n        System.out.println(\"饭后一根烟，赛过活神仙...\");\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {  \n        AbsTarget target = new Target();  \n        target = new DecoratorB(new DecoratorA(target));  \n        target.method();  \n    }  \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>解耦：装饰类和被装饰类。</li>\n	<li>是继承关系的一个替代方案。</li>\n	<li>可动态地扩展一个实现类的功能。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>多层装饰比较复杂，应尽量减少装饰类的数量，以便降低系统的复杂度&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466805917085696,'2019-05-31 09:25:24','2019-05-31 09:25:24'),(294276417507454976,'<h1>代理模式<br></h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Proxy</li>\n	<li>为其他对象提供一种代理以控制对这个对象的访问。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、静态代理</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标类\ninterface AbsTarget {\n    public void method();\n}\n\n//具体目标类\nclass Target implements AbsTarget {\n    public void method() {\n        System.out.println(\"吃饭...\");\n    }\n}\n\n//代理类\nclass Proxy implements AbsTarget{\n    //1、定义被代理者 \n    private AbsTarget absTarget = null;  \n\n    //2、传递被代理者 \n    public Proxy(AbsTarget absTarget) {\n        this.absTarget=absTarget;\n    }\n\n    //3、控制被代理者的行为\n    @Override\n    public void method() {\n        Random rand = new Random();\n        if(rand.nextBoolean()){\n            System.out.println(\"代理人今天高兴，同意安排吃饭\");\n            absTarget.method();\n        }else{\n            System.out.println(\"代理人心情不好，不安排吃饭\");\n        }\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {  \n        AbsTarget target = new Target();  \n        target = new Proxy(target);  \n        target.method();  \n    }  \n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、动态代理</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标类\ninterface AbsTarget {\n    public void method();\n}\n\n//具体目标类\nclass Target implements AbsTarget {\n    public void method() {\n        System.out.println(\"吃饭...\");\n    }\n}\n\n/**\n * JDK 动态代理\n */\nclass JDKProxy implements InvocationHandler{\n    //1、被代理的目标对象 \n    private Object target = null;  \n\n    //2、获取代理对象\n    public Object newProxy(Object obj) {\n        this.target=obj;\n        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),\n                target.getClass().getInterfaces(), this);\n    }\n\n    //3、操作代理对象的行为\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        this.before();\n        Object result = method.invoke(target, args); \n        this.after();\n        return result;\n    }\n    \n    private void before() {\n        System.out.println(\"jdk:饭前去洗手，长寿到白首...\");\n    }\n    private void after() {\n        System.out.println(\"jdk:饭后一根烟，赛过活神仙...\");\n    }\n}\n\n/**\n * CGLib 动态代理 \n */\nclass CGLibProxy implements MethodInterceptor {\n    //1、被代理的目标对象\n    private Object target=null;\n    \n    //2、获取代理对象\n    public Object newProxy(Object obj){\n        this.target = obj;        \n        Enhancer enhancer = new Enhancer();       //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类    \n        enhancer.setSuperclass(obj.getClass());\n        enhancer.setCallback(this);\n        Object proxyObj = enhancer.create();\n        return proxyObj;\n    }    \n    \n    //3、操作代理对象的行为\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        this.before();\n        Object result = method.invoke(target, args);\n        this.after();\n        return result;\n    }\n\n    private void before() {\n        System.out.println(\"cglib:饭前去洗手，长寿到白首...\");\n    }\n    private void after() {\n        System.out.println(\"cglib:饭后一根烟，赛过活神仙...\");\n    }\n}\n\n//情景类\npublic class Test {\n    public static void main(String[] args) {\n        JDKProxy jdkProxy=new JDKProxy();\n        CGLibProxy cglibProxy=new CGLibProxy();\n        \n        AbsTarget target1=(AbsTarget) jdkProxy.newProxy(new Target());\n        AbsTarget target2=(AbsTarget) cglibProxy.newProxy(new Target());\n        target1.method();\n        target2.method();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、优点</strong></p>\n\n<ul>\n	<li>职责清晰</li>\n	<li>高扩展性</li>\n	<li>智能化</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、静态代理、动态代理</strong></p>\n\n<ul>\n	<li>静态代理：手动生成代理类</li>\n	<li>动态代理：运用反射机制，动态生成代理类</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、JDK 动态代理、CGLib 动态代理</strong></p>\n\n<ul>\n	<li>JDK 动态代理\n	<ul>\n		<li>只能代理实现了接口的类</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>CGLib 动态代理\n	<ul>\n		<li>是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理</li>\n	</ul>\n	</li>\n</ul>\n',0,293466805917085696,'2019-05-31 09:25:34','2019-05-31 09:25:34'),(294276434825736192,'<h1>外观模式<br></h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Facade</li>\n	<li>又称门面模式。</li>\n	<li>子系统外部与其内部的通信，必须通过一个统一的对象进行。</li>\n	<li>外观模式提供一个高层次的接口，使得子系统更易于使用。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//子系统A、B、C...\nclass ClassA {\n    public void doSomethingA(){\n        System.out.println(\"A doSomething...\");\n    }\n}\n\n//门面类\nclass Facade {\n    //被委托的对象\n    private ClassA a = new ClassA();\n    private ClassB b = new ClassB();\n    private ClassC c = new ClassC();\n    //提供给外部访问的方法\n    public void methodA(){\n        this.a.doSomethingA();\n    }\n    public void methodB(){\n        this.b.doSomethingB();\n    }\n    public void methodC(){\n        this.c.doSomethingC();\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Facade facade = new Facade();\n        facade.methodA();\n        facade.methodB();\n        facade.methodC();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>减少系统相互依赖</li>\n	<li>提高灵活性</li>\n	<li>提高安全性</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>不符合开闭原则</li>\n	<li>一个子系统可以有多个门面</li>\n	<li>门面不参与子系统内的业务逻辑</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466805917085696,'2019-05-31 09:25:45','2019-05-31 09:25:45'),(294276475883778048,'<h1>桥接模式<br></h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Bridge</li>\n	<li>将抽象和实现解耦，使得两者可以独立地变化。<br>\n	&nbsp;</li>\n</ul>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标\ninterface AbsTarget {\n    public void method();\n}\n\n//具体目标A、B、C...\nclass TargetA implements AbsTarget {\n    @Override\n    public void method() {\n        System.out.println(\"具体目标A\");\n    }\n}\n\n//抽象桥类\nabstract class Bridge {\n    //引用目标角色\n    protected AbsTarget target;\n    \n    //传入目标角色\n    public Bridge(AbsTarget target) {\n        this.target=target;\n    }\n    \n    //自身的行为\n    public abstract void operate();\n}\n\n//来源A、B、C...\nclass SourceA extends Bridge {\n    \n    public SourceA(AbsTarget target) {\n        super(target);\n    }\n\n    @Override\n    public void operate() {\n        System.out.println(\"来源A\");\n        this.target.method();\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        AbsTarget target=new TargetA();\n        Bridge a=new SourceA(target);\n        a.operate();\n        \n        target=new TargetB();\n        a=new SourceA(target);\n        a.operate();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>抽象和实现的分离</li>\n	<li>优秀的扩展能力</li>\n	<li>实现细节对客户透明</li>\n	<li>是继承的一种替代方式</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>对于两个独立变化的维度，适合使用桥接模式</li>\n</ul>\n',0,293466805917085696,'2019-05-31 09:25:55','2019-05-31 09:25:55'),(294277072682905600,'<h1>组合模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Composite</li>\n	<li>又称部分整体模式</li>\n	<li>是把一组相似的对象当作一个单一的对象</li>\n	<li>将对象组合成树形结构以表示\"部分-整体\"的层次结构</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<ul>\n	<li>即树形结构数据，如树形菜单</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>高层模块调用简单</li>\n	<li>节点自由增加。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、备注</strong></p>\n\n<ul>\n	<li>只要是树形结构，就要考虑使用组合模式。&nbsp;</li>\n</ul>\n',0,293466805917085696,'2019-05-31 09:20:42','2019-05-31 09:20:42'),(294277108481290240,'<h1>享元模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Flyweight</li>\n	<li>运用共享技术有效地支持大量细粒度的对象。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象享元类\nabstract class AbsFlyweight {\n    //内部状态：不可改变，可以共享\n    protected final String color;\n    \n    //构造方法：传入内部状态\n    public AbsFlyweight(String color){\n        this.color = color;\n    }\n    \n    public abstract void display(String position);\n}\n\n//具体享元类\nclass Flyweight extends AbsFlyweight {\n    public Flyweight(String color) {\n        super(color);\n    }\n    \n    //外部状态：可以改变，不可共享，作为参数传入方法中\n    public void display(String position){\n        System.out.println(\"棋子：\"+color+\"，\"+position);\n    }\n}\n\n//享元工厂\nclass FlyweightFactory {\n    //池容器\n    private static HashMap&lt;String,Flyweight&gt; pool= new HashMap&lt;&gt;();\n    \n    //获取享元对象\n    public static Flyweight getFlyweight(String color){\n        Flyweight flyweight = null;\n        if(pool.containsKey(color)){\n            System.out.print(\"————————————\");\n            flyweight = pool.get(color);\n        }else{\n            System.out.print(\"++++++++++++\");\n            flyweight = new Flyweight(color);\n            pool.put(color, flyweight);\n        }\n        return flyweight;\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Flyweight chess;\n        for (int i = 0; i &lt; 3; i++) {\n            for (int j = 0; j &lt; 3; j++) {\n                if(new Random().nextBoolean()){\n                    chess=FlyweightFactory.getFlyweight(\"黑色\");\n                }else {\n                    chess=FlyweightFactory.getFlyweight(\"白色\");\n                }\n                chess.display(\"x\"+i+\"y\"+j);\n            }\n        }\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优缺点</strong></p>\n\n<ul>\n	<li>大大减少对象的创建，降低系统的内存，使效率提高。</li>\n	<li>提高了系统的复杂度，需要分离出外部状态和内部状态</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、适用场景</strong></p>\n\n<ul>\n	<li>系统有大量相似对象</li>\n	<li>需要缓冲池的场景</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、注意事项</strong></p>\n\n<ul>\n	<li>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</li>\n	<li>这些类必须有一个工厂对象加以控制</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466805917085696,'2019-05-31 09:47:00','2019-05-31 09:47:00'),(294277968443633664,'<h1>策略模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Strategy</li>\n	<li>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象策略\ninterface AbsStrategy {\n    public void doSomething();\n}\n\n//具体策略A、B、C...\nclass StrategyA implements AbsStrategy {\n    @Override\n    public void doSomething() {\n        System.out.println(\"具体策略A的运算法则\");\n    }\n}\n\n//封装策略类\nclass Context {\n    //抽象策略\n    private AbsStrategy policy = null;\n    //构造函数设置具体策略\n    public Context(AbsStrategy policy){\n        this.policy = policy;\n    }\n    //封装后的策略方法\n    public void doAnythinig(){\n        this.policy.doSomething();\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        //声明一个具体的策略\n        AbsStrategy policy = new StrategyA();\n        //声明上下文对象\n        Context context = new Context(policy);\n        //执行封装后的方法\n        context.doAnythinig();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>算法可以自由切换</li>\n	<li>避免使用多重条件判断</li>\n	<li>扩展性良好。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>维护各个策略类会给开发带来额外开销</li>\n	<li>所有策略类都需要对外暴露</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、注意事项</strong></p>\n\n<ul>\n	<li>具体策略数量尽量不要超过4个</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-05-31 17:00:29','2019-05-31 17:00:29'),(294277997786984448,'<h1>模板模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Template</li>\n	<li>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象模板类\nabstract class AbsTemplate {\n    //基本方法\n    protected abstract void doSomething();\n    protected abstract void doAnything();\n    \n    //模板方法\n    public void templateMethod(){\n        //调用基本方法，完成相关的逻辑\n        this.doSomething();\n        this.doAnything();\n    }\n}\n\n//具体模板类A、B、C...\nclass TemplateA extends AbsTemplate {\n    @Override\n    protected void doSomething() {\n        System.out.println(\"穿休闲服\");\n    }\n    @Override\n    protected void doAnything() {\n        System.out.println(\"坐公交车\");\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        AbsTemplate class1 = new TemplateA();\n        class1.templateMethod();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>封装不变部分，扩展可变部分</li>\n	<li>提取公共代码，便于维护</li>\n	<li>行为由父类控制，子类实现。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>与设计习惯颠倒，子类对父类产生了影响，给阅读代码带来困难。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-05-31 17:06:18','2019-05-31 17:06:18'),(294278029445591040,'<h1>观察者模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Observer</li>\n	<li>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标\nabstract class AbsTarget {\n    //定义一个观察者数组\n    private List&lt;AbsObserver&gt; observers = new ArrayList&lt;&gt;();\n    //增加一个观察者\n    public void addObserver(AbsObserver o){\n        observers.add(o);\n    }\n    //删除一个观察者\n    public void delObserver(AbsObserver o){\n        observers.remove(o);\n    }\n    //通知所有观察者\n    public void notifyObservers(){\n        for(AbsObserver o:observers){\n            o.update();\n        }\n    }\n}\n\n//具体目标\nclass Target extends AbsTarget {\n    //具体的业务\n    public void doSomething(){\n        System.out.println(\"目标出现！\");\n        super.notifyObservers();\n    }\n}\n\n//抽象观察者\ninterface AbsObserver {\n    //更新方法\n    public void update();\n}\n\n//具体观察者\nclass Observer implements AbsObserver{\n    //实现更新方法\n    public void update() {\n        System.out.println(\"抓住目标！\");\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        // 目标\n        Target target = new Target();\n        // 观察者\n        AbsObserver obs = new Observer();\n        // 观察者监视目标\n        target.addObserver(obs);\n        // 目标开始活动了\n        target.doSomething();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>观察者和被观察者是抽象耦合的</li>\n	<li>建立一套触发机制</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>\n	<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>\n	<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、注意事项</strong></p>\n\n<ul>\n	<li>JAVA 中已经有了对观察者模式的支持类</li>\n	<li>避免循环引用</li>\n	<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-05-31 17:12:49','2019-05-31 17:12:49'),(294278053751582720,'<h1>迭代器模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Iterator</li>\n	<li>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、备注</strong></p>\n\n<ul>\n	<li>Java已经把迭代器模式融入到集合框架API中，直接使用java.util.Iterator即可&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-05-31 17:15:14','2019-05-31 17:15:14'),(294278079252951040,'<h1>责任链模式</h1>','sys','待编辑','<p>1、定义</p>\n\n<ul>\n	<li>Chain of Responsibility</li>\n	<li>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。</li>\n	<li>将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、示例</p>\n\n<pre><code class=\"language-java\">//抽象处理者\nabstract class AbsHandler {\n    // 下一个处理者\n    protected AbsHandler nextHandler;\n    public AbsHandler getNextHandler() {\n        return nextHandler;\n    }\n    public void setNextHandler(AbsHandler nextHandler) {\n        this.nextHandler = nextHandler;\n    }\n\n    //业务处理\n    public abstract void doHandler(double free);\n}\n\n//处理人A、B、C...\nclass HandlerA extends AbsHandler{\n    @Override\n    public void doHandler(double free) { \n        if (free &lt;= 500) {    \n            System.out.println(\"费用：\"+free+\",给予报销...\");\n            return;\n        }\n        if(this.getNextHandler()!=null){\n            //转发请求    \n            this.nextHandler.doHandler(free);\n        }else {\n            System.out.println(\"费用：\"+free+\",不予报销...\");\n        }\n    }    \n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        AbsHandler a = new HandlerA();\n        AbsHandler b = new HandlerB();\n        AbsHandler c = new HandlerC();\n        a.setNextHandler(b);\n        b.setNextHandler(c);\n        \n        a.doHandler(4300);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>降低耦合度。它将请求的发送者和接收者解耦。</li>\n	<li>简化了对象。使得对象不需要知道链的结构。</li>\n	<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>\n	<li>增加新的请求处理类很方便。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>不能保证请求一定被接收。</li>\n	<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li>\n	<li>可能不容易观察运行时的特征，有碍于除错。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、备注</strong></p>\n\n<ul>\n	<li>责任链模式其实就是一个灵活版的if…else…语句</li>\n</ul>\n',0,293466863634903040,'2019-05-31 17:23:08','2019-05-31 17:23:08'),(294278104217448448,'<h1>命令模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Command</li>\n	<li>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象接收者\nabstract class AbsReceiver {\n    public abstract void doSomething();\n}\n\n//具体接收者A、B、C...\nclass ReceiverA extends AbsReceiver {\n    @Override\n    public void doSomething() {\n        System.out.println(\"接收者A do something\");\n    }\n}\n\n//抽象命令者\nabstract class AbsCommand {\n    public abstract void execute();\n}\n\n//命令者A、B、C...\nclass CommandA extends AbsCommand {\n    //对哪个Receiver类进行命令处理\n    private AbsReceiver receiver;\n    //构造函数传递接收者\n    public CommandA(AbsReceiver receiver){\n        this.receiver = receiver;\n    }\n    //必须实现一个命令\n    public void execute() {\n        //业务处理\n        this.receiver.doSomething();\n    }\n}\n\n//调用者\nclass Invoker {\n    private AbsCommand command;\n    //受气包，接受命令者\n    public void setCommand(AbsCommand command){\n        this.command = command;\n    }\n    //执行命令\n    public void action(){\n        this.command.execute();\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        // 首先声明调用者Invoker\n        Invoker invoker = new Invoker();\n        // 定义接收者\n        AbsReceiver receiver = new ReceiverA();\n        // 定义一个发送给接收者的命令\n        AbsCommand command = new CommandA(receiver);\n        // 把命令交给调用者去执行\n        invoker.setCommand(command);\n        invoker.action();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-05-31 17:26:53','2019-05-31 17:26:53'),(294278128900927488,'<h1>备忘录模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Memento</li>\n	<li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//备忘录\nclass Memento {\n    //发起人的内部状态\n    private String state = \"\";\n    //构造函数传递参数\n    public Memento(String state){\n        this.state = state;\n    }\n    public String getState() {\n        return state;\n    }\n    public void setState(String state) {\n        this.state = state;\n    }\n}\n\n//备忘录管理员\nclass Manager{\n    //备忘录对象\n    private Memento memento;\n    public Memento getMemento() {\n        return memento;\n    }\n    public void setMemento(Memento memento) {\n        this.memento = memento;\n    }\n}\n\n//发起人\nclass Originator {\n    //内部状态\n    private String state = \"\";\n    public String getState() {\n        return state;\n    }\n    public void setState(String state) {\n        this.state = state;\n    }\n    //创建一个备忘录\n    public Memento createMemento(){\n        return new Memento(this.state);\n    }\n    //恢复一个备忘录\n    public void restoreMemento(Memento memento){\n        this.setState(memento.getState());\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        //定义出发起人\n        Originator originator = new Originator();\n        //定义出备忘录管理员\n        Manager manager = new Manager();\n        //创建一个备忘录\n        manager.setMemento(originator.createMemento());\n        //恢复一个备忘录\n        originator.restoreMemento(manager.getMemento());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>\n	<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>消耗资源</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-06-01 00:58:29','2019-06-01 00:58:29'),(294278152321921024,'<h1>状态模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>State</li>\n	<li>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//环境类：电梯\nclass Lift {\n    //所有状态\n    public final static OpenState state_open = new OpenState();\n    public final static CloseState state_close = new CloseState();\n    public final static RunState state_run = new RunState();\n    public final static StopState state_stop = new StopState();\n    \n    //当前状态\n    private LiftState state;\n    public LiftState getState() {\n        return state;\n    }\n    public void setState(LiftState state) {\n        this.state = state;\n        //把当前的环境通知到各个实现类中\n        this.state.setLift(this);\n    }\n    \n    //行为委托给状态类\n    public void open(){\n        this.state.open();\n    }\n    public void close(){\n        this.state.close();\n    }\n    public void run(){\n        this.state.run();\n    }\n    public void stop(){\n        this.state.stop();\n    }\n}\n\n//抽象状态类：电梯状态\nabstract class LiftState{\n    //定义环境角色\n    protected Lift lift;\n    public void setLift(Lift lift){\n        this.lift = lift;\n    }\n    \n    //定义动作\n    public abstract void open();    //开门\n    public abstract void close();    //关门\n    public abstract void run();        //运行\n    public abstract void stop();    //停止\n}\n\n//开门状态（其他状态类似，关门状态/运行状态/停止状态）\nclass OpenState extends LiftState {\n    public void open() {\n        System.out.println(\"电梯门开启...\");\n    }\n    public void close() {\n        lift.setState(Lift.state_close);\n        lift.close();\n    }\n    public void run() {\n    }\n    public void stop() {\n    }\n}\n\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        Lift lift = new Lift();\n        lift.setState(new CloseState());\n        lift.open();\n        lift.stop();\n        lift.run();\n        lift.close();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>封装了转换规则</li>\n	<li>枚举可能的状态，在枚举状态之前需要确定状态种类</li>\n	<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为</li>\n	<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</li>\n	<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>状态模式的使用必然会增加系统类和对象的个数</li>\n	<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</li>\n	<li>状态模式对\"开闭原则\"的支持并不太好</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、备注</strong></p>\n\n<ul>\n	<li>行为受状态约束时使用。</li>\n	<li>对象的状态最好不要超过5个。</li>\n</ul>\n',0,293466863634903040,'2019-06-01 01:05:50','2019-06-01 01:05:50'),(294278175742914560,'<h1>访问者模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Visitor</li>\n	<li>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象目标类\nabstract class AbsTarget {\n    //自身业务逻辑\n    public abstract void doSomething();\n    //接收访问者\n    public abstract void accept(AbsVisitor visitor);\n}\n\n//具体目标类A、B、C...\nclass TargetA extends AbsTarget{\n    public void doSomething(){\n        System.out.println(\"TargetA do Something...\");\n    }\n    public void accept(AbsVisitor visitor){\n        visitor.visit(this);\n    }\n}\n\n//抽象访问者\ninterface AbsVisitor {\n    //可以访问哪些对象\n    public void visit(TargetA t1);\n    public void visit(TargetB t2);\n}\n\n//具体访问者\nclass Visitor implements AbsVisitor{\n    public void visit(TargetA t1) {\n        t1.doSomething();\n    }\n    public void visit(TargetB t2) {\n        t2.doSomething();\n    }\n}\n\n//结构对象\nclass ObjectStructure {\n    public static AbsTarget createTarget(){\n        Random rand = new Random();\n        if(rand.nextBoolean()){\n            return new TargetA();\n        }else{\n            return new TargetB();\n        }\n    }\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        //获得元素对象\n        AbsTarget t = ObjectStructure.createTarget();\n        //接受访问者访问\n        t.accept(new Visitor());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>符合单一职责原则</li>\n	<li>优秀的扩展性</li>\n	<li>灵活性。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>具体元素对访问者公布细节，违反了迪米特原则</li>\n	<li>具体元素变更比较困难</li>\n	<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,293466863634903040,'2019-06-01 01:09:50','2019-06-01 01:09:50'),(294278205937709056,'<h1>中介者模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Mediator</li>\n	<li>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-java\">//抽象中介者\nabstract class AbsMediator {\n    //保持各个同事的联系方式\n    protected Map&lt;String,AbsColleague&gt; colleagues=new HashMap&lt;&gt;();\n    \n    //动态联系某个同事\n    public void addColleague(String name, AbsColleague c) { \n        colleagues.put(name, c); \n    } \n    //动态撤销某个同事的联系\n    public void deleteColleague(String name) { \n        this.colleagues.remove(name); \n    } \n    \n    //中介者必须具备在同事之间处理逻辑、分配任务、促进交流的操作 \n    public abstract void request(String name);  \n}\n\n//具体中介者\nclass Mediator extends AbsMediator {\n    @Override\n    public void request(String name) {\n        AbsColleague b=this.colleagues.get(name);\n        System.out.println(\"中介者 --&gt; 请求...\");\n        b.self();\n    }\n}\n\n//抽象同事类\nabstract class AbsColleague {\n    //能联系中介者\n    protected AbsMediator mediator;\n    public AbsColleague(AbsMediator mediator) {\n        this.mediator = mediator;\n    }\n    \n    //各同事自有方法\n    public abstract void self();\n}\n\n//具体同事类A\nclass ColleagueA extends AbsColleague {\n    public ColleagueA(AbsMediator mediator) {\n        super(mediator);\n    }\n\n    // 自有方法\n    public void self() {\n        System.out.println(\"同事A --&gt; 使用打印纸 ...\");\n    }\n\n    // 依赖方法\n    public void out() {\n        System.out.println(\"同事A --&gt; 请求同事B买打印纸 ...\");\n        super.mediator.request(\"同事B\");\n    }\n}\n\n//具体同事类B\nclass ColleagueB extends AbsColleague {\n    public ColleagueB(AbsMediator mediator) {\n        super(mediator);\n    }\n\n    //自有方法\n    public void self() { \n        System.out.println(\"同事B --&gt; 买打印纸 ...\");\n    } \n\n    // 依赖方法...\n}\n\n//情景类\npublic class Client {\n    public static void main(String[] args) {\n        AbsMediator mediator = new Mediator();\n        ColleagueA colleagueA = new ColleagueA(mediator); \n        ColleagueB colleagueB = new ColleagueB(mediator);\n        mediator.addColleague(\"同事B\", colleagueB);\n        \n        colleagueA.out();\n        colleagueA.self();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、优点</strong></p>\n\n<ul>\n	<li>降低了类的复杂度，将一对多转化成了一对一</li>\n	<li>各个类之间的解耦</li>\n	<li>符合迪米特原则。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、缺点</strong></p>\n\n<ul>\n	<li>中介者会庞大，变得复杂难以维护。</li>\n</ul>\n',0,293466863634903040,'2019-06-01 01:13:40','2019-06-01 01:13:40'),(294278234895183872,'<h1>解释器模式</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>Interpreter</li>\n	<li>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>可扩展性比较好，灵活</li>\n	<li>增加了新的解释表达式的方式</li>\n	<li>易于实现简单文法。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、缺点</strong></p>\n\n<ul>\n	<li>可利用场景比较少</li>\n	<li>对于复杂的文法比较难维护</li>\n	<li>解释器模式会引起类膨胀</li>\n	<li>解释器模式采用递归调用方法。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、注意事项</strong></p>\n\n<ul>\n	<li>解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。</li>\n</ul>\n',0,293466863634903040,'2019-06-01 01:16:13','2019-06-01 01:16:13'),(294386335061274100,'<h1>概念</h1>','sys','待编辑','<p><strong>1、程序、进程、线程</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th scope=\"row\">程序</th>\n			<td>为完成特定任务、用某种语言编写的一组指令的集合。</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">进程</th>\n			<td>正在运行的程序的实例。</td>\n			<td>操作系统资源分配的基本单位</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">线程</th>\n			<td>进程的组成部分，代表一个单一顺序的执行流。</td>\n			<td>任务调度和执行的基本单位</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、串行、并发、并行</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<td>定义</td>\n			<td>特征</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">串行</th>\n			<td><strong>顺序</strong> 执行多个任务</td>\n			<td>一个任务执行完毕后，再执行下一个任务</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">并发</th>\n			<td><strong>交替&nbsp;</strong>执行多个任务</td>\n			<td>同一时刻，只有一个任务在执行</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">并行</th>\n			<td><strong>同时&nbsp;</strong>执行多个任务</td>\n			<td>同一时刻，同时有多个任务在执行</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、同步、异步、阻塞、非阻塞</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>&nbsp;</td>\n			<td>定义</td>\n			<td>关注点</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">同步</th>\n			<td>执行某个任务，等待结果返回，再执行后续任务</td>\n			<td colspan=\"1\" rowspan=\"2\">指处理方式，是否等待结果</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">异步</th>\n			<td>执行某个任务，不等待结果返回，就执行后续任务</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">阻塞</th>\n			<td>调用结果返回前，当前线程挂起</td>\n			<td colspan=\"1\" rowspan=\"2\">指自身状态，是否能去做其他事</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">非阻塞</th>\n			<td>调用结果返回前，该调用不会挂起当前线程</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、临界资源、临界区、线程互斥</strong></p>\n\n<ul>\n	<li>临界资源：是一次仅允许一个进程使用的共享资源</li>\n	<li>临界区：各个进程中，操作临界资源的代码片段</li>\n	<li>相关临界区：多个进程涉及到同一个临界资源的临界区</li>\n	<li>线程互斥：多个线程之间竞争使用临界资源的现象</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-02 22:05:18','2019-06-02 22:05:18'),(294386335061274300,'<h1>线程</h1>','sys','待编辑','<p><strong>1、创建线程</strong></p>\n\n<pre><code class=\"language-java\">//方式一：继承 Thread 类\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        //线程执行体...\n    }\n}\n\n//方式二：实现 Runnable 接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        //线程执行体...\n    }\n}\n\n//方式三：实现 Callable 接口\nclass MyCallable implements Callable&lt;String&gt;{ \n    @Override\n    public String call(){\n        //线程执行体...\n        return \"\";\n    } \n}\n\n//方式四：线程池\n\n//测试\npublic class Test {\n    public static void main(String[] args) {\n        /*************Thread****************/\n        MyThread t1=new MyThread();\n        t1.start();        \n        \n        /*************Runnable****************/\n        MyRunnable mr=new MyRunnable();\n        Thread t2=new Thread(mr);\n        t2.start();\n        \n        /*************Callable****************/\n        MyCallable mc=new MyCallable();\n        FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc);\n        Thread t3=new Thread(ft);\n        t3.start();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java.lang.Thread</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">成员方法</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">静态方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>start()</td>\n			<td>开始执行线程，JVM 会调用该线程的 run()</td>\n			<td>yield()</td>\n			<td>使当前线程暂停</td>\n		</tr>\n		<tr>\n			<td>run()</td>\n			<td>线程的任务方法</td>\n			<td>sleep()</td>\n			<td>使当前线程休眠</td>\n		</tr>\n		<tr>\n			<td>setName()</td>\n			<td>修改线程名称</td>\n			<td>holdsLock()</td>\n			<td>当前线程是否持有指定锁</td>\n		</tr>\n		<tr>\n			<td>setPriority()</td>\n			<td>设置线程优先级（1~10）</td>\n			<td>currentThread()</td>\n			<td>获取当前正在执行的线程对象</td>\n		</tr>\n		<tr>\n			<td>setDaemon()</td>\n			<td>标记线程为用户线程</td>\n			<td>dumpStack()</td>\n			<td>打印当前线程的堆栈信息</td>\n		</tr>\n		<tr>\n			<td>join()</td>\n			<td>\n			<p>加入线程。</p>\n\n			<p>例如：线程B中调用了线程A.join()，</p>\n\n			<p>直到线程A执行完毕后，才会继续执行线程B。</p>\n			</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>interrupt()</td>\n			<td>中断线程</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>isAlive()</td>\n			<td>线程是否处于活动状态</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、java.lang.Object</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>notify()</td>\n			<td>唤醒在此对象监视器上等待的单个线程。&nbsp;</td>\n		</tr>\n		<tr>\n			<td>notifyAll()</td>\n			<td>唤醒在此对象监视器上等待的所有线程。&nbsp;</td>\n		</tr>\n		<tr>\n			<td>wait()</td>\n			<td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-01 23:20:50','2019-06-01 23:20:50'),(294386335061274400,'<h1>线程状态</h1>','sys','待编辑','<p><strong>1、线程状态</strong></p>\n\n<ul>\n	<li>初始状态：线程对象被 new 后，就处于初始状态。</li>\n	<li>就绪状态：线程拥有执行资格，正等待系统的调度</li>\n	<li>运行状态：线程获得 CPU 执行资源，正在执行。</li>\n	<li>阻塞状态：线程挂起，阻塞于锁。</li>\n	<li>等待状态：线程等待中，需要被显式地唤醒，否则会无限期等待</li>\n	<li>超时等待：线程等待中，在达到一定时间后，会自动唤醒</li>\n	<li>终止状态：线程执行完毕</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、状态转换</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-017.png\" style=\"height:534px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、状态转换方法</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">调用者</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">对象锁</th>\n			<th scope=\"col\">唤醒</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>Thread.sleep(long millis)</td>\n			<td>当前线程</td>\n			<td><strong>休眠</strong>当前线程</td>\n			<td>不释放</td>\n			<td>millis 毫秒后自动唤醒</td>\n		</tr>\n		<tr>\n			<td>Thread.yield()</td>\n			<td>当前线程</td>\n			<td><strong>让出</strong>执行资源，休眠当前线程</td>\n			<td>不释放</td>\n			<td>由系统进行调度</td>\n		</tr>\n		<tr>\n			<td>\n			<p>thread.join()</p>\n\n			<p>thread.join(long millis)</p>\n			</td>\n			<td>其他线程</td>\n			<td><strong>加入</strong>其他线程，休眠当前线程</td>\n			<td>不释放</td>\n			<td>\n			<p>其他线程执行完后唤醒</p>\n\n			<p>millis 毫秒后自动唤醒</p>\n			</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>\n			<p>obj.wait()</p>\n\n			<p>obj.wait(long millis)</p>\n			</td>\n			<td>锁对象</td>\n			<td>使线程进入<strong>等待</strong>队列</td>\n			<td>释放</td>\n			<td>\n			<p>notify()/notifyAll() 唤醒</p>\n\n			<p>millis 毫秒后自动唤醒</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、sleep()、wait() 区别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">sleep()</th>\n			<th scope=\"col\">wait</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>所属类</td>\n			<td>java.lang.Thread</td>\n			<td>java.lang.Object</td>\n		</tr>\n		<tr>\n			<td>对象锁</td>\n			<td>不释放</td>\n			<td>释放</td>\n		</tr>\n		<tr>\n			<td>使用位置</td>\n			<td>任意地方</td>\n			<td>只能在同步块中使用</td>\n		</tr>\n		<tr>\n			<td>捕获异常</td>\n			<td>需要</td>\n			<td>不需要</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-12 19:09:05','2019-06-12 19:09:05'),(294386335061274600,'<h1>线程池</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>一个容纳了多个线程的容器，里面的线程可以反复使用，避免频繁创建销毁线程。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、组成</strong></p>\n\n<ul>\n	<li>线程池管理器</li>\n	<li>工作线程</li>\n	<li>任务接口</li>\n	<li>任务队列</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、作用</strong></p>\n\n<ul>\n	<li>重用线程，避免频繁创建销毁线程</li>\n	<li>控制线程数量</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、常见线程池</strong></p>\n\n<ul>\n	<li>java.util.concurrent.Executors</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">静态方法</th>\n			<th scope=\"col\">特点</th>\n			<th scope=\"col\">适用场景</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>new<strong>Single</strong>ThreadExecutor()</td>\n			<td>单个线程的固定线程池</td>\n			<td>保证异步执行顺序的场景</td>\n		</tr>\n		<tr>\n			<td>new<strong>Fixed</strong>ThreadPool()&nbsp;</td>\n			<td>固定线程数，无界队列</td>\n			<td>\n			<p>任务数量不均匀的场景</p>\n\n			<p>对内存压力不敏感，但系统负载敏感的场景</p>\n			</td>\n		</tr>\n		<tr>\n			<td>new<strong>Cached</strong>ThreadPool()</td>\n			<td>无限线程数</td>\n			<td>要求低延迟的短期任务场景</td>\n		</tr>\n		<tr>\n			<td>new<strong>Scheduled</strong>ThreadPool()</td>\n			<td>固定线程数，支持定时及周期性任务执行</td>\n			<td>\n			<p>适用于定期执行任务场景</p>\n\n			<p>支持固定频率和固定延迟</p>\n			</td>\n		</tr>\n		<tr>\n			<td>newWorkStealingPool()</td>\n			<td>多个任务队列</td>\n			<td>任务执行时长不均匀的场景</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、线程池参数</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">参数</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>corePoolSize</td>\n			<td>核心线程数，也可理解为最小线程数</td>\n		</tr>\n		<tr>\n			<td>maximumPoolSize</td>\n			<td>最大线程数</td>\n		</tr>\n		<tr>\n			<td>keepaAliveTime</td>\n			<td>非核心线程非活跃存活时间长度</td>\n		</tr>\n		<tr>\n			<td>timeUnit</td>\n			<td>存活时间单位，枚举等</td>\n		</tr>\n		<tr>\n			<td>workQueue</td>\n			<td>阻塞队列</td>\n		</tr>\n		<tr>\n			<td>threadFactory</td>\n			<td>可定制线程，一般使用默认即可</td>\n		</tr>\n		<tr>\n			<td>rejectedHandler</td>\n			<td>线程池满时拒绝策略（Abort、Discard、CallerRuns、DiscardOldest）</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-20 18:10:32','2019-06-20 18:10:32'),(294386335061274624,'<h1>Java 锁</h1>','sys','待编辑','<p><strong>1、悲观锁 / 乐观锁</strong></p>\n\n<ul>\n	<li>乐观锁\n	<ul>\n		<li>很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，</li>\n		<li>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，一般会使用版本号机制或CAS操作实现。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>悲观锁\n	<ul>\n		<li>很悲观，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），</li>\n		<li>当其他线程想要访问数据时，都需要阻塞挂起。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、公平锁 / 非公平锁</strong></p>\n\n<ul>\n	<li>是否按照申请锁的顺序来获取锁的锁</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、可重入锁/不可重入锁</strong></p>\n\n<ul>\n	<li>是否可递归调用（不发生死锁）的锁</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、独享锁 / 共享锁</strong></p>\n\n<ul>\n	<li>是否可以被多个线程共有的锁</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、互斥锁 / 读写锁</strong></p>\n\n<ul>\n	<li>是独享锁/共享锁的具体实现</li>\n	<li>读写锁：\n	<ul>\n		<li>读模式共享，写模式互斥</li>\n		<li>读加锁状态、写加锁状态和不加锁状态</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、自旋锁</strong></p>\n\n<ul>\n	<li>是一种锁机制</li>\n	<li>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试</li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、分段锁</strong></p>\n\n<ul>\n	<li>是一种锁的设计，即分段加锁。</li>\n	<li>如 ConcurrentHashMap 运用的就是分段锁</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、偏向锁 / 轻量级锁 / 重量级锁</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>无锁状态</p>\n\n			<p>偏向锁状态</p>\n\n			<p>轻量级锁状态</p>\n\n			<p>重量级锁状态</p>\n			</td>\n			<td>\n			<p>1、通过对象监视器在对象头中的字段来表明</p>\n\n			<p>2、锁状态会随着竞争的情况逐渐升级，而且不可降级<br>\n			3、不是Java语言中的锁，而是使用synchronized时，JVM为提高锁获取与释放效率所做的优化</p>\n			</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>偏向锁</td>\n			<td>一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</td>\n		</tr>\n		<tr>\n			<td>轻量级锁</td>\n			<td>偏向锁被另一个线程所访问，会升级为轻量级锁。</td>\n		</tr>\n		<tr>\n			<td>重量级锁</td>\n			<td>轻量级锁被另一个线程自旋访问，当自旋一定次数还未获取到锁，就会进入阻塞，该锁升级为重量级锁。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-02 02:30:19','2019-06-02 02:30:19'),(294608688231903232,'<h1>参考资料</h1>','sys','待编辑','<p><strong>1、菜鸟教程-设计模式</strong></p>\n\n<p><a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>\n',0,293465959888220160,'2019-06-01 01:17:19','2019-06-01 01:17:19'),(294608988304994304,'<h1>UML 类图</h1>','sys','待编辑','<p><strong>1、继承、实现</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-022.png\" style=\"height:350px; width:233px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-023.png\" style=\"height:350px; width:257px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、聚合、组合</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-024.png\" style=\"height:350px; width:450px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-025.png\" style=\"height:350px; width:234px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、关联（拥有的关系）、依赖（使用的关系）</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-026.png\" style=\"height:350px; width:271px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-027.png\" style=\"height:350px; width:257px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,293465959888220160,'2019-06-12 19:17:26','2019-06-12 19:17:26'),(294989437271437312,'<h1>同步与互斥</h1>','sys','待编辑','<p><strong>1、概念</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>原子性</td>\n			<td>一个或多个操作，要么全部执行，要么都不执行。</td>\n		</tr>\n		<tr>\n			<td>可见性</td>\n			<td>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</td>\n		</tr>\n		<tr>\n			<td>有序性</td>\n			<td>程序执行的顺序按照代码的先后顺序执行</td>\n		</tr>\n		<tr>\n			<td>指令重排</td>\n			<td>编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段</td>\n		</tr>\n		<tr>\n			<td>内存屏障</td>\n			<td>\n			<p>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</p>\n\n			<p>会强制将对缓存的修改操作立即写入主存</p>\n\n			<p>如果是写操作，它会导致其他CPU中对应的缓存行无效</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、volatile</strong></p>\n\n<ul>\n	<li>是一种比sychronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。</li>\n</ul>\n\n<ul>\n	<li>特性\n	<ul>\n		<li>保证此变量对所有的线程的可见性</li>\n		<li>禁止指令重排优化</li>\n		<li>不保证原子性</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>实现原理：内存屏障</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、synchronized</strong></p>\n\n<ul>\n	<li>修饰代码块或方法，既保证可见性，又保证原子性</li>\n	<li>实现原理：\n	<ul>\n		<li>JVM 基于进入和退出 Monitor 对象来实现对方法、同步块的同步</li>\n		<li>synchronized 用的锁保存在 Java 对象头里。每一个被锁住的对象都会和一个 Monitor 关联</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Lock</strong></p>\n\n<ul>\n	<li>Lock提供了比synchronized更多的功能</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">synchronized</th>\n			<th scope=\"col\">Lock</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>实现层面</td>\n			<td>是一个Java关键字，基于JVM层面实现</td>\n			<td>是一个Java接口，基于JDK层面实现</td>\n		</tr>\n		<tr>\n			<td>释放锁</td>\n			<td>不需要手动释放锁</td>\n			<td>必须要手动释放锁</td>\n		</tr>\n		<tr>\n			<td>锁机制</td>\n			<td>悲观锁机制</td>\n			<td>乐观锁机制</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、无锁编程</strong></p>\n\n<ul>\n	<li>不使用锁的情况下，实现多线程之间的变量同步。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、乐观锁实现机制</strong></p>\n\n<ul>\n	<li>版本号机制\n	<ul>\n		<li>用一版本号字段，记录数据被修改的次数。每修改一次，版本号加一</li>\n		<li>当某一线程要更新数据时，读取数据时同时获得版本号值。在提交更新时，判断这个值与数据库当前值是否相等。</li>\n		<li>相等则更新，否则重试更新操作，直到更新成功。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>CAS 算法\n	<ul>\n		<li>Compare And Swap，是一种无锁算法</li>\n		<li>涉及到三个操作数，数据所在的内存值，预期值，新值。</li>\n		<li>当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试</li>\n		<li>一般情况下是一个自旋操作，即不断的重试。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、乐观锁的缺点</strong></p>\n\n<ul>\n	<li>ABA 问题\n	<ul>\n		<li>CAS 操作中，一个变量初次读取的是 A 值，在准备赋值的时候，检查到它仍然是 A 值。并不一定意味着其他线程没有做更新操作。</li>\n		<li>存在这种情况：在这段时间内，其他线程将 A 值改成 B 值，又改回 A 值，那CAS操作就会误认为它从来没有被修改过。</li>\n		<li>解决：增加一个版本戳\n		<ul>\n			<li>Java中，AtomicStampedReference&lt;V&gt;、AtomicMarkableReference&lt;V&gt;也实现了这个作用</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>循环时间长开销大\n	<ul>\n		<li>自旋 CAS，如果长时间不成功，会给CPU带来非常大的执行开销。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>只能保证单个共享变量的原子操作</li>\n</ul>\n\n<p><br>\n<strong>&nbsp;</strong><br>\n&nbsp;</p>\n',0,289689362567688192,'2019-06-02 22:14:00','2019-06-02 22:14:00'),(295034920635363328,'<h1>死锁</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、产生条件</strong></p>\n\n<ul>\n	<li>互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</li>\n	<li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源</li>\n	<li>请求并保持，当资源请求者在请求其他的资源的同时保持对原有资源的占有</li>\n	<li>环路等待</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,289689362567688192,'2019-06-02 05:53:43','2019-06-02 05:53:43'),(295461332617949184,'<h1>概述</h1>','sys','待编辑','<p><strong>1、JDBC</strong></p>\n\n<ul>\n	<li>Java Data Base Connectivity，java 数据库连接</li>\n	<li>是一种用于执行sql语句的java API，可以为多种关系数据库提供统一访问。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、java.sql.Driver</strong></p>\n\n<ul>\n	<li>数据库驱动接口，由数据库厂商提供具体实现</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、java.sql.DriverManager</strong></p>\n\n<ul>\n	<li>\n	<p>管理一组 JDBC 驱动程序的基本服务</p>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、java.sql.Connection</strong></p>\n\n<ul>\n	<li>与特定数据库的连接（会话），在上下文中执行sql语句并返回结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、java.sql.Statement</strong></p>\n\n<ul>\n	<li>用于执行静态sql语句并返回它所生成结果的对象</li>\n	<li>PreparedStatement\n	<ul>\n		<li>将 SQL 进行预编译，效率更好。当 SQL 重复执行时，数据库会调用以前预编译好的SQL语句。</li>\n		<li>可对 SQL 参数进行强制类型转换，以保证数据格式的一致性;&nbsp;</li>\n	</ul>\n	</li>\n	<li>CallableStatement\n	<ul>\n		<li>用于执行存储过程</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、java.sql.ResultSet</strong></p>\n\n<ul>\n	<li>\n	<p>查询结果集</p>\n	</li>\n</ul>\n',0,295461276368138240,'2019-06-03 10:59:35','2019-06-03 10:59:35'),(295461737594777600,'<h1>步骤</h1>','sys','待编辑','<p><strong>1、加载驱动</strong></p>\n\n<pre><code class=\"language-java\">Class.forName(\"com.mysql.jdbc.Driver\");</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、建立连接</strong></p>\n\n<pre><code class=\"language-java\">String url = \"jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8\";\nString user = \"root\";\nString password = \"root\";\nConnection conn = DriverManager.getConnection(url, user, password);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、创建 Statement</strong></p>\n\n<pre><code class=\"language-java\">String sql =\"SELECT * FROM catalog_info WHERE CATALOG_NAME=?\";\nPreparedStatement prs = conn.prepareStatement(sql);\nprs.setString(1, \"JavaSE\");</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、执行sql语句，获取结果集</strong></p>\n\n<pre><code class=\"language-java\">ResultSet res = prs.executeQuery();\nwhile (res.next()) {\n    System.out.println(res.getLong(\"catalog_id\") + \"--\" + res.getString(\"catalog_name\"));\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、关闭资源</strong></p>\n\n<pre><code class=\"language-java\">res.close();    //关闭 ResultSet\nprs.close();    //关闭 Statement\nconn.close();   //关闭 Connection\n</code></pre>\n\n<p>&nbsp;</p>\n',0,295461276368138240,'2019-06-20 18:31:56','2019-06-20 18:31:56'),(295467467001458688,'<h1>公司</h1>','sys','待编辑','<ul>\n	<li>中软国际</li>\n	<li>软通动力</li>\n	<li>微品致远</li>\n	<li>金证股份</li>\n	<li>金蝶</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><br>\n文思海辉<br>\n武汉佰钧成<br>\n紫川软件<br>\n博奥特科技<br>\n博悦科创</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,287957628796956672,'2019-06-03 10:17:28','2019-06-03 10:17:28'),(296036504924221440,'<h1>类加载过程</h1>','sys','待编辑','<p><img alt=\"类加载过程\" src=\"/furesky/images/201906/20190613-000000-010.png\" style=\"height:231px; width:650px\"></p>\n\n<p><strong>1、加载</strong></p>\n\n<ul>\n	<li>通过一个类的全限定名，获取定义此类的二进制字节流。</li>\n	<li>将这个字节流所代表的静态存储结构，转化为方法区的运行时数据结构。</li>\n	<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区该类各种数据的访问入口。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、验证</strong></p>\n\n<ul>\n	<li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">阶段</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>文件格式验证</td>\n			<td>验证字节流是否符合Class文件格式的规范，确保能被当前虚拟机处理。</td>\n		</tr>\n		<tr>\n			<td>元数据验证</td>\n			<td>对字节码进行语义验证，确保其描述信息符合Java语言规范的要求</td>\n		</tr>\n		<tr>\n			<td>字节码验证</td>\n			<td>通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的</td>\n		</tr>\n		<tr>\n			<td>符号引用验证</td>\n			<td>验证符号引用是否为可用的直接引用，确保解析动作能正确执行。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、准备</strong></p>\n\n<ul>\n	<li>为类变量（静态变量）分配内存，并将其初始化为系统默认值（零值）</li>\n	<li>如果是 final 修饰的类变量，则会直接初始化设定的值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、解析</strong></p>\n\n<ul>\n	<li>将常量池内的符号引用替换为直接引用</li>\n	<li>解析：类或接口、字段、类方法、接口方法<br>\n	&nbsp;</li>\n</ul>\n\n<p><strong>5、初始化</strong></p>\n\n<ul>\n	<li>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</li>\n	<li>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。</li>\n	<li>虚拟机保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td colspan=\"1\">&lt;clinit&gt;()方法</td>\n			<td>\n			<p>1、由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生</p>\n\n			<p>2、虚拟机保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步</p>\n			</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"1\">触发</td>\n			<td>\n			<p>1、当虚拟机启动时，虚拟机会初始化定义了main()方法的主类</p>\n\n			<p>2、当使用 java.lang.reflect 包的方法对类进行反射调用时，会触发类的初始化</p>\n\n			<p>3、当初始化一个类的时候，如果其父类还未初始化，会先触发其父类的初始化。</p>\n\n			<p>4、当遇到new、getstatic、putstatic或invokestatic节码指令时，会触发类的初始化。</p>\n\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; a.使用new关键字实例化对象</p>\n\n			<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;b.访问类的静态变量</p>\n\n			<p>&nbsp; &nbsp; &nbsp; &nbsp; c.访问类的静态方法</p>\n			</td>\n		</tr>\n		<tr>\n			<td>不触发</td>\n			<td>1、访问类的常量<br>\n			2、通过数组定义来引用类<br>\n			3、子类访问父类的静态变量，子类不会被初始化。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,292350110464897024,'2019-06-12 18:59:18','2019-06-12 18:59:18'),(296036518366965760,'<h1>类加载器</h1>','sys','待编辑','<p><strong>1、类加载器</strong></p>\n\n<ul>\n	<li>实现“通过一个类的全限定名来获取描述此类的二进制字节流”动作的代码模块，称为类加载器。</li>\n	<li>相同的字节码被不同的类加载器加载的类不相等。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、加载器类型</strong></p>\n\n<ul>\n	<li>启动类加载器（Bootstrap）\n	<ul>\n		<li>由 C++实现，负责加载 &lt;JAVA_HOME&gt;\\jre\\lib 下面的核心类库</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>扩展类加载器（Extension）\n	<ul>\n		<li>只有一个实例，负责加载&lt;JAVA_HOME&gt;\\lib\\ext 中的类库</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>应用程序类加载器（App）\n	<ul>\n		<li>只有一个实例，负责加载系统环境变量ClassPath或者系统属性java.class.path制定目录下的所有类库</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>用户自定义加载器</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、双亲委派机制</strong></p>\n\n<ol>\n	<li>如果一个类加载器收到了类加载的请求，它会将类加载请求，委派给父类加载器去完成。</li>\n	<li>每一个层类加载器都把类加载请求委派给父类加载器，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中。</li>\n	<li>只有当父类加载器无法完成此加载请求时，子类加载器才会尝试自己去加载。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>优点&nbsp;&nbsp;\n	<ul>\n		<li>可以避免重复加载</li>\n		<li>Java类随着类加载器一起具备了带有优先级的层级关系</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-011.png\" style=\"height:396px; width:600px\"></p>\n\n<p>&nbsp;</p>\n',0,292350110464897024,'2019-06-12 18:59:58','2019-06-12 18:59:58'),(296098866276495360,'<h1>索引</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>索引是对数据库表中一列或多列的值进行排序的一种结构</li>\n	<li>使用索引可快速访问数据库表中的特定信息。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<ul>\n	<li>极大地提高数据的检索速度。</li>\n	<li>加速表和表之间的连接</li>\n	<li>显著减少查询中分组和排序的时间</li>\n	<li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、缺点</strong></p>\n\n<ul>\n	<li>需要额外的磁盘空间来保存索引</li>\n	<li>对于插入、更新、删除等操作，由于更新索引会增加额外的开销</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、索引遵循原则</strong></p>\n\n<ul>\n	<li>最左侧原则：表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据</li>\n	<li>命名短小原则：索引命名过长会使索引文件变大，损耗内存</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、分类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>普通索引</td>\n			<td>最基本的索引，没有任何限制。唯一任务是加快对数据的访问速度。</td>\n		</tr>\n		<tr>\n			<td>唯一索引</td>\n			<td>不允许任意两行具有相同的索引值，允许有空值。</td>\n		</tr>\n		<tr>\n			<td>主键索引</td>\n			<td>\n			<p>一种特殊的唯一索引，在一张表中只能定义一个主键索引，用来标识唯一一条数据。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>全文索引</td>\n			<td>仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间</td>\n		</tr>\n		<tr>\n			<td>联合索引</td>\n			<td>覆盖多个数据列的索引</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、主键索引、唯一索引</strong></p>\n\n<ul>\n	<li>主键索引\n	<ul>\n		<li>主键索引是一种唯一索引，且每张表只能有一个，可以是多个字段的组合。</li>\n		<li>不能为空</li>\n		<li>可作为外键</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>唯一索引\n	<ul>\n		<li>可以为空</li>\n		<li>不可以做外键</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、复合主键、联合主键</strong></p>\n\n<ul>\n	<li>复合主键：一个主键由多个字段组成。</li>\n	<li>联合主键：多个主键联合形成一个主键组合。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、索引实现</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>B-Tree</td>\n			<td>比较适合用作\'&gt;\'或\'&lt;\'这样的范围查询，在MySQL中最为常用</td>\n		</tr>\n		<tr>\n			<td>R-Tree</td>\n			<td>用于处理多维数据的数据结构，可以对地理数据进行空间索引。运用较少</td>\n		</tr>\n		<tr>\n			<td>Hash</td>\n			<td>使用散列表来对数据进行索引。效率高于B-Tree，但是不支持范围查找和排序。运用较少</td>\n		</tr>\n		<tr>\n			<td>FullText</td>\n			<td>全文索引，是一种记录关键字与对应文档关系的倒排索引。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,296098831367303168,'2019-06-05 19:25:23','2019-06-05 19:25:23'),(296115889731694592,'<h1>索引优化</h1>','sys','待编辑','<p><strong>1、建立合适的索引</strong></p>\n\n<ul>\n	<li>索引应建立在区分度高、数据量小的字段上</li>\n	<li>下列情况，应建立索引\n	<ul>\n		<li>外键</li>\n		<li>经常作为查询条件的字段</li>\n		<li>经常与其他表进行连接的字段</li>\n		<li>经常需要排序、分组和联合操作的字段</li>\n		<li>执行频率高（几千次/每天）的语句</li>\n		<li>数据量大（超过300万）的表</li>\n	</ul>\n	</li>\n	<li>对数字的索引效率要优于字符串</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、控制索引的数量</strong></p>\n\n<ul>\n	<li>删除不再使用或者很少使用的索引</li>\n	<li>频繁进行数据更新操作的表，不要建立太多的索引</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、充分利用索引查询，避免全表扫描</strong></p>\n\n<ul>\n	<li>全表扫描：读取表所有数据，检查每一行是否满足给定条件的过程。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">导致索引失效的情况</th>\n			<th scope=\"col\">示例</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>1、使用 null 、not、&lt;&gt;、!=、参数、内置函数</p>\n\n			<p>2、or 拼接非索引字段</p>\n\n			<p>3、like 前模糊匹配，形如‘%abc’</p>\n			</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>\n			<p>4、对索引字段进行操作运算</p>\n\n			<p>5、不符合复合索引的最左前缀匹配原则</p>\n\n			<p>6、查询的数量是大表的大部分（30％以上）</p>\n			</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>7、列与列进行比较</td>\n			<td>例如： select * from test where id=c_id;</td>\n		</tr>\n		<tr>\n			<td>8、数据类型转换，包括显式与隐式</td>\n			<td>\n			<p>例如，字段 name 为字符型</p>\n\n			<p>错误：select * from test where name=123;</p>\n\n			<p>正确：select * from test where name=\'123\';</p>\n			</td>\n		</tr>\n		<tr>\n			<td>9、尽量使用前缀来索引</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,296115674555510500,'2019-06-05 23:59:43','2019-06-05 23:59:43'),(296115911768567808,'<h1>文章1</h1>','sys','待编辑','待编辑',0,296115674555510784,'2019-06-05 05:05:45','2019-06-05 22:06:06'),(296217165312192512,'<h1>表结构优化</h1>','sys','待编辑','<p>1、合理设计表结构</p>\n\n<ul>\n	<li>尽量将表字段定义为NOT NULL约束</li>\n	<li>单表不要有太多字段，建议在20以内</li>\n	<li>VARCHAR 的只分配真正需要的空间</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、选取最适用的字段属性，优先最简单的数据类型</p>\n\n<ul>\n	<li>尽量使用数字型字段</li>\n	<li>尽量使用 VARCHAR 代替 CHAR&nbsp;</li>\n	<li>尽量使用 TIMESTAMP 代替 DATETIME</li>\n	<li>尽量使用 TINYINT、SMALLINT、MEDIUMINT 代替 INT</li>\n	<li>对于特定类型字段，可用enum、set 等符合的数据类型</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>3、将字段多的表分解成多个表，增加中间表。</p>\n\n<p>4、混用范式与反范式，适当冗余</p>\n\n<ul>\n	<li><strong>第一范式</strong>：数据表中每个字段都必须是不可拆分的最小单元</li>\n	<li><strong>第二范式</strong>：满足一范式后，要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。</li>\n	<li><strong>第三范式</strong>：满足二范式后，要求所有属性必须直接依赖主键，不允许间接依赖。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>5、分库分表，读写分离</p>\n\n<ul>\n	<li>垂直分表（按列）</li>\n	<li>水平分表（按行）\n	<ul>\n		<li>按时间分表</li>\n		<li>按区间分表</li>\n		<li>按hash分表</li>\n	</ul>\n	</li>\n</ul>\n',0,296115674555510600,'2019-06-06 00:48:33','2019-06-06 00:48:33'),(296327047415754752,'<h1>SQL语句优化</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>避免使用双引号，用单引号代替</p>\n\n			<p>避免使用 *，用具体列名代替</p>\n\n			<p>避免使用 in，用 exist 代替</p>\n			</td>\n			<td>\n			<pre><code class=\"language-sql\">select num from a where num in(select num from b);\nselect num from a where exists(select 1 from b where num=a.num);</code></pre>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>尽量使用UNION ALL代替UNION</p>\n\n			<p>尽量使用预编译：性能更好、防止SQL注入</p>\n			</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>尽量少做重复的工作</td>\n			<td>控制同一语句的多次执行<br>\n			减少多次的数据转换<br>\n			杜绝不必要的子查询和连接表<br>\n			合并对同一表同一条件的多次UPDATE<br>\n			UPDATE操作不要拆成DELETE操作+INSERT操作的形式<br>\n			不要写一些没有意义的查询</td>\n		</tr>\n		<tr>\n			<td>尽量避免耗时操作</td>\n			<td>DISTINCT、UNION、MINUS、INTERSECT、ORDER BY</td>\n		</tr>\n		<tr>\n			<td>\n			<p>尽量避免使用游标</p>\n\n			<p>尽量避免使用临时表</p>\n\n			<p>尽量避免大事务操作</p>\n\n			<p>尽量避免向客户端返回大数据量</p>\n			</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>\n			<p>分析 sql 语句</p>\n			</td>\n			<td>\n			<p>寻找最需要优化的SQL语句：分析慢查询日志</p>\n\n			<p>利用分析工具：Explain、Profile。</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,296115674555510500,'2019-06-06 00:15:11','2019-06-06 00:15:11'),(296420466381189120,'<h1>初始化顺序</h1>','sys','待编辑','<p><strong>1、各种结构</strong></p>\n\n<pre><code class=\"language-java\">public class Test{\n    //静态属性：只初始化一次\n    private static float PI = 3.14f;\n    \n    //静态代码块：只初始化一次\n    static {\n        //...\n    }\n	\n    //成员属性\n    private int id = 1;\n	\n    //构造代码块：提取构造方法中的相同部分，减少重复代码\n    {\n    	//每次对象实例化，都执行一次\n    }\n	\n    //构造函数\n    public Test() {\n    	//...\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、初始化顺序</strong></p>\n\n<ul>\n	<li>静态属性 --&gt; 静态代码块 --&gt; 成员属性 --&gt; 构造代码块&nbsp; --&gt; 构造函数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、子类初始化顺序</strong></p>\n\n<ul>\n	<li>规则一：先静态后非静态</li>\n	<li>规则二：先父类后子类</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-000000-021.png\" style=\"height:464px; width:400px\"></p>\n',0,283963875107172352,'2019-06-12 19:13:36','2019-06-12 19:13:36'),(296446572719140854,'<h1>笔试题-1</h1>','sys','待编辑','<p>1、哪两个可以在A的子类中使用？</p>\n\n<pre><code>class A {\n    protected int method(int a,int b) {\n        return 0;\n    }\n}\n\nA、public int method(int a,int b) {return 0;}\nB、private int method(int a,int b) {return 0;}\nC、private int method(int a,long b) {return 0;}\nD、public short method(int a,int b) {return 0;}</code></pre>\n\n<pre><code>解答：AC\n\n主要考查子类重写父类的方法的原则\nB，子类重写父类的方法，访问权限不能降低\nC，属于重载\nD，子类重写父类的方法 返回值类型要相同或是父类方法返回值类型的子类</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2、运行结果是？</p>\n\n<pre><code>class Base {\n    void test(){\n        System.out.println(\"Base.test()\");\n    }\n}\npublic class Child extends Base{\n    void test(){\n        System.out.println(\"Child.test()\");\n    }\n    public static void main(String[] args) {\n        Child anObj=new Child();\n        Base baseObj=(Base) anObj;\n        baseObj.test();\n    }\n}</code></pre>\n\n<pre><code>解答：Child.test()\n\n测试代码相当于：Base baseObj = new Child();\n父类的引用指向子类的实例，子类又重写了父类的test方法，因此调用子类的test方法。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>3、运行结果是？</p>\n\n<pre><code>class Base {\n    static void test(){\n        System.out.println(\"Base.test()\");\n    }\n}\npublic class Child extends Base{\n    void test(){\n        System.out.println(\"Child.test()\");\n        Base.test();\n    }\n    public static void main(String[] args) {\n        new Child().test();        \n    }\n}</code></pre>\n\n<pre><code>解答：Compilation error.Cannot override a static method by an instance method.\n\n静态方法不能在子类中被重写</code></pre>\n\n<p>&nbsp;</p>\n\n<p>4、运行结果是？</p>\n\n<pre><code>public class Test {\n    public static void main(String[] argc) throws Exception{\n        System.out.println(6+6+\"(result)\");\n    }\n}</code></pre>\n\n<pre><code>解答：12(result)\n\n字符串与基本数据类型链接的问题\n字符串之后，才按字符串处理</code></pre>\n\n<p>&nbsp;</p>\n\n<p>5、运行结果是？</p>\n\n<pre><code>public class Base {\n    private void test(){\n        String aStr=\" One \";\n        String bStr=aStr;\n        aStr.toUpperCase();\n        aStr.trim();    \n        System.out.println(\"[\"+aStr+\",\"+bStr+\"]\");\n    }\n    public static void main(String[] args) {\n        new Base().test();\n    }\n}</code></pre>\n\n<pre><code>解答：[ One , One ]\n\n通过String bStr = aStr;这句代码使bStr和aStr指向同一个地址空间，所以最后aStr和bStr的结果应该是一样，\nString类是定长字符串，调用一个字符串的方法以后会形成一个新的字符串。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>6、下列说法错误的是？</p>\n\n<pre><code>A．实例变量是类的成员变量\n\nB．实例变量用关键字static声明\n\nC．在方法中定义的局部变量在该方法被执行时创建\n\nD．局部变量在使用前必须被初始化</code></pre>\n\n<pre><code>解答：BC\n\n由static修饰的变量称为类变量或是静态变量\n方法加载的时候创建局部变量</code></pre>\n\n<p>&nbsp;</p>\n\n<p>7、下列说法错误的是？</p>\n\n<pre><code>A．abstract不能与final并列修饰同一个类\n\nB．abstract类中可以有private的成员\n\nC．abstract方法必须在abstract类中\n\nD．static方法中能处理非static的属性</code></pre>\n\n<pre><code>解答：D\n\n静态方法中不能引用非静态的成员</code></pre>\n\n<p>&nbsp;</p>\n\n<p>8、下列说法正确的是？</p>\n\n<pre><code>关于int[] x=new int[25];\n\nA、x[24]为0\nB、x[24]未定义\nC、x[25]为0\nD、x[0]为空</code></pre>\n\n<pre><code>解答：A\n\nx属于引用类型，该引用类型的每一个成员是int类型，默认值为：0</code></pre>\n\n<p>&nbsp;</p>\n\n<p>9、运行结果是？</p>\n\n<pre><code>public class Test {\n    public static void main(String[] argc){\n        int x=4;\n        System.out.println(\"value is \"+((x&gt;4)?99.9:9));\n    }\n}\nA、 输出结果为：value is 99.99\nB、 输出结果为：value is 9\nC、 输出结果为：value is 9.0\nD、 编译错误</code></pre>\n\n<pre><code>解答：value is 9.0\n\n三目运算符中：第二个表达式和第三个表达式中如果都为基本数据类型，整个表达式的运算结果由容量高的决定。\n99.9是double类型 而9是int类型，double容量高。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>10、运行结果是？</p>\n\n<pre><code>public class Test {\n    static int x=10;\n    static {x+=5;}   //1\n    public static void main(String[] argc){\n        System.out.println(\"x=\"+x);\n    }\n    static{x/=3;}    //2\n}\n\nA、 1 与 2 不能通过编译，因为缺少方法名和返回类型\nB、 2 不能通过编译，因为只能有一个静态初始化器\nC、 编译通过，执行结果为：x=5\nD、 编译通过，执行结果为：x=3</code></pre>\n\n<pre><code>解答：C\n\n静态代码块是类加载的时候就会被执行到的，并按照在类中出现的先后顺序执行。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>11、运行结果是？</p>\n\n<pre><code>public class Test {\n    private static int x=100;\n    public static void main(String[] argc){\n        Test t1=new Test();\n        t1.x++;\n        Test t2=new Test();\n        t2.x++;\n        t1=new Test();\n        t1.x++;\n        Test.x--;\n        System.out.println(\"x=\"+x);\n    }\n}</code></pre>\n\n<pre><code>解答：x=102\n\n静态变量是所有对象所共享的，所以上述代码中的几个对象操作是同一静态变量x， 静态变量可以通过类名调用。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>12、下列说法正确的是？</p>\n\n<pre><code>A． class中的constructor不可省略\n\nB． constructor必须与class同名，但方法不能与class同名\n\nC． constructor在一个对象被new时执行\n\nD． 一个class只能定义一个constructor</code></pre>\n\n<pre><code>解答：C\n\n构造方法的作用是在实例化对象的时候给数据成员进行初始化\nA．类中如果没有显示的给出构造方法，系统会提供一个无参构造方法\nB．构造方法与类同名，类中可以有和类名相同的方法\nD．构造方法可以重载</code></pre>\n\n<p>&nbsp;</p>\n\n<p>13、下列说法正确的是？</p>\n\n<pre><code>A．实例方法可直接调用超类的实例方法\n\nB．实例方法可直接调用超类的类方法\n\nC．实例方法可直接调用其他类的实例方法\n\nD．实例方法可直接调用本类的类方法</code></pre>\n\n<pre><code>解答：D\n\nA. 实例方法不可直接调用超类的私有实例方法\nB. 实例方法不可直接调用超类的私有的类方法\nC．要看访问权限</code></pre>\n\n<p>&nbsp;</p>\n\n<p>14、下列说法正确的是？</p>\n\n<pre><code>A． abstract修饰符可修饰字段、方法和类\n\nB． 抽象方法的body部分必须用一对大括号{ }包住\n\nC． 声明抽象方法，大括号可有可无\n\nD． 声明抽象方法不可写出大括号</code></pre>\n\n<pre><code>解答：D\n\nabstract可以修饰方法和类，不能修饰属性。抽象方法没有方法体，即没有大括号{}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>15、运行结果是？</p>\n\n<pre><code>public class Test {\n    public static void main(String[] argc){\n        Set&lt;Short&gt; t=new HashSet&lt;&gt;();\n        for (short i = 0; i &lt; 100; i++) {\n            t.add(i);\n            t.remove(i-1);\n        }\n        System.out.println(t.size());\n    }\n}\n\nA.1\nB.100\nC.Throws Exception\nD.None of the Above</code></pre>\n\n<pre><code>解答：B\n\ni是Short类型 i-1是int类型,其包装类为Integer，所以s.remove(i-1);不能移除Set集合中Short类型对象。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>16、链表具有的特点是？(选择3项)</p>\n\n<pre><code>A、不必事先估计存储空间\n\nB、可随机访问任一元素\n\nC、插入删除不需要移动元素\n\nD、所需空间与线性表长度成正比</code></pre>\n\n<pre><code>解答：ACD\n\nA.采用动态存储分配，不会造成内存浪费和溢出。\nB. 不能随机访问，查找时要从头指针开始遍历\nC. 插入、删除时，只要找到对应前驱结点，修改指针即可，无需移动元素\nD. 需要用额外空间存储线性表的关系，存储密度小</code></pre>\n\n<p>&nbsp;</p>\n\n<p>17、Java语言中，String 类的 indexOf() 方法返回的类型是？</p>\n\n<pre><code>A、Int16\nB、Int32\nC、int\nD、long</code></pre>\n\n<pre><code>解答：C\n\nindexOf方法的声明为：public int indexOf(int ch)\n在此对象表示的字符序列中第一次出现该字符的索引；如果未出现该字符，则返回 -1。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>18、下列说法错误的是？</p>\n\n<pre><code>A.在现实生活中，对象是指客观世界的实体\n\nB.程序中的对象就是现实生活中的对象\n\nC.在程序中，对象是通过一种抽象数据类型来描述的，这种抽象数据类型称为类（class）\n\nD.在程序中，对象是一组变量和相关方法的集合</code></pre>\n\n<pre><code>解答：B</code></pre>\n\n<p>&nbsp;</p>\n\n<p>19、下列说法正确的是？</p>\n\n<pre><code>执行String[] s=new String[10];\n\nA、s[9]为null\nB、s[10]为\"\"\nC、s[0]为未定义\nD、s.length为10</code></pre>\n\n<pre><code>解答：AD\n\ns是引用类型，s中的每一个成员都是引用类型，即String类型，String类型默认的值为null\ns数组的长度为10。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>20、属性的可见性有？(选择3项)</p>\n\n<pre><code>A.公有的\n\nB.私有的\n\nC.私有保护的\n\nD.保护的</code></pre>\n\n<pre><code>解答：ABD\n\n属性的可见性有四种：公有的public、保护的protected、默认的、私有的private</code></pre>\n\n<p>&nbsp;</p>\n',0,283963385795473408,'2019-07-17 07:33:00','2019-07-17 07:33:00'),(296446572719140864,'<h1>笔试题-2</h1>','sys','待编辑','<p>1、在字符串前面加上_____符号，则字符串中的转义字符将不被处理。(选择1项)</p>\n\n<pre><code>A. <span class=\"hljs-decorator\">@</span>\n\nB. \\\n\nC. <span class=\"hljs-comment\">#</span>\n\nD. %</code></pre>\n\n<pre><code>解答：B</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2、对记录序列{314，298，508，123，486，145}按从小到大的顺序进行插入排序，经过两趟排序后的结果为：(选择1项)</p>\n\n<pre><code><span class=\"hljs-tag\">A</span> <span class=\"hljs-rules\">{<span class=\"hljs-rule\">314，298，508，123，145，486}</span></span>\n\n<span class=\"hljs-tag\">B</span> <span class=\"hljs-rules\">{<span class=\"hljs-rule\">298，314，508，123，486，145}</span></span>\n\n<span class=\"hljs-tag\">C</span> <span class=\"hljs-rules\">{<span class=\"hljs-rule\">298，123，314，508，486，145}</span></span>\n\n<span class=\"hljs-tag\">D</span> <span class=\"hljs-rules\">{<span class=\"hljs-rule\">123、298，314，508，486，145}</span></span></code></pre>\n\n<pre><code>解答：B\n\n插入排序算法：\n    把n个待排序的元素看成一个有序表和一个无序表。开始时有序表中只有一个元素，无序表中有n-<span class=\"hljs-number\">1</span>个元素；\n    排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表\n    重复n-<span class=\"hljs-number\">1</span>次完成整个排序过程。\n\n示例代码：\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">injectionSort</span>(<span class=\"hljs-keyword\">int</span>[] number) {\n    <span class=\"hljs-comment\">// 第一个元素作为一部分，对后面的部分进行循环</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt; number.length; j++) {\n        <span class=\"hljs-keyword\">int</span> tmp = number[j];\n        <span class=\"hljs-keyword\">int</span> i = j – <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">while</span> (tmp &lt; number[i]) {\n            number[i + <span class=\"hljs-number\">1</span>] = number[i];\n            i–;\n            <span class=\"hljs-keyword\">if</span> (i == -<span class=\"hljs-number\">1</span>)\n                <span class=\"hljs-keyword\">break</span>;\n        }\n        number[i + <span class=\"hljs-number\">1</span>] = tmp;\n    }\n}\n\n示例：\n<span class=\"hljs-number\">0.</span>初始状态 <span class=\"hljs-number\">3</span>，<span class=\"hljs-number\">1</span>，<span class=\"hljs-number\">5</span>，<span class=\"hljs-number\">7</span>，<span class=\"hljs-number\">2</span>，<span class=\"hljs-number\">4</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">6</span>（共<span class=\"hljs-number\">8</span>个数）\n    有序表：<span class=\"hljs-number\">3</span>；无序表：<span class=\"hljs-number\">1</span>，<span class=\"hljs-number\">5</span>，<span class=\"hljs-number\">7</span>，<span class=\"hljs-number\">2</span>，<span class=\"hljs-number\">4</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">1.</span>第一次循环，从无序表中取出第一个数 <span class=\"hljs-number\">1</span>，把它插入到有序表中，使新的数列依旧有序\n    有序表：<span class=\"hljs-number\">1</span>，<span class=\"hljs-number\">3</span>；无序表：<span class=\"hljs-number\">5</span>，<span class=\"hljs-number\">7</span>，<span class=\"hljs-number\">2</span>，<span class=\"hljs-number\">4</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">2.</span>第二次循环，从无序表中取出第一个数 <span class=\"hljs-number\">5</span>，把它插入到有序表中，使新的数列依旧有序\n    有序表：<span class=\"hljs-number\">1</span>，<span class=\"hljs-number\">3</span>，<span class=\"hljs-number\">5</span>；无序表：<span class=\"hljs-number\">7</span>，<span class=\"hljs-number\">2</span>，<span class=\"hljs-number\">4</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">6</span></code></pre>\n\n<p>&nbsp;</p>\n\n<p>3、栈是一种？</p>\n\n<pre><code>A 存取受限的线性结构\n\nB 存取不受限的线性结构\n\nC 存取受限的非线性结构\n\nD 存取不受限的非线性结构</code></pre>\n\n<pre><code>解答：A\n\n栈（<span class=\"hljs-built_in\">stack</span>）在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>4、下列说法正确的是？</p>\n\n<pre><code>A、程序员必须创建一个线程来释放内存\n\nB、内存回收程序负责释放无用内存\n\nC、内存回收程序允许程序员直接释放内存\n\nD、内存回收程序可以在指定的时间释放内存对象</code></pre>\n\n<pre><code>解答：B\n\n垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，即使程序员能明确地判断出有一块内存已经无用了，是应该回收的，程序员也不能强制垃圾收集器回收该内存块。程序员唯一能做的就是通过调用System.gc 方法来”建议”执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>5、运行结果是？</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(String[] argc){\n    Object obj=<span class=\"hljs-keyword\">new</span> Object(){\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hashCode</span>(){\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>;\n        }\n    };\n    System.<span class=\"hljs-keyword\">out</span>.println(obj.hashCode());\n}</code></pre>\n\n<pre><code>解答：<span class=\"hljs-number\">42</span>\n\n匿名内部类覆盖<span class=\"hljs-built_in\">hash</span>Code方法。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>6、Which two are reserved words in the Java programming language?&nbsp;</p>\n\n<pre><code>A. run\n\nB. <span class=\"hljs-keyword\">import</span>\n\nC. <span class=\"hljs-keyword\">default</span>\n\nD. implements</code></pre>\n\n<pre><code>解答：BD\n\n<span class=\"hljs-keyword\">import</span>导入包的保留字，implements实现接口的保留字。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>7、Which two statements are true regarding the return values of property written hashCodeand equals methods from two instances of the same class?</p>\n\n<pre><code>A. If the <span class=\"hljs-built_in\">hash</span>Code values are different, the objects might be equal.\n\nB. If the <span class=\"hljs-built_in\">hash</span>Code values are the same, the object must be equal.\n\nC. If the <span class=\"hljs-built_in\">hash</span>Code values are the same, the objects might be equal.\n\nD. If the <span class=\"hljs-built_in\">hash</span>Code values are different, the objects must be unequal.</code></pre>\n\n<pre><code>解答：CD\n\n先通过 hashcode来判断某个对象是否存放某个桶里，但这个桶里可能有很多对象，那么我们就需要再通过 equals 来在这个桶里找到我们要的对象。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>8、What is the numerical range of a char?</p>\n\n<pre><code>A. <span class=\"hljs-number\">0</span> … <span class=\"hljs-number\">32767</span>\n\nB. <span class=\"hljs-number\">0</span> … <span class=\"hljs-number\">65535</span>\n\nC. –<span class=\"hljs-number\">256</span> … <span class=\"hljs-number\">255</span>\n\nD. –<span class=\"hljs-number\">32768</span> … <span class=\"hljs-number\">32767</span>\n\nE. Range <span class=\"hljs-keyword\">is</span> platform dependent.</code></pre>\n\n<pre><code>解答：B\n\n在Java中，<span class=\"hljs-keyword\">char</span>是一个无符号<span class=\"hljs-number\">16</span>位类型，取值范围为<span class=\"hljs-number\">0</span>到<span class=\"hljs-number\">65535</span>。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>9、运行结果是？</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> Test {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">float</span>[] f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">float</span>[<span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(String args[]) {\n        System.<span class=\"hljs-keyword\">out</span>.println(“f[<span class=\"hljs-number\">0</span>] = “ + f[<span class=\"hljs-number\">0</span>]);\n    }\n}</code></pre>\n\n<pre><code>解答：f[0] = 0.0</code></pre>\n\n<p>&nbsp;</p>\n\n<p>10、运行结果是？</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> Test {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(String[] args) {\n        String str = NULL;\n        System.<span class=\"hljs-keyword\">out</span>.println(str);\n    }\n}\n\nA. NULL\nB. Compilation fails.\nC. The code runs with no output.\nD. An exception <span class=\"hljs-keyword\">is</span> thrown at runtime.</code></pre>\n\n<pre><code>解答：B\n\n<span class=\"hljs-keyword\">null</span>应该小写</code></pre>\n\n<p>&nbsp;</p>\n\n<p>11、运行结果是？</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">X</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span> {</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> x;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> y;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(String [] args) {\n        X that = <span class=\"hljs-keyword\">new</span> X();\n        (<span class=\"hljs-keyword\">new</span> Thread(that)).start();\n        (<span class=\"hljs-keyword\">new</span> Thread(that)).start();    <span class=\"hljs-comment\">//1</span>\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span>( ){\n        <span class=\"hljs-keyword\">for</span> (;;) {\n            x++;    <span class=\"hljs-comment\">//2</span>\n            y++;\n            System.out.println(“x = “ + x + “, y = “ + y);\n        }\n    }\n}\n\nA. An error at line <span class=\"hljs-number\">2</span> causes compilation to fail.\n\nB. Errors at lines <span class=\"hljs-number\">1</span> cause compilation to fail.\n\nC. The program prints pairs of values <span class=\"hljs-keyword\">for</span> x and y that might not always be the same on the same line (<span class=\"hljs-keyword\">for</span> example, “x=<span class=\"hljs-number\">2</span>, y=<span class=\"hljs-number\">1</span>”)\n\nD. The program prints pairs of values <span class=\"hljs-keyword\">for</span> x and y that are always the same on the same line (<span class=\"hljs-keyword\">for</span> example, “x=<span class=\"hljs-number\">1</span>, y=<span class=\"hljs-number\">1</span>”. In addition, each value appears twice (<span class=\"hljs-keyword\">for</span> example, “x=<span class=\"hljs-number\">1</span>, y=<span class=\"hljs-number\">1</span>” followed by “x=<span class=\"hljs-number\">1</span>, y=<span class=\"hljs-number\">1</span>”)\n\nE. The program prints pairs of values <span class=\"hljs-keyword\">for</span> x and y that are always the same on the same line (<span class=\"hljs-keyword\">for</span> example, “x=<span class=\"hljs-number\">1</span>, y=<span class=\"hljs-number\">1</span>”. In addition, each value appears twice (<span class=\"hljs-keyword\">for</span> example, “x=<span class=\"hljs-number\">1</span>, y=<span class=\"hljs-number\">1</span>” followed by “x=<span class=\"hljs-number\">2</span>, y=<span class=\"hljs-number\">2</span>”)</code></pre>\n\n<pre><code>解答：E\n\n多线程共享相同的数据，使用<span class=\"hljs-keyword\">synchronized</span>实现数据同步。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>12、Which two CANNOT directly cause a thread to stop executing? (Choose Two)</p>\n\n<pre><code>A. Existing <span class=\"hljs-keyword\">from</span> a synchronized block.\n\nB. Calling the wait method on an <span class=\"hljs-keyword\">object</span>.\n\nC. Calling notify method on an <span class=\"hljs-keyword\">object</span>.\n\nD. Calling read method on an InputStream <span class=\"hljs-keyword\">object</span>.\n\nE. Calling the SetPriority method on a Thread <span class=\"hljs-keyword\">object</span>.</code></pre>\n\n<pre><code>解答：AD\n\nstop方法.这个方法将终止所有未结束的方法，包括run方法。当一个线程停止时候，他会立即释放所有他锁住对象上的锁。这会导致对象处于不一致的状态。 当线程想终止另一个线程的时候，它无法知道何时调用stop是安全的，何时会导致对象被破坏。所以这个方法被弃用了。你应该中断一个线程而不是停止他。被中断的线程会在安全的时候停止。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>13、Which two statements are true regarding the creation of a default constructor? (Choose Two)</p>\n\n<pre><code>A. The <span class=\"hljs-reserved\">default</span> constructor initializes method variables.\n\nB. The <span class=\"hljs-reserved\">default</span> constructor invokes the <span class=\"hljs-literal\">no</span>-parameter constructor <span class=\"hljs-keyword\">of</span> the superclass.\n\nC. The <span class=\"hljs-reserved\">default</span> constructor initializes the instance variables declared <span class=\"hljs-keyword\">in</span> the <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.</span>\n\nD. If a <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">lacks</span> <span class=\"hljs-title\">a</span> <span class=\"hljs-title\">no</span>-<span class=\"hljs-title\">parameter</span> <span class=\"hljs-title\">constructor</span>, <span class=\"hljs-title\">but</span> <span class=\"hljs-title\">has</span> <span class=\"hljs-title\">other</span> <span class=\"hljs-title\">constructors</span>, <span class=\"hljs-title\">the</span> <span class=\"hljs-title\">compiler</span> <span class=\"hljs-title\">creates</span> <span class=\"hljs-title\">a</span> <span class=\"hljs-title\">default</span> <span class=\"hljs-title\">constructor</span>.</span>\n\nE. The compiler creates a <span class=\"hljs-reserved\">default</span> constructor only <span class=\"hljs-keyword\">when</span> there are <span class=\"hljs-literal\">no</span> other constructors <span class=\"hljs-keyword\">for</span> the <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.</span></code></pre>\n\n<pre><code>解答：CE\n\n构造方法的作用是实例化对象的时候给数据成员初始化，如果类中没有显示的提供构造方法，系统会提供默认的无参构造方法，如果有了其它构造方法，默认的构造方法不再提供。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>14、Which two inner class declarations are valid? (Choose Two)</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> OuterClass {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> d1 = <span class=\"hljs-number\">1.0</span>;\n    <span class=\"hljs-comment\">//insert code here</span>\n}\n\nA. <span class=\"hljs-keyword\">static</span> class InnerOne { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">methoda</span>() {<span class=\"hljs-keyword\">return</span> d1;} }\nB. <span class=\"hljs-keyword\">static</span> class InnerOne { <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> methoda() {<span class=\"hljs-keyword\">return</span> d1;} }\nC. <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">class</span> InnerOne { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">methoda</span>() {<span class=\"hljs-keyword\">return</span> d1;} }\nD. <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">class</span> InnerOne { <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> methoda() {<span class=\"hljs-keyword\">return</span> d1;} }\nE. <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> InnerOne { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">methoda</span>(); }</code></pre>\n\n<pre><code>解答：CE\n\nAB.内部类可以声明为<span class=\"hljs-keyword\">static</span>的，但此时就不能再使用外层封装类的非<span class=\"hljs-keyword\">static</span>的成员变量；\nD.非<span class=\"hljs-keyword\">static</span>的内部类中的成员不能声明为<span class=\"hljs-keyword\">static</span>的，只有在顶层类或<span class=\"hljs-keyword\">static</span>的内部类中才可声明<span class=\"hljs-keyword\">static</span>成员</code></pre>\n\n<p>&nbsp;</p>\n\n<p>15、&nbsp;Which two declarations prevent the overriding of a method? (Choose Two)</p>\n\n<pre><code>A. <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> methoda() {}\n\nB. <span class=\"hljs-keyword\">void</span> <span class=\"hljs-keyword\">final</span> methoda() {}\n\nC. <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> methoda() {}\n\nD. <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> methoda() {}\n\nE. <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> methoda() {}</code></pre>\n\n<pre><code>解答：AD\n\n<span class=\"hljs-keyword\">final</span>修饰方法，在子类中不能被重写。\nB.返回类型<span class=\"hljs-keyword\">void</span>应该紧挨着方法名.\nC.没有<span class=\"hljs-keyword\">final</span>\nE.<span class=\"hljs-keyword\">final</span>和<span class=\"hljs-keyword\">abstract</span>不能同时用.</code></pre>\n\n<p>&nbsp;</p>\n\n<p>16、运行结果是？</p>\n\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> Test {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span> (String args[]) {\n        class Foo {\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>;\n        }\n        Object o = (Object) <span class=\"hljs-keyword\">new</span> Foo();\n        Foo foo = (Foo)o;\n        System.<span class=\"hljs-keyword\">out</span>.println(foo.i);\n    }\n}\n\nA. Compilation will fail.\nB. Compilation will succeed and the program will print “<span class=\"hljs-number\">3</span>”\nC. Compilation will succeed but the program will <span class=\"hljs-keyword\">throw</span> a ClassCastException at line <span class=\"hljs-number\">6.</span>\nD. Compilation will succeed but the program will <span class=\"hljs-keyword\">throw</span> a ClassCastException at line <span class=\"hljs-number\">7.</span></code></pre>\n\n<p>&nbsp;</p>\n\n<p>17、运行结果是？</p>\n\n<pre><code>public class Test {\n    public static void main (String [] args) {\n        String foo = “blue”;\n        String bar = foo;\n        foo = “green”;\n        System.out.println(bar);\n    }\n}\n\nA. An exception is thrown.\nB. The code will not compile.\nC. The program prints “null”\nD. The program prints “blue”\nE. The program prints “green”</code></pre>\n\n<pre><code>解答：D\n\n采用String foo = “blue”定义方式定义的字符串放在字符串池中，通过String bar = foo;\n他们指向了同一地址空间，就是同一个池子，当执行foo = “green”; foo指向新的地址空间。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>18、Which code determines the int value foo closest to a double value bar?</p>\n\n<pre><code>A. int foo = (int) Math.max(bar);\n\nB. int foo = (int) Math.min(bar);\n\nC. int foo = (int) Math.abs(bar);\n\nD. int foo = (int) Math.ceil(bar);\n\nE. int foo = (int) Math.floor(bar);\n\nF. int foo = (int) Math.round(bar);</code></pre>\n\n<pre><code>解答：DEF\n\nA B两个选项方法是用错误，都是两个参数。\nabs方法是取bar的绝对值，\nceil方法返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。\nfloor方法返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。\nround方法 返回最接近参数的 long。</code></pre>\n\n<p>&nbsp;</p>\n\n<p>19、The file MyNewVector.java is shown in the exhibit. What is the result?</p>\n\n<pre><code>private class MyVector extends Vector {    //A\n    int i = 1;\n    public MyVector() {\n        i = 2;    //B\n    }\n}\npublic class MyNewVector extends MyVector {    //C\n    public MyNewVector () {\n        i = 4;\n    }\n    public static void main (String args []) {\n        MyVector v = new MyNewVector();    //D\n    }\n}\n\nA. Compilation will succeed.\nB. Compilation will fail at line A.\nC. Compilation will fail at line B.\nD. Compilation will fail at line C.\nE. Compilation will fail at line D.</code></pre>\n\n<pre><code>解答：B\n\n类MyVector不能是私有的</code></pre>\n\n<p>&nbsp;</p>\n\n<p>20、Which command line invocation will produce the output?</p>\n\n<pre><code>public class Test {\n    public static void main (String[]args) {\n        String foo = args[1];\n        String bar = args[2];\n        String baz = args[3];\n        System.out.println(“baz = ” + baz);\n    }\n}\nAnd the output:\nBaz = 2\n\nA. java Test 2222\nB. java Test 1 2 3 4\nC. java Test 4 2 4 2\nD. java Test 4 3 2 1</code></pre>\n\n<pre><code>解答：C\n\n数组下标从0开始</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,283963385795473408,'2019-07-17 09:53:16','2019-07-17 09:53:16'),(296446572719140874,'<h1>笔试题</h1>','sys','待编辑','<p>1、运行结果是？</p>\n\n<pre><code class=\"language-java\">class A{\n    public A(){\n        System.out.print(\" a1 --&gt;\");\n    }\n    {\n        System.out.print(\" a2 --&gt;\");\n    }\n    static {\n        System.out.print(\" a3 --&gt;\");\n    }\n}\n\nclass B extends A{\n    public B(){\n        System.out.print(\" b1 --&gt;\");\n    }\n    {\n        System.out.print(\" b2 --&gt;\");\n    }\n    static {\n        System.out.print(\" b3 --&gt;\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new B();\n    }\n}\n/***********************************************************/\n\n\na3 --&gt; b3 --&gt; a2 --&gt; a1 --&gt; b2 --&gt; b1 --&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>2、运行结果是？</p>\n\n<pre><code class=\"language-java\">public class Example{\n    Object obj=new String(\"good\");\n    char[] ch={\'a\',\'b\',\'c\'};\n    List&lt;String&gt; list=new ArrayList&lt;String&gt;(){\n        {\n            add(\"1\");\n            add(\"2\");\n        }\n    };    \n    public void change(Object obj,char[] ch,List&lt;String&gt; list) {\n        obj=\"123\";\n        ch[0]=\'g\';\n        list=new ArrayList&lt;&gt;();\n        list.add(\"ok\");                \n    }\n    public static void main(String[] args) {\n        Example ex=new Example();\n        ex.change(ex.obj+\" and \", ex.ch, ex.list);\n        System.out.println(ex.obj+\" and \"+ex.list+\" and \"+Arrays.toString(ex.ch));\n    }\n}\n/***********************************************************/\n\n\ngood and [1, 2] and [g, b, c]</code></pre>\n\n<p>&nbsp;</p>\n\n<p>3、运行结果是？</p>\n\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        BigInteger one=new BigInteger(\"1\");\n        BigInteger two=new BigInteger(\"2\");\n        BigInteger three=new BigInteger(\"3\");\n        BigInteger sum=new BigInteger(\"0\");\n        sum.add(one);\n        sum.add(two);\n        sum.add(three);\n        System.out.println(sum.toString());\n    }\n}\n/***********************************************************/\n\n\n0</code></pre>\n\n<p><br>\n&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,283963385795473408,'2019-07-17 07:18:30','2019-07-17 07:18:30'),(298207466939641856,'<h1>企凡OA系统</h1>','sys','待编辑','<p>待编辑</p>\n',0,287960981564190720,'2019-06-10 23:44:32','2019-06-10 23:44:32'),(298207597588017152,'<h1>五洲天美商城</h1>','sys','待编辑','<p>待编辑</p>\n',0,287960981564190720,'2019-06-10 23:44:01','2019-06-10 23:44:01'),(298207745407873024,'<h1>玉柴车联</h1>','sys','待编辑','<p>2016.5-2017.6，南宁市企凡信息技术有限公司</p>\n\n<p>项目介绍：</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;玉柴车联是为玉柴货车司机、厂商、运营商提供的运营服务管理平台，主要功能如下</p>\n\n<ul>\n	<li>位置服务：车辆分组，车辆查询</li>\n	<li>财产无忧：客户管理，合同管理，借款还款管理，防拆管理，车辆控制，控制提醒</li>\n	<li>维修无忧：故障库，保养策略，保养历史，车辆故障</li>\n	<li>运管无忧：报警提醒，车辆报表导出</li>\n	<li>运营管理：车辆信息导入，终端号、SIM卡、车辆、车主管理</li>\n	<li>系统管理：角色权限，字典管理，用户管理</li>\n</ul>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n<p><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;页面采用Html、CSS、JQuery等技术，后台使用spring、mybatis、springMvc等技术</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>从需求分析、接口文档编写，到数据库设计、功能代码实现，到最后的测试与上线部署。熟练的掌握了一些项目开发的基本技能。</p>\n',0,287960981564190720,'2019-06-18 23:13:59','2019-06-18 23:13:59'),(298207951008460800,'<h1>CATTC微信公众号</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,287960981564190720,'2019-06-10 23:43:05','2019-06-10 23:43:05'),(298422943871836160,'<h1>Linux 简介</h1>','sys','待编辑','<p><strong>1、Linux</strong></p>\n\n<ul>\n	<li>是一个开源、免费的操作系统。</li>\n	<li>其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、常见的操作系统</strong></p>\n\n<ul>\n	<li>Windows、IOS、Android、Mac</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Linux 与 Unix</strong></p>\n\n<p><img alt=\"20190615-051710-010.png\" src=\"/furesky/images/201906/20190615-051710-010.png\" style=\"height:358px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、启动过程</strong></p>\n\n<ul>\n	<li>内核的引导</li>\n	<li>运行 init</li>\n	<li>系统初始化</li>\n	<li>建立终端&nbsp;</li>\n	<li>用户登录系统</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-060147-010.png\" style=\"height:197px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,298772070904274944,'2019-06-16 00:27:08','2019-06-16 00:27:08'),(298425871529582592,'<h1>新建虚拟机</h1>','sys','待编辑','<p><strong>1、VMware 安装</strong></p>\n\n<ul>\n	<li>略</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、新建虚拟机</strong></p>\n\n<ul>\n	<li>步骤 1</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-001.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-002.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 2</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-003.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-004.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 3</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-005.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-006.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 4</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-007.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-008.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 5</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-009.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-010.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 6</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-011.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-012.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>结果</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-013.png\" style=\"height:512px; width:485px\"><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-014.png\" style=\"height:512px; width:485px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>步骤 2</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-034645-015.png\" style=\"height:618px; width:970px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,298889203055239000,'2019-06-14 21:12:01','2019-06-12 20:07:34'),(298425871529582800,'<h1>安装 Linux</h1>','sys','待编辑','<p><strong>1、CentOS 资源</strong></p>\n\n<ul>\n	<li><a href=\"https://wiki.centos.org/Download\">https://wiki.centos.org/Download</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、图形化界面</strong></p>\n\n<ul>\n	<li>&nbsp;<a href=\"https://www.runoob.com/linux/linux-install.html\">https://www.runoob.com/linux/linux-install.html</a>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、命令行界面</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-010.png\" style=\"height:341px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-020.png\" style=\"height:284px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-030.png\" style=\"height:346px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-040.png\" style=\"height:489px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-050.png\" style=\"height:364px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-060.png\" style=\"height:380px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>一直Next，到如下界面</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-070.png\" style=\"height:346px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>设置名称</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-080.png\" style=\"height:182px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>设置时区</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-090.png\" style=\"height:339px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>设置 root 用户密码</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-100.png\" style=\"height:218px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>自定义分区</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-110.png\" style=\"height:332px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>创建如下分区</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-120.png\" style=\"height:277px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-130.png\" style=\"height:308px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-140.png\" style=\"height:183px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-150.png\" style=\"height:423px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-160.png\" style=\"height:265px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>重启</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-045041-170.png\" style=\"height:320px; width:600px\"></p>\n',0,298889203055239000,'2019-06-14 21:12:03','2019-06-12 21:52:57'),(298425871529582900,'<h1>网络配置</h1>','sys','待编辑','<p><strong>一、虚拟机网络配置方式</strong></p>\n\n<ul>\n	<li>桥接模式\n	<ul>\n		<li>都在同一个网段，相互间可以通讯</li>\n		<li>ip地址有限，可能造成ip冲突</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>NAT模式\n	<ul>\n		<li>虚拟机不占用其他的ip</li>\n		<li>内网的其他人不能和虚拟机通讯</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>主机模式\n	<ul>\n		<li>单独的一台电脑，封闭的网络</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>二、桥接无线网</strong></p>\n\n<p><strong>1、环境</strong></p>\n\n<ul>\n	<li>虚拟机：VMware</li>\n	<li>Linux版本：CentOS 64位</li>\n	<li>主机网络：无线wifi</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、主机网络信息</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-001.png\" style=\"height:290px; margin-left:40px; margin-right:40px; width:450px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、VMware 设置</strong></p>\n\n<ul>\n	<li>编辑 --&gt; 虚拟网络编辑器</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-002.png\" style=\"height:382px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、虚拟机设置</strong></p>\n\n<ul>\n	<li>设置为桥接模式</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-003.png\" style=\"height:229px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>设置虚拟机网络\n	<ul>\n		<li>vi /etc/sysconfig/network-scripts/ifcfg-eth0\n		<ul>\n			<li>删除UUID和MAC地址</li>\n			<li>更改配置</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-004.png\" style=\"height:273px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>删除旧网络文件\n	<ul>\n		<li>rm -f /etc/udev/rules.d/70-persistent-net.rules</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-005.png\" style=\"height:71px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li>设置虚拟机显示名称（可选）\n	<ul>\n		<li>vi&nbsp;/etc/sysconfig/network</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>重启\n	<ul>\n		<li>init 6</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、测试结果</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-041053-006.png\" style=\"height:107px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n',0,298889203055239000,'2019-06-14 21:28:17','2019-06-14 21:28:17'),(298884949565415424,'<h1>克隆节点</h1>','sys','待编辑','<p><strong>1、创建快照</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-010.png\" style=\"height:258px; width:700px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-020.png\" style=\"height:480px; width:700px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、克隆快照</strong></p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-030.png\" style=\"height:416px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-040.png\" style=\"height:416px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-050.png\" style=\"height:416px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190613-043341-070.png\" style=\"height:416px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置节点信息</strong></p>\n\n<ul>\n	<li>配置 IP 信息</li>\n	<li>配置节点名称\n	<ul>\n		<li>vi /etc/sysconfig/network</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,298889203055239000,'2019-06-14 21:12:05','2019-06-12 21:36:13'),(298910140098060288,'<h1>Linux 目录结构</h1>','sys','待编辑','<p><strong>1、在 Linux 世界里，一切皆文件</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Linux 目录结构</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">目录</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/bin</span></strong></td>\n			<td>Binary，常用命令文件目录。</td>\n		</tr>\n		<tr>\n			<td>/sbin</td>\n			<td>Super User Binary，超级用户的命令文件目录。</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#c0392b\"><strong>/boot</strong></span></td>\n			<td>存放的是启动Linux时使用的一些核心文件</td>\n		</tr>\n		<tr>\n			<td>/dev&nbsp;</td>\n			<td>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/etc</span></strong></td>\n			<td>系统配置文件目录</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#c0392b\"><strong>/home</strong></span></td>\n			<td>普通用户的家目录</td>\n		</tr>\n		<tr>\n			<td>/lib</td>\n			<td>库文件目录</td>\n		</tr>\n		<tr>\n			<td>/lost+found</td>\n			<td>存放系统非法关机后产生的文件</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/media</span></strong></td>\n			<td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/mnt</span></strong></td>\n			<td>挂载点目录，为了让用户临时挂载别的文件系统</td>\n		</tr>\n		<tr>\n			<td>/opt</td>\n			<td>第三方软件的安装目录。默认为空。</td>\n		</tr>\n		<tr>\n			<td>/proc</td>\n			<td>是一个虚拟目录，它是系统内存的映射。</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/root</span></strong></td>\n			<td>root用户的家目录</td>\n		</tr>\n		<tr>\n			<td>/srv</td>\n			<td>service，该目录存放一些服务启动之后需要提取的数据。</td>\n		</tr>\n		<tr>\n			<td>/sys</td>\n			<td>系统硬件的映射文件</td>\n		</tr>\n		<tr>\n			<td>/tmp</td>\n			<td>临时文件目录</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#c0392b\"><strong>/usr</strong></span></td>\n			<td>默认的用户软件安装目录，类似与windows下的program files目录。</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#c0392b\"><strong>/usr/local</strong></span></td>\n			<td>用户软件安装目录。一般是存放通过编译源码方式安装的程序</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#c0392b\">/var</span></strong></td>\n			<td>经常变化的文件（如日志）目录</td>\n		</tr>\n	</thead>\n</table>\n\n<p><br>\n&nbsp;</p>\n',0,298772070904274944,'2019-06-14 22:23:56','2019-06-14 22:23:56'),(299174945551720448,'<h1>vi / vim</h1>','sys','待编辑','<p><strong>1、vi / vim</strong></p>\n\n<ul>\n	<li>vi：\n	<ul>\n		<li>是一个 Unix 内建的文本编辑器</li>\n	</ul>\n	</li>\n	<li>vim：\n	<ul>\n		<li>具有程序编辑的能力，是 vi 的增强版本</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、进入 vi</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>vi</td>\n			<td>打开文件</td>\n		</tr>\n		<tr>\n			<td>vi +n</td>\n			<td>打开文件，并定位于第 n 行&nbsp;</td>\n		</tr>\n		<tr>\n			<td>vi +</td>\n			<td>打开文件，定位至最后一行</td>\n		</tr>\n		<tr>\n			<td>vi +/pattern</td>\n			<td>打开文件，定位至 pattern 首次匹配的行的行首</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、退出 vi</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">模式</th>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"6\">末行模式</td>\n			<td>:q</td>\n			<td>退出没有动过的文件</td>\n		</tr>\n		<tr>\n			<td>:q!</td>\n			<td>强制退出</td>\n		</tr>\n		<tr>\n			<td>:w</td>\n			<td>保存</td>\n		</tr>\n		<tr>\n			<td>:w!</td>\n			<td>强制保存</td>\n		</tr>\n		<tr>\n			<td>:wq</td>\n			<td>强制保存并退出</td>\n		</tr>\n		<tr>\n			<td>:x</td>\n			<td>保存并退出</td>\n		</tr>\n		<tr>\n			<td>命令模式</td>\n			<td>ZZ</td>\n			<td>保存并退出</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、命令模式 --&gt; 输入模式</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">i</td>\n			<td>在当前光标所在字符的前面</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">a</td>\n			<td>在当前光标所在字符的后面</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">o</td>\n			<td>在当前光标所在行的下方，新建一行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Shift+o</td>\n			<td>在当前光标所在行的上方，新建一行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Shift+i</td>\n			<td>在当前光标所在行的行首</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Shift+a</td>\n			<td>在当前光标所在行的行尾</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、模式转换</strong></p>\n\n<ul>\n	<li>命令模式</li>\n	<li>输入模式</li>\n	<li>末行命令模式</li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/20190613/20190614-013707-010.png\" style=\"height:322px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p><br>\n&nbsp;</p>\n',0,298889203055239095,'2019-06-15 20:15:49','2019-06-14 22:38:12'),(299215102929707008,'<h1>命令模式</h1>','sys','待编辑','<p><strong>1、移动光标</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">步进</th>\n			<th scope=\"col\" style=\"text-align:center\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"2\">字符</td>\n			<td style=\"text-align:center\">h&nbsp; &nbsp; j&nbsp; &nbsp; k&nbsp; &nbsp; l</td>\n			<td>左、下、上、右</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">←&nbsp; ↓&nbsp; &nbsp; ↑&nbsp; &nbsp;→</td>\n			<td>左、下、上、右</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"3\">单词</td>\n			<td style=\"text-align:center\">w</td>\n			<td>移至下一个单词的词首</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">e</td>\n			<td>跳至当前或下一个单词的词尾</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">b</td>\n			<td>跳至当前或前一个单词的词首</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"3\">行内</td>\n			<td style=\"text-align:center\">0</td>\n			<td>绝对行首</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">^</td>\n			<td>行首的第一个非空白字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">$</td>\n			<td>绝对行尾</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"3\">行间</td>\n			<td style=\"text-align:center\">G</td>\n			<td>文章末尾</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">nG</td>\n			<td>第 n 行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">gg</td>\n			<td>文章开头</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"2\">页</td>\n			<td style=\"text-align:center\">Ctrl+f</td>\n			<td>向下翻页</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Ctrl+b</td>\n			<td>向上翻页</td>\n		</tr>\n	</thead>\n</table>\n\n<p><br>\n<strong>2、删除</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">x</td>\n			<td>向后删除一个字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Shift+x</td>\n			<td>向前删除一个字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">nx</td>\n			<td>向后删除 n 个字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">dd</td>\n			<td>删除当前行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">ndd</td>\n			<td>向后删除 n 行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">d1G</td>\n			<td>删除当前行，及之前的所有行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">dG</td>\n			<td>删除当前行，及之后的所有行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">d0</td>\n			<td>删除游标所在处，到该行的最前一个字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">d$</td>\n			<td>删除游标所在处，到该行的最后一个字符</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、复制</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">yy</td>\n			<td>复制所在行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">nyy</td>\n			<td>复制光标所在的向下 n 行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">y1G</td>\n			<td>复制当前行，及之前的所有行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">yG</td>\n			<td>复制当前行，及之后的所有行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">y0</td>\n			<td>复制游标所在处，到该行的最前一个字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">y$</td>\n			<td>复制游标所在处，到该行的最后一个字符</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、粘贴、替换、撤销、重做</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">p</td>\n			<td>在当前行之后，粘贴已复制的内容</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Shift+p</td>\n			<td>在当前行之前，粘贴已复制的内容</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">r</td>\n			<td>替换光标位置字符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">u</td>\n			<td>撤销</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">Ctrl+r</td>\n			<td>重做所撤销的操作</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>.</strong></td>\n			<td>小数点，重做</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n',0,298889203055239095,'2019-06-15 20:15:50','2019-06-14 02:41:52'),(299227459714195456,'<h1>末行命令模式</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、set 设置</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">\n			<p>命令</p>\n			</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>set：设置</p>\n\n<ul>\n	<li>set nu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number</li>\n	<li>set nonu&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonumber</li>\n	<li>set readonly</li>\n</ul>\n\n<p><br>\n/：查找</p>\n\n<ul>\n	<li>/after</li>\n	<li>n，N</li>\n	<li>？向上查找</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>！：执行命令</p>\n\n<ul>\n	<li>:!ls -l /</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>s查找并替换</p>\n\n<ul>\n	<li>s/str1/str2/gi\n	<ul>\n		<li>/：临近s命令的第一个字符为边界字符：/，@，#</li>\n		<li>g：一行内全部替换</li>\n		<li>i：忽略大小写</li>\n	</ul>\n	</li>\n	<li>范围\n	<ul>\n		<li>n：行号</li>\n		<li>.：当前光标行</li>\n		<li>+n：偏移n行</li>\n		<li>$：末尾行，$-3</li>\n		<li>%：全文</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,298889203055239095,'2019-06-15 20:15:52','2019-06-13 19:20:33'),(299299140205977600,'<h1>HTML 简介</h1>','sys','待编辑','<p><strong>1、HTML</strong></p>\n\n<ul>\n	<li><strong>超文本标记语言</strong>，Hyper Text Markup Language</li>\n	<li>是一种描述网页的语言，代码由标签组成</li>\n	<li>不需编译，直接由浏览器执行</li>\n	<li>文件以html、htm为后缀</li>\n	<li>不区分大小写</li>\n	<br>\n	&nbsp;\n</ul>\n\n<p><strong>2、HTML 文档</strong></p>\n\n<ul>\n	<li>即网页，包含 HTML 标签和纯文本</li>\n</ul>\n\n<pre><code class=\"language-xhtml\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;         \n        &lt;title&gt;标题&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        网页正文\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、HTML 声明</strong></p>\n\n<ul>\n	<li>&lt;!DOCTYPE html&gt;</li>\n	<li>声明必须放在HTML文档第一行</li>\n	<li>声明不是HTML标签</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、HTML 标签</strong></p>\n\n<ul>\n	<li>由尖括号包围关键词，比如：&lt;html&gt;</li>\n	<li>通常是成对出现，比如：&lt;b&gt;&lt;/b&gt;</li>\n	<li>单标签，比如：&lt;br/&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、HTML 元素</strong></p>\n\n<ul>\n	<li>从&nbsp;开始标签&nbsp;到&nbsp;结束标签&nbsp;的所有代码。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、HTML 属性</strong></p>\n\n<ul>\n	<li>在开始标签中规定，以名称/值对的形式出现</li>\n	<li>例如：&lt;p name=\"value\"&gt;xxx&lt;/p&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、HTML 注释</strong></p>\n\n<ul>\n	<li>&lt;!-- 在此处写注释 --&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-10-29 16:04:00','2019-10-29 16:04:00'),(299299155032842240,'<h1>HTML 段落</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、内容标签</strong></p>\n\n<ul>\n	<li>标题：&lt;h1&gt;...&lt;h6&gt;</li>\n	<li>段落：&lt;p&gt;</li>\n	<li>换行：&lt;br/&gt;</li>\n	<li>水平线：&lt;hr/&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、修饰标签</strong></p>\n\n<ul>\n	<li>斜体：&lt;i&gt;、&lt;em&gt;</li>\n	<li>加粗：&lt;b&gt;、&lt;strong&gt;</li>\n	<li>上标：&lt;sup&gt;</li>\n	<li>下标：&lt;sub&gt;</li>\n	<li>插入：&lt;ins&gt;</li>\n	<li>删除：&lt;del&gt;</li>\n	<li>预格式：&lt;pre&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、转义字符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">转义字符</th>\n			<th scope=\"col\">字符</th>\n			<th scope=\"col\">转义字符</th>\n			<th scope=\"col\">字符</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>&amp;nbsp;</td>\n			<td>Space</td>\n			<td>&amp;quot;</td>\n			<td>\"</td>\n		</tr>\n		<tr>\n			<td>&amp;lt;</td>\n			<td>&lt;</td>\n			<td>&amp;trade;</td>\n			<td>™ 商标</td>\n		</tr>\n		<tr>\n			<td>&amp;gt;</td>\n			<td>&gt;</td>\n			<td>&amp;reg;</td>\n			<td>® 注册</td>\n		</tr>\n		<tr>\n			<td>&amp;amp;</td>\n			<td>&amp;</td>\n			<td>&amp;copy;</td>\n			<td>© 版权</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-06-14 04:20:55','2019-06-14 00:13:01'),(299299167624142848,'<h1>HTML 列表</h1>','sys','待编辑','<h3><strong>&lt;ul&gt;</strong></h3>\n\n<ul>\n	<li>无序列表，unordered list</li>\n	<li>列表项：&lt;li&gt;</li>\n	<li>属性：type（disc、square、circle）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;ol&gt;</strong></h3>\n\n<ul>\n	<li>有序列表，ordered list</li>\n	<li>列表项：&lt;li&gt;</li>\n	<li>属性：type（1、a、A、ⅰ、Ⅰ）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;dl&gt;</strong></h3>\n\n<ul>\n	<li>定义列表，definition list</li>\n	<li>列表项：&lt;dt&gt;</li>\n	<li>列表项描述：&lt;dd&gt;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<pre><code class=\"language-xhtml\">&lt;ul&gt;\n    &lt;li&gt;Coffee&lt;/li&gt;\n    &lt;li&gt;Milk&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ol&gt;\n    &lt;li&gt;Coffee&lt;/li&gt;\n    &lt;li&gt;Milk&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;dl&gt;\n    &lt;dt&gt;Coffee&lt;/dt&gt;\n        &lt;dd&gt;Black hot drink&lt;/dd&gt;\n    &lt;dt&gt;Milk&lt;/dt&gt;\n        &lt;dd&gt;White cold drink&lt;/dd&gt;\n&lt;/dl&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-06-14 04:20:53','2019-06-14 00:16:01'),(299299181343711232,'<h1>HTML 链接</h1>','sys','待编辑','<h3><strong>URL</strong></h3>\n\n<pre><code class=\"language-xhtml\">//.     代表当前网页所在目录，可省略\n//..	代表当前网页所在目录的上一级目录\n\n//绝对路径\n&lt;img src=\"D:/html/img.jpg\" /&gt;\n\n//相对路径\n&lt;img src=\"../img.jpg\" /&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;img&gt;</strong></h3>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">示例</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>src</td>\n			<td>图像的URL</td>\n			<td colspan=\"1\" rowspan=\"4\">&lt;img src=\"xxx.jpg\" alt=\"xxx\" width=\"40\" height=\"40\" /&gt;</td>\n		</tr>\n		<tr>\n			<td>alt</td>\n			<td>图像的替代文本</td>\n		</tr>\n		<tr>\n			<td>width</td>\n			<td>图像的宽</td>\n		</tr>\n		<tr>\n			<td>height</td>\n			<td>图像的高</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;a&gt;</strong></h3>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">&nbsp;</th>\n		</tr>\n		<tr>\n			<td>href</td>\n			<td>链接地址</td>\n			<td>Hypertext Reference</td>\n		</tr>\n		<tr>\n			<td>target</td>\n			<td>在何处打开链接</td>\n			<td>_self、_blank、_top、_parent</td>\n		</tr>\n		<tr>\n			<td>title</td>\n			<td>链接提示文字</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>name</td>\n			<td>链接名称</td>\n			<td>&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-xhtml\">//链接到资源\n&lt;a href=\"https://www.baidu.com/\" /&gt;\n&lt;a href=\"../xxx.html\" /&gt;\n&lt;a href=\"../xxx.rar\" /&gt;\n\n//链接到邮件\n&lt;a href=\"mailto:xxx@qq.com\" /&gt;\n\n//定义锚点\n&lt;a name=\"mark\" /&gt;\n\n//链接到锚点\n&lt;a href=\"#mark\" /&gt;\n&lt;a href=\"../xxx.html#&gt;mark\" /&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-06-14 04:20:51','2019-06-14 04:20:30'),(299299195923111936,'<h1>HTML 表格</h1>','sys','待编辑','<p><strong>1、表格</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">标签</th>\n			<th scope=\"col\">标签含义</th>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\" rowspan=\"7\"><strong>&lt;table&gt;</strong></td>\n			<td rowspan=\"7\">表格</td>\n			<td>width</td>\n			<td>表格宽度</td>\n		</tr>\n		<tr>\n			<td>border</td>\n			<td>边框宽度</td>\n		</tr>\n		<tr>\n			<td>cellspacing</td>\n			<td>单元格间距</td>\n		</tr>\n		<tr>\n			<td>cellpadding</td>\n			<td>单元格与内容间距</td>\n		</tr>\n		<tr>\n			<td>frame</td>\n			<td>外侧边框，可见样式</td>\n		</tr>\n		<tr>\n			<td>rules</td>\n			<td>内侧边框，可见样式</td>\n		</tr>\n		<tr>\n			<td>summary</td>\n			<td>摘要</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;tr&gt;</strong></td>\n			<td>行</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"2\"><strong>&lt;td&gt;</strong></td>\n			<td colspan=\"1\" rowspan=\"2\">单元格</td>\n			<td>colspan</td>\n			<td>单元格横跨几列</td>\n		</tr>\n		<tr>\n			<td>rowspan</td>\n			<td>单元格横跨几行</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;th&gt;</strong></td>\n			<td>表头单元格</td>\n			<td>同&lt;td&gt;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;caption&gt;</strong></td>\n			<td>表格标题</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;thead&gt;&nbsp;</strong></td>\n			<td>表格页眉&nbsp;</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;tbody&gt;</strong></td>\n			<td>表格主体</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td><strong>&lt;tfoot&gt;</strong></td>\n			<td>表格页脚</td>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、公共属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\" rowspan=\"5\">水平对齐：align</td>\n			<td>left</td>\n			<td>左对齐（默认）</td>\n		</tr>\n		<tr>\n			<td>right</td>\n			<td>右对齐</td>\n		</tr>\n		<tr>\n			<td>center</td>\n			<td>居中对齐</td>\n		</tr>\n		<tr>\n			<td>justify</td>\n			<td>拉伸对齐</td>\n		</tr>\n		<tr>\n			<td>char</td>\n			<td>对齐指定字符</td>\n		</tr>\n		<tr>\n			<td colspan=\"1\" rowspan=\"4\">垂直对齐：valign</td>\n			<td>top</td>\n			<td>顶部对齐（默认）</td>\n		</tr>\n		<tr>\n			<td>middle</td>\n			<td>居中对齐</td>\n		</tr>\n		<tr>\n			<td>bottom</td>\n			<td>底部对齐</td>\n		</tr>\n		<tr>\n			<td>baseline</td>\n			<td>基线对齐</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<pre><code class=\"language-xhtml\">&lt;table border=\"1\" width=\"70%\" cellspacing=\"0\"&gt;\n    &lt;caption&gt;表格标题&lt;/caption&gt; \n    &lt;tr&gt;\n        &lt;th&gt;北京&lt;/th&gt;\n        &lt;th&gt;上海&lt;/th&gt;\n        &lt;th&gt;广州&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;...&lt;/td&gt;\n        &lt;td&gt;...&lt;/td&gt;\n        &lt;td&gt;...&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-06-14 04:20:49','2019-06-14 03:03:41'),(299299209462325248,'<h1>HTML 表单</h1>','sys','待编辑','<h3><strong>&lt;form&gt;</strong></h3>\n\n<ul>\n	<li>定义供用户输入的 HTML 表单</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">描述</th>\n			<th scope=\"col\">值</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>name</td>\n			<td>名称</td>\n			<td><em>form_name</em></td>\n		</tr>\n		<tr>\n			<td>action</td>\n			<td>提交目的地</td>\n			<td>URL</td>\n		</tr>\n		<tr>\n			<td>method</td>\n			<td>提交方式</td>\n			<td>get、post</td>\n		</tr>\n		<tr>\n			<td>target</td>\n			<td>打开方式</td>\n			<td>_blank&nbsp;<br>\n			_self&nbsp;<br>\n			_parent&nbsp;<br>\n			_top&nbsp;<br>\n			<em>frame_name</em></td>\n		</tr>\n		<tr>\n			<td>enctype</td>\n			<td>编码方式</td>\n			<td>application/x-www-form-urlencoded&nbsp;<br>\n			multipart/form-data&nbsp;<br>\n			text/plain</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;input&gt;</strong></h3>\n\n<ul>\n	<li>定义输入控件</li>\n	<li>属性：name、value、size、type</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">type值</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">备注</th>\n		</tr>\n		<tr>\n			<td>text</td>\n			<td>文本域</td>\n			<td rowspan=\"2\">最大长度：maxlength&nbsp;<br>\n			提示文字：placeholder</td>\n		</tr>\n		<tr>\n			<td>password</td>\n			<td>密码域</td>\n		</tr>\n		<tr>\n			<td>radio</td>\n			<td>单选框</td>\n			<td rowspan=\"2\">选中选项：checked</td>\n		</tr>\n		<tr>\n			<td>checkbox</td>\n			<td>复选框</td>\n		</tr>\n		<tr>\n			<td>button</td>\n			<td>按钮</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>reset</td>\n			<td>重置按钮</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>submit</td>\n			<td>提交按钮（文本）</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>image</td>\n			<td>提交按钮（图片）</td>\n			<td>见&lt;imge&gt;</td>\n		</tr>\n		<tr>\n			<td>file</td>\n			<td>上传文件</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>hidden</td>\n			<td>隐藏域</td>\n			<td>&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;select&gt;</strong></h3>\n\n<ul>\n	<li>定义选择列表（下拉列表）</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>name</td>\n			<td>名称</td>\n		</tr>\n		<tr>\n			<td>size</td>\n			<td>可选数量</td>\n		</tr>\n		<tr>\n			<td>multiple</td>\n			<td>是否多选</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">子标签</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">&nbsp;</th>\n		</tr>\n		<tr>\n			<td>&lt;option&gt;</td>\n			<td>下拉选项</td>\n			<td>选中状态：selected&nbsp;<br>\n			选项的值：vule</td>\n		</tr>\n		<tr>\n			<td>&lt;optgroup&gt;</td>\n			<td>选项分组</td>\n			<td>分组描述：label</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>&lt;textarea&gt;</strong></h3>\n\n<ul>\n	<li>定义多行的文本输入控件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>name</td>\n			<td>名称</td>\n		</tr>\n		<tr>\n			<td>rows</td>\n			<td>可见行数</td>\n		</tr>\n		<tr>\n			<td>cols</td>\n			<td>可见宽度</td>\n		</tr>\n		<tr>\n			<td>placeholder</td>\n			<td>提示文字</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>示例</strong></h3>\n\n<pre><code class=\"language-xhtml\">&lt;form action=\"xxx.php\" method=\"get\"&gt;\n    姓名：&lt;input type=\"text\" name=\"username\" size=\"15\" placeholder=\"请输入姓名\" /&gt;\n    密码：&lt;input type=\"password\" name=\"pwd\" maxlength=\"8\" placeholder=\"请输入密码\" /&gt;\n    照片：&lt;input type=\"file\" name=\"pic\" /&gt;\n\n    性别：\n    &lt;input type=\"radio\" name=\"sex\" value=\"man\" checked/&gt;男\n    &lt;input type=\"radio\" name=\"sex\" value=\"woman\" /&gt;女\n\n    爱好：\n    &lt;input type=\"checkbox\" name=\"hobby\" value=\"read\" checked/&gt;读书\n    &lt;input type=\"checkbox\" name=\"hobby\" value=\"dance\" /&gt; 跳舞\n    &lt;input type=\"checkbox\" name=\"hobby\" value=\"sing\" /&gt; 唱歌\n\n    城市:\n    &lt;select name=\"city\"&gt;\n        &lt;option value=\"0\" selected&gt;__请选择__&lt;/option&gt;\n        &lt;optgroup label=\"北方\"&gt;\n            &lt;option value=\"bj\"&gt;北京&lt;/option&gt;\n            &lt;option value=\"tj\"&gt;天津&lt;/option&gt;\n        &lt;/optgroup&gt;\n        &lt;optgroup label=\"南方\"&gt;\n            &lt;option value=\"gz\"&gt;广州&lt;/option&gt;\n            &lt;option value=\"sz\"&gt;深圳&lt;/option&gt;\n        &lt;/optgroup&gt;\n    &lt;/select&gt;\n    \n    备注：\n    &lt;textarea name=\"tips\" cols=\"5\" rows=\"5\"&gt;\n        这是一段多行文字\n    &lt;/textarea&gt;\n&lt;/form&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,299298744272068608,'2019-06-14 04:20:47','2019-06-14 01:08:09'),(299321212386844672,'<h1>CSS 概述</h1>','sys','待编辑','<p><strong>1、CSS</strong></p>\n\n<ul>\n	<li><strong>层叠样式表</strong>，Cascading Style Sheets</li>\n	<li>简化网页代码，提高页面浏览速度</li>\n	<li>使网页内容与表现相分离</li>\n	<li>降低网页维护成本</li>\n	<li>提高工作效率</li>\n	<br>\n	<li>&nbsp;</li>\n</ul>\n\n<p><strong>2、CSS 继承</strong></p>\n\n<ul>\n	<li>html子元素，会继承其父元素的CSS样式</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、CSS 层叠</strong></p>\n\n<ul>\n	<li>HTML同一元素，可以定义多个样式</li>\n	<li>样式不冲突时，多个样式效果可叠加</li>\n	<li>样式冲突时，按样式的优先级来显示</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、CSS 语法</strong></p>\n\n<ul>\n	<li>CSS规则，由选择器、声明组成</li>\n	<li>注释：/*注释语句*/</li>\n</ul>\n\n<p><img alt=\"20190614-100230-010.png\" src=\"/furesky/images/201906/20190614-100230-010.png\" style=\"height:119px; width:350px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、CSS 引入</strong></p>\n\n<ul>\n	<li>外部样式表</li>\n	<li>内部样式表</li>\n	<li>内联样式</li>\n</ul>\n\n<pre><code class=\"language-xml\">//外部样式表：在网页头部引入\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"XXX.css\"&gt;\n&lt;/head&gt;\n\n\n//内部样式表：在网页头部，定义样式表\n&lt;head&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {color:red;}\n        ...\n    &lt;/style&gt;\n&lt;/head&gt;\n\n\n//内联颜色表：在相关标签内，定义style属性\n&lt;p style=\"color:red;\"&gt;这是一个段落。&lt;/p&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,299318043602755584,'2019-06-14 04:18:34','2019-06-14 03:39:46'),(299332289996693504,'<h1>CSS 单位</h1>','sys','待编辑','<p><strong>1、尺寸：size</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">值</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">备注</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>%</td>\n			<td>百分比</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>in</td>\n			<td>英寸</td>\n			<td>\n			<p>25.4 mm</p>\n			</td>\n		</tr>\n		<tr>\n			<td>cm</td>\n			<td>厘米</td>\n			<td>\n			<p>10 mm</p>\n			</td>\n		</tr>\n		<tr>\n			<td>mm</td>\n			<td>毫米</td>\n			<td>\n			<p>1 mm</p>\n			</td>\n		</tr>\n		<tr>\n			<td>pt</td>\n			<td>磅/点，Point</td>\n			<td>\n			<p>0.35 mm</p>\n			</td>\n		</tr>\n		<tr>\n			<td>pc</td>\n			<td>派卡，Pica</td>\n			<td>\n			<p>4.23 mm</p>\n			</td>\n		</tr>\n		<tr>\n			<td>px</td>\n			<td>像素，Pixel</td>\n			<td>\n			<p>&nbsp;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>em</td>\n			<td>当前字体尺寸的倍数</td>\n			<td>\n			<p>1em = 16px（默认）</p>\n			</td>\n		</tr>\n		<tr>\n			<td>ex</td>\n			<td>x-height</td>\n			<td>\n			<p>1ex = 0.5em</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、颜色：color</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">值</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">备注</th>\n		</tr>\n		<tr>\n			<td>(颜色名)</td>\n			<td>颜色名称</td>\n			<td>\n			<p>red</p>\n			</td>\n		</tr>\n		<tr>\n			<td>rgb(x,x,x)</td>\n			<td>RGB 值</td>\n			<td>\n			<p>rgb(255,0,0)</p>\n			</td>\n		</tr>\n		<tr>\n			<td>rgb(x%, x%, x%)</td>\n			<td>RGB 百分比值</td>\n			<td>\n			<p>rgb(100%,0%,0%)</p>\n			</td>\n		</tr>\n		<tr>\n			<td>#rrggbb</td>\n			<td>十六进制数</td>\n			<td>\n			<p>#ff0000</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299318043602755584,'2019-06-14 04:18:32','2019-06-14 03:39:51'),(299332334322098176,'<h1>CSS 选择器</h1>','sys','待编辑','<p><strong>1、基础</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选择器</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">CSS</th>\n			<th scope=\"col\">HTML</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>标签选择器</td>\n			<td>标签名</td>\n			<td>\n			<p>p {...}</p>\n			</td>\n			<td>\n			<p>&lt;p&gt;..............&lt;/p&gt;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>ID选择器</td>\n			<td>id属性值，#</td>\n			<td>\n			<p>#p1 {...}</p>\n			</td>\n			<td>\n			<p>&lt;p id=\"p1\"&gt;......&lt;/p&gt;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>类选择器</td>\n			<td>class属性值，&nbsp;<strong>.</strong></td>\n			<td>\n			<p>.c1 {...}</p>\n			</td>\n			<td>\n			<p>&lt;p class=\"c1\"&gt;...&lt;/p&gt;</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、派生</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选择器</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">CSS</th>\n			<th scope=\"col\">HTML</th>\n		</tr>\n		<tr>\n			<td>全局选择器</td>\n			<td>通配符，*</td>\n			<td>\n			<p>*{...}</p>\n			</td>\n			<td>\n			<p>&nbsp;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>组合选择器</td>\n			<td>多个选择器，用逗号分隔</td>\n			<td>\n			<p>div,p{...}</p>\n			</td>\n			<td>\n			<p>&lt;div&gt;............&lt;/div&gt;<br>\n			&lt;/p&gt;.............&lt;/p&gt;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>后代选择器</td>\n			<td>父子标签名，用空格分隔</td>\n			<td>\n			<p>div p{...}</p>\n			</td>\n			<td>\n			<p>&lt;div&gt;<br>\n			&nbsp;&nbsp;&nbsp; &lt;p&gt;..........&lt;/p&gt;<br>\n			&lt;/div&gt;</p>\n			</td>\n		</tr>\n		<tr>\n			<td>伪类选择器</td>\n			<td>伪类</td>\n			<td>\n			<p>a:visited {...}</p>\n			</td>\n			<td>\n			<p>&lt;a ...&gt;..........&lt;/a&gt;</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、伪类、伪元素</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">伪类</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>:link</td>\n			<td>未被访问的链接</td>\n		</tr>\n		<tr>\n			<td>:visited</td>\n			<td>已被访问的链接</td>\n		</tr>\n		<tr>\n			<td>:hover</td>\n			<td>鼠标悬浮于上方的元素</td>\n		</tr>\n		<tr>\n			<td>:active</td>\n			<td>被激活的元素</td>\n		</tr>\n		<tr>\n			<td>:focus</td>\n			<td>拥有键盘输入焦点的元素</td>\n		</tr>\n		<tr>\n			<td>:first-child</td>\n			<td>元素的第一个子元素</td>\n		</tr>\n		<tr>\n			<td>:lang</td>\n			<td>带有lang 属性的元素</td>\n		</tr>\n	</tbody>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">伪元素</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>:first-letter</td>\n			<td>文本的第一个字母</td>\n		</tr>\n		<tr>\n			<td>:first-line</td>\n			<td>文本的首行</td>\n		</tr>\n		<tr>\n			<td>:before</td>\n			<td>元素之前</td>\n		</tr>\n		<tr>\n			<td>:after</td>\n			<td>元素之后</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、优先级</strong></p>\n\n<ul>\n	<li>不同样式表\n	<ul>\n		<li>行内样式&gt;内部样式&gt;外部样式</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>同一样式表\n	<ul>\n		<li>权值相同：就近原则</li>\n		<li>权值不同：根据权重</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选择器</th>\n			<th scope=\"col\">权重值</th>\n			<th scope=\"col\">示例</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>!important</td>\n			<td>最高</td>\n			<td>div{color:red !important}</td>\n		</tr>\n		<tr>\n			<td>行内样式</td>\n			<td>1000</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>ID选择器</td>\n			<td>100</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>类选择器、伪类</td>\n			<td>10</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>标签选择器</td>\n			<td>1</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>通配符选择器</td>\n			<td>0</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318043602755584,'2019-06-14 04:18:30','2019-06-14 03:39:56'),(299332352546349056,'<h1>CSS 盒模型</h1>','sys','待编辑','<p><strong>盒模型</strong></p>\n\n<ul>\n	<li>垂直方向，相邻元素的外边距会合并，实际高度为较大值</li>\n	<li>盒模型各属性，默认不继承父元素样式</li>\n</ul>\n\n<p><img alt=\"20190614-114041-010.png\" src=\"/furesky/images/201906/20190614-114041-010.png\" style=\"height:294px; width:450px\"></p>\n',0,299318043602755584,'2019-06-14 04:18:28','2019-06-14 03:42:01'),(299332365624188928,'<h1>CSS 编码规范</h1>','sys','待编辑','<p><strong>1、CSS 命名</strong></p>\n\n<ul>\n	<li>以小写字母开头</li>\n	<li>英文字母、数字、\"_\"、\"-\"</li>\n	<li>使用有意义的命名</li>\n	<li>命名形式：单个单词、连字符、驼峰命名</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<tbody>\n		<tr>\n			<td rowspan=\"5\">页面结构</td>\n			<td>页头</td>\n			<td>header</td>\n			<td>导航</td>\n			<td>nav</td>\n		</tr>\n		<tr>\n			<td>页体</td>\n			<td>main</td>\n			<td>侧栏</td>\n			<td>sidebar</td>\n		</tr>\n		<tr>\n			<td>页尾</td>\n			<td>footer</td>\n			<td>栏目</td>\n			<td>column</td>\n		</tr>\n		<tr>\n			<td>内容</td>\n			<td>content</td>\n			<td>页面外围</td>\n			<td>wrapper</td>\n		</tr>\n		<tr>\n			<td>容器</td>\n			<td>container</td>\n			<td>左中右</td>\n			<td>left、center、right</td>\n		</tr>\n		<tr>\n			<td colspan=\"5\">.</td>\n		</tr>\n		<tr>\n			<td rowspan=\"3\">导航</td>\n			<td>主导航</td>\n			<td>mainnav</td>\n			<td>边导航</td>\n			<td>sidebar</td>\n		</tr>\n		<tr>\n			<td>子导航</td>\n			<td>subnav</td>\n			<td>左导航</td>\n			<td>leftsidebar</td>\n		</tr>\n		<tr>\n			<td>顶导航</td>\n			<td>topnav</td>\n			<td>右导航</td>\n			<td>rightsidebar</td>\n		</tr>\n		<tr>\n			<td colspan=\"5\">.</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">功能</td>\n			<td>标志</td>\n			<td>logo</td>\n			<td>注册</td>\n			<td>register</td>\n		</tr>\n		<tr>\n			<td>标题</td>\n			<td>title</td>\n			<td>搜索</td>\n			<td>search</td>\n		</tr>\n		<tr>\n			<td>登录</td>\n			<td>login</td>\n			<td>广告</td>\n			<td>banner</td>\n		</tr>\n		<tr>\n			<td>登录条</td>\n			<td>loginbar</td>\n			<td>功能区</td>\n			<td>shop</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、CSS 书写顺序</strong></p>\n\n<ol>\n	<li>位置：position、top、right、z-index、display、float...</li>\n	<li>大小：width、height、padding、margin</li>\n	<li>字体：font、line-height、letter-spacing、color、text-align...</li>\n	<li>背景：background、border...</li>\n	<li>其他：animation、transition...</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299318043602755584,'2019-06-14 04:18:26','2019-06-14 03:46:10'),(299332377921888256,'<h1>CSS 元素显示</h1>','sys','待编辑','<p><strong>1、display</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td rowspan=\"4\">改变元素类型</td>\n			<td>none</td>\n			<td>不显示元素</td>\n		</tr>\n		<tr>\n			<td>inline</td>\n			<td>显示为内联元素</td>\n		</tr>\n		<tr>\n			<td>block</td>\n			<td>显示为块级元素</td>\n		</tr>\n		<tr>\n			<td>inline-block</td>\n			<td>显示为内联元素，同时具有块级元素特性</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、元素分类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">块级元素</th>\n			<th scope=\"col\">内联元素</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>独自占一行</td>\n			<td>是</td>\n			<td>否</td>\n		</tr>\n		<tr>\n			<td>可以包含块级元素</td>\n			<td>是</td>\n			<td>否</td>\n		</tr>\n		<tr>\n			<td>元素宽度</td>\n			<td>与父容器相关</td>\n			<td>与内容相关</td>\n		</tr>\n		<tr>\n			<td>盒模型无效属性</td>\n			<td>无</td>\n			<td>width、height、padding上、margin上下</td>\n		</tr>\n		<tr>\n			<td>常用元素</td>\n			<td>\n			<p>&lt;div&gt;、&lt;p&gt;、&lt;pre&gt;、&lt;hr&gt;、<br>\n			&lt;h1&gt;~&lt;h6&gt;、&lt;form&gt;、列表、表格、...</p>\n			</td>\n			<td>\n			<p>&lt;a&gt;、&lt;b&gt;、&lt;span&gt;、<br>\n			&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、...</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318043602755584,'2019-06-14 04:18:24','2019-06-14 03:49:14'),(299358222212308992,'<h1>CSS 字体</h1>','sys','待编辑','<p><strong>1、属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>color</td>\n			<td>字体颜色</td>\n			<td><em>color</em></td>\n			<td>颜色值</td>\n		</tr>\n		<tr>\n			<td rowspan=\"3\">font-style</td>\n			<td rowspan=\"3\">字体风格</td>\n			<td>normal</td>\n			<td>正常</td>\n		</tr>\n		<tr>\n			<td>italic</td>\n			<td>斜体</td>\n		</tr>\n		<tr>\n			<td>oblique</td>\n			<td>斜体</td>\n		</tr>\n		<tr>\n			<td rowspan=\"5\">font-weight</td>\n			<td rowspan=\"5\">字体粗细</td>\n			<td>100 - 900</td>\n			<td>数值：400=normal，700=bold</td>\n		</tr>\n		<tr>\n			<td>lighter</td>\n			<td>更细</td>\n		</tr>\n		<tr>\n			<td>normal</td>\n			<td>标准</td>\n		</tr>\n		<tr>\n			<td>bold</td>\n			<td>粗体</td>\n		</tr>\n		<tr>\n			<td>bolder</td>\n			<td>更粗</td>\n		</tr>\n		<tr>\n			<td rowspan=\"8\">font-size</td>\n			<td rowspan=\"8\">字体尺寸</td>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>\n			<p>xx-small</p>\n			</td>\n			<td>&nbsp;&nbsp;9px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>&nbsp;x-small</p>\n			</td>\n			<td>11px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>&nbsp;&nbsp; small</p>\n			</td>\n			<td>13px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>&nbsp; medium</p>\n			</td>\n			<td>16px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>&nbsp;&nbsp; large</p>\n			</td>\n			<td>19px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>&nbsp;x-large</p>\n			</td>\n			<td>23px</td>\n		</tr>\n		<tr>\n			<td>\n			<p>xx-large</p>\n			</td>\n			<td>28px</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">font-family</td>\n			<td rowspan=\"2\">字体系列</td>\n			<td>字体名</td>\n			<td>Times、\"Times New Roman\"、...</td>\n		</tr>\n		<tr>\n			<td>字体集</td>\n			<td>\"serif\"、\"sans-serif\"、...</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、简写</strong></p>\n\n<ul>\n	<li>顺序：font-style | font-weight | font-size/line-height | font-family</li>\n	<li>至少需设定 font-size 和 font-family</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<pre><code class=\"language-css\">div{\n    font-style:italic;\n    font-weight:bold;\n    font-size:12px;\n    line-height:1.5em;\n    font-family:arial,verdana;\n    color:red;\n}\n\ndiv{\n    font:italic bold 12px/1.5em arial,verdana;\n    color:red;\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,299318150809165824,'2019-06-14 04:18:22','2019-06-14 03:53:58'),(299358235533418496,'<h1>CSS 文本</h1>','sys','待编辑','<p><strong>1、文本属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td rowspan=\"4\">text-align</td>\n			<td rowspan=\"4\">水平对齐&nbsp;<br>\n			仅对块级元素有效</td>\n			<td>left</td>\n			<td>左对齐</td>\n		</tr>\n		<tr>\n			<td>center</td>\n			<td>居中</td>\n		</tr>\n		<tr>\n			<td>right</td>\n			<td>右对齐</td>\n		</tr>\n		<tr>\n			<td>justify</td>\n			<td>两端对齐</td>\n		</tr>\n		<tr>\n			<td rowspan=\"9\">vertical-align</td>\n			<td rowspan=\"9\">垂直对齐</td>\n			<td>baseline</td>\n			<td>默认</td>\n		</tr>\n		<tr>\n			<td>sub</td>\n			<td>下标</td>\n		</tr>\n		<tr>\n			<td>super</td>\n			<td>上标</td>\n		</tr>\n		<tr>\n			<td>top</td>\n			<td>最顶端对齐</td>\n		</tr>\n		<tr>\n			<td>text-top</td>\n			<td>顶端对齐</td>\n		</tr>\n		<tr>\n			<td>middle</td>\n			<td>中部对齐</td>\n		</tr>\n		<tr>\n			<td>bottom</td>\n			<td>最底端对齐</td>\n		</tr>\n		<tr>\n			<td>text-bottom</td>\n			<td>底端对齐</td>\n		</tr>\n		<tr>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>line-height</td>\n			<td>文本行高</td>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>word-spacing</td>\n			<td>单词间距</td>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>letter-spacing</td>\n			<td>字符间距</td>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>text-indent</td>\n			<td>首行缩进</td>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">text-transform</td>\n			<td rowspan=\"4\">文本大小写</td>\n			<td>none</td>\n			<td>默认</td>\n		</tr>\n		<tr>\n			<td>capitalize</td>\n			<td>单词大写字母开头</td>\n		</tr>\n		<tr>\n			<td>uppercase</td>\n			<td>字母都大写</td>\n		</tr>\n		<tr>\n			<td>lowercase</td>\n			<td>字母都小写</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">text-decoration</td>\n			<td rowspan=\"4\">修饰文本</td>\n			<td>none</td>\n			<td>默认</td>\n		</tr>\n		<tr>\n			<td>underline</td>\n			<td>划线，文本底部</td>\n		</tr>\n		<tr>\n			<td>overline</td>\n			<td>划线，文本顶部</td>\n		</tr>\n		<tr>\n			<td>line-through</td>\n			<td>划线，穿过文本</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、文字基线</strong></p>\n\n<p><img alt=\"20190614-115620-010.png\" src=\"/furesky/images/201906/20190614-115620-010.png\" style=\"height:186px; width:517px\"></p>\n\n<p>&nbsp;</p>\n',0,299318150809165824,'2019-06-14 04:18:19','2019-06-14 03:57:09'),(299358248221188096,'<h1>CSS 列表</h1>','sys','待编辑','<p><strong>列表属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>list-style</td>\n			<td>简写属性</td>\n			<td>&nbsp;</td>\n			<td>空格分隔各值，不分顺序</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">list-style-image</td>\n			<td rowspan=\"2\">列表项标志的图片</td>\n			<td>none</td>\n			<td>无图片，默认</td>\n		</tr>\n		<tr>\n			<td>URL</td>\n			<td>图片路径</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">list-style-position</td>\n			<td rowspan=\"2\">列表项标志的位置</td>\n			<td>outside</td>\n			<td>标记在文本外，文本与文本对齐。默认</td>\n		</tr>\n		<tr>\n			<td>inside</td>\n			<td>标记在文本内，文本与标记对齐</td>\n		</tr>\n		<tr>\n			<td rowspan=\"9\">list-style-type</td>\n			<td rowspan=\"9\">列表项标志的类型</td>\n			<td>none</td>\n			<td>无标记</td>\n		</tr>\n		<tr>\n			<td>disc</td>\n			<td>实心圆，默认</td>\n		</tr>\n		<tr>\n			<td>circle</td>\n			<td>空心圆</td>\n		</tr>\n		<tr>\n			<td>square</td>\n			<td>实心方块</td>\n		</tr>\n		<tr>\n			<td>decimal</td>\n			<td>数字</td>\n		</tr>\n		<tr>\n			<td>lower-alpha</td>\n			<td>小写英文字母(a、b、c、...)</td>\n		</tr>\n		<tr>\n			<td>upper-alpha</td>\n			<td>大写英文字母(A、B、C、...)</td>\n		</tr>\n		<tr>\n			<td>lower-roman</td>\n			<td>小写罗马数字(i、ii、iii、...)</td>\n		</tr>\n		<tr>\n			<td>upper-roman</td>\n			<td>大写罗马数字(I、II、III、...)</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318150809165824,'2019-06-14 04:18:17','2019-06-14 03:59:18'),(299358262330826752,'<h1>CSS 背景</h1>','sys','待编辑','<p><strong>1、属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>background</td>\n			<td>简写</td>\n			<td>&nbsp;</td>\n			<td>空格分隔各值，不分顺序</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">background-color</td>\n			<td rowspan=\"2\">背景颜色</td>\n			<td>transparent</td>\n			<td>透明色，默认</td>\n		</tr>\n		<tr>\n			<td><em>color</em></td>\n			<td>颜色值</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">background-image</td>\n			<td rowspan=\"2\">背景图片</td>\n			<td>none</td>\n			<td>无图片，默认</td>\n		</tr>\n		<tr>\n			<td>url(\'<em>URL</em>\')</td>\n			<td>图片路径</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">background-repeat</td>\n			<td rowspan=\"4\">背景图片重复</td>\n			<td>repeat</td>\n			<td>默认。垂直方向及水平方向重复</td>\n		</tr>\n		<tr>\n			<td>repeat-x</td>\n			<td>水平方向重复</td>\n		</tr>\n		<tr>\n			<td>repeat-y</td>\n			<td>垂直方向重复</td>\n		</tr>\n		<tr>\n			<td>no-repeat</td>\n			<td>不重复</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">background-attachment</td>\n			<td rowspan=\"2\">背景图片滚动</td>\n			<td>scroll</td>\n			<td>跟随滚动。默认</td>\n		</tr>\n		<tr>\n			<td>fixed</td>\n			<td>固定</td>\n		</tr>\n		<tr>\n			<td rowspan=\"8\">background-position</td>\n			<td rowspan=\"8\">背景图片起始位置</td>\n			<td colspan=\"2\">当只有一个值时，第二个值默认为居中</td>\n		</tr>\n		<tr>\n			<td>x%、y%</td>\n			<td>百分比，默认0% 0%</td>\n		</tr>\n		<tr>\n			<td>x、y</td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>top</td>\n			<td>上</td>\n		</tr>\n		<tr>\n			<td>bottom</td>\n			<td>下</td>\n		</tr>\n		<tr>\n			<td>left</td>\n			<td>左</td>\n		</tr>\n		<tr>\n			<td>right</td>\n			<td>右</td>\n		</tr>\n		<tr>\n			<td>center</td>\n			<td>中</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例</strong></p>\n\n<pre><code class=\"language-css\">body{ \n    background-image:url(\'/i/eg_bg_03.gif\');\n    background-repeat:no-repeat;\n    background-position:66% 33%;\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,299318150809165824,'2019-06-14 04:01:19','2019-06-14 04:01:19'),(299361305386459136,'<h1>CSS 边框</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>border</td>\n			<td>简写属性</td>\n			<td colspan=\"2\">border: [宽度] [样式] [颜色]</td>\n		</tr>\n		<tr>\n			<td>border-width | style | color</td>\n			<td>简写属性</td>\n			<td colspan=\"2\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>border-left | right | top | bottom</td>\n			<td>简写属性</td>\n			<td colspan=\"2\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">border-[ left | right | top | bottom ]-width</td>\n			<td rowspan=\"4\">边框宽度</td>\n			<td>thin</td>\n			<td>细边框</td>\n		</tr>\n		<tr>\n			<td>medium</td>\n			<td>中边框，默认</td>\n		</tr>\n		<tr>\n			<td>thick</td>\n			<td>粗边框</td>\n		</tr>\n		<tr>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td rowspan=\"10\">border-[ left | right | top | bottom ]-style</td>\n			<td rowspan=\"10\">边框样式</td>\n			<td>none</td>\n			<td>无边框</td>\n		</tr>\n		<tr>\n			<td>hidden</td>\n			<td>无边框，用于解决边框冲突</td>\n		</tr>\n		<tr>\n			<td>dotted</td>\n			<td>点状边框</td>\n		</tr>\n		<tr>\n			<td>dashed</td>\n			<td>虚线边框</td>\n		</tr>\n		<tr>\n			<td>solid</td>\n			<td>实线边框</td>\n		</tr>\n		<tr>\n			<td>double</td>\n			<td>双线边框</td>\n		</tr>\n		<tr>\n			<td>groove</td>\n			<td>3D 凹槽边框</td>\n		</tr>\n		<tr>\n			<td>ridge</td>\n			<td>3D 垄状边框</td>\n		</tr>\n		<tr>\n			<td>inset</td>\n			<td>3D inset 边框</td>\n		</tr>\n		<tr>\n			<td>outset</td>\n			<td>3D outset 边框</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">border-[ left | right | top | bottom ]-color</td>\n			<td rowspan=\"2\">边框颜色</td>\n			<td>transparent</td>\n			<td>透明色，默认</td>\n		</tr>\n		<tr>\n			<td><em>color</em></td>\n			<td>颜色值</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318210791907328,'2019-06-14 04:05:35','2019-06-14 04:05:35'),(299361320108466176,'<h1>CSS 边距</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>padding</td>\n			<td>padding-left | right | top | bottom</td>\n			<td>内边距</td>\n		</tr>\n		<tr>\n			<td>margin</td>\n			<td>margin-left | right | top | bottom</td>\n			<td>外边距</td>\n		</tr>\n		<tr>\n			<td rowspan=\"2\">值</td>\n			<td>auto</td>\n			<td>浏览器自动计算</td>\n		</tr>\n		<tr>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td rowspan=\"4\">简写&nbsp;<br>\n			助记：顺时针</td>\n			<td>margin:值1</td>\n			<td>上下左右 = 值1</td>\n		</tr>\n		<tr>\n			<td>margin:值1 值2</td>\n			<td>上下=值1，左右=值2</td>\n		</tr>\n		<tr>\n			<td>margin:值1 值2 值3</td>\n			<td>上=值1，左右=值2，下=值3</td>\n		</tr>\n		<tr>\n			<td>margin:值1 值2 值3 值4</td>\n			<td>上=值1，右=值2，下=值3，左=值4</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318210791907328,'2019-06-14 04:04:45','2019-06-14 04:04:45'),(299361333869977600,'<h1>CSS 宽高</h1>','sys','待编辑','<p><strong>1、属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n		</tr>\n		<tr>\n			<td>width</td>\n			<td>宽度</td>\n		</tr>\n		<tr>\n			<td>min-width</td>\n			<td>最小宽度</td>\n		</tr>\n		<tr>\n			<td>max-width</td>\n			<td>最大宽度</td>\n		</tr>\n		<tr>\n			<td>height</td>\n			<td>高度</td>\n		</tr>\n		<tr>\n			<td>min-height</td>\n			<td>最小高度</td>\n		</tr>\n		<tr>\n			<td>max-height</td>\n			<td>最大高度</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、属性值</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>auto</td>\n			<td>默认</td>\n		</tr>\n		<tr>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,299318210791907328,'2019-06-14 04:11:13','2019-06-14 04:11:13'),(299361346985566208,'<h1>CSS 定位</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td rowspan=\"5\">position</td>\n			<td rowspan=\"5\">定位</td>\n			<td>static</td>\n			<td>没有定位，默认值</td>\n		</tr>\n		<tr>\n			<td>fixed</td>\n			<td>绝对定位，相对于浏览器窗口，脱离标准流</td>\n		</tr>\n		<tr>\n			<td>absolute</td>\n			<td>绝对定位，相对于父元素，脱离标准流</td>\n		</tr>\n		<tr>\n			<td>relative</td>\n			<td>相对定位，相对于自身正常位置</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n		<tr>\n			<td rowspan=\"3\">z-index</td>\n			<td rowspan=\"3\">层级</td>\n			<td>auto</td>\n			<td>与父元素相等，默认</td>\n		</tr>\n		<tr>\n			<td><em>number</em></td>\n			<td>层级数值</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n		<tr>\n			<td rowspan=\"3\">top&nbsp;<br>\n			bottom&nbsp;<br>\n			left&nbsp;<br>\n			right</td>\n			<td rowspan=\"3\">上下左右</td>\n			<td>auto</td>\n			<td>浏览器计算，默认</td>\n		</tr>\n		<tr>\n			<td><em>size</em></td>\n			<td>数值</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n	</tbody>\n</table>\n',0,299318210791907328,'2019-06-14 04:12:29','2019-06-14 04:12:29'),(299364030383824896,'<h1>CSS 浮动</h1>','sys','待编辑','<p><strong>1、属性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">属性</th>\n			<th scope=\"col\">属性说明</th>\n			<th scope=\"col\">属性值</th>\n			<th scope=\"col\">属性值说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td rowspan=\"4\">float</td>\n			<td rowspan=\"4\">浮动</td>\n			<td>none</td>\n			<td>不浮动，默认</td>\n		</tr>\n		<tr>\n			<td>left</td>\n			<td>左浮动</td>\n		</tr>\n		<tr>\n			<td>right</td>\n			<td>右浮动</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n		<tr>\n			<td rowspan=\"5\">clear</td>\n			<td rowspan=\"5\">清除浮动</td>\n			<td>none</td>\n			<td>两侧元素，允许浮动，默认值。</td>\n		</tr>\n		<tr>\n			<td>left</td>\n			<td>左侧元素，不允许浮动</td>\n		</tr>\n		<tr>\n			<td>right</td>\n			<td>右侧元素，不允许浮动</td>\n		</tr>\n		<tr>\n			<td>both</td>\n			<td>两侧元素，不允许浮动</td>\n		</tr>\n		<tr>\n			<td>inherit</td>\n			<td>继承</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、浮动规则</strong></p>\n\n<ul>\n	<li>浮动元素\n	<ul>\n		<li>不会重叠&nbsp;</li>\n		<li>不会上下浮动&nbsp;</li>\n		<li>会脱离标准流</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>浮动元素的外边距，不会超过父元素内边距</li>\n	<li>非浮动元素的文本，会环绕浮动元素周围</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,299318210791907328,'2019-06-14 04:16:53','2019-06-14 04:16:53'),(299639802658988032,'<h1>Linux 远程访问</h1>','sys','待编辑','<p><strong>1、Xshell</strong></p>\n\n<ul>\n	<li>是一个远程登录到 Linux 的软件</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Xftp</strong></p>\n\n<ul>\n	<li>是一个基于 windows 平台的功能强大的 SFTP、FTP 文件传输软件</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、SecureCRT</strong></p>\n\n<ul>\n	<li>是一个远程登录 Linux 的软件，在大数据开发中使用较多。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,298772070904274944,'2019-06-14 22:35:45','2019-06-14 22:35:45'),(299648555764588500,'<h1>帮助指令</h1>','sys','待编辑','<h3><strong>man</strong></h3>\n\n<ul>\n	<li>命令帮助手册</li>\n	<li>安装 man 命令：#yum install man -y</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# man ls\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>help</strong></h3>\n\n<ul>\n	<li>显示 shell 内部命令的帮助信息</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# help cd</code></pre>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>type</strong></h3>\n\n<ul>\n	<li>判断指令的类型</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>alias</td>\n			<td>别名</td>\n		</tr>\n		<tr>\n			<td>keyword</td>\n			<td>关键字，Shell保留字</td>\n		</tr>\n		<tr>\n			<td>function</td>\n			<td>函数，Shell函数</td>\n		</tr>\n		<tr>\n			<td>builtin</td>\n			<td>内建命令，Shell内建命令</td>\n		</tr>\n		<tr>\n			<td>file</td>\n			<td>文件，磁盘文件，外部命令</td>\n		</tr>\n		<tr>\n			<td>unfound</td>\n			<td>没有找到</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# type ls</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>history</strong></h3>\n\n<ul>\n	<li>查看已经执行过历史命令</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# history       //显示所有的历史命令       \n# history 10    //显示最近使用过的10个指令\n# !5            //执行历史编号为5的指令\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>hash</strong></h3>\n\n<ul>\n	<li>linux系统下会有一个hash表，作为 shell 解释器的命令缓存</li>\n</ul>\n\n<pre><code class=\"language-bash\">//清除hash表，清除的是全部的\n# hash -r&nbsp;&nbsp;</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487987830210,'2019-06-16 00:28:11','2019-06-16 00:28:11'),(299648555764588544,'<h1>关机、重启</h1>','sys','待编辑','<h3><strong>shutdown</strong></h3>\n\n<ul>\n	<li>启动关机程序</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-t seconds</td>\n			<td>设定时间，在几秒后执行</td>\n		</tr>\n		<tr>\n			<td>-r</td>\n			<td>重启</td>\n		</tr>\n		<tr>\n			<td>-h</td>\n			<td>关机</td>\n		</tr>\n		<tr>\n			<td>time</td>\n			<td>设定关机的时间</td>\n		</tr>\n		<tr>\n			<td>message</td>\n			<td>设置告警信息</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//语法\nshutdown [-t seconds] [选项] time [message]\n\n\n//示例\n# shutdown -r now    // 立即重启\n# shutdown -h now    // 立即关机\n# shutdown +5 “System will shutdown after 5 minutes”    // 5分钟后关机</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>halt</strong></h3>\n\n<ul>\n	<li>立刻关机</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-p</td>\n			<td>关闭电源</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//语法\nhalt [选项]\n\n\n//示例\n# halt       //立刻关机\n# halt -p    //关闭系统并关闭电源</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>reboot</strong></h3>\n\n<ul>\n	<li>立刻重启</li>\n</ul>\n\n<pre><code class=\"language-bash\">//语法\nreboot [选项]\n\n\n//示例\n# reboot    //立刻重启\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>sync</strong></h3>\n\n<ul>\n	<li>把内存的数据，写入磁盘。</li>\n	<li>注意：在关机、重启时，保存数据</li>\n</ul>\n\n<pre><code class=\"language-bash\">//语法\n# sync</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487987830210,'2019-06-15 16:26:36','2019-06-14 23:58:58'),(299658971857199104,'<h1>登录、注销</h1>','sys','待编辑','<h3><strong>su</strong></h3>\n\n<ul>\n	<li>切换用户</li>\n	<li>注意：尽量少用 root 登录</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-c command</td>\n			<td>执行&nbsp;command 指令后，将用户切换回去</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# su -c ls root    //变更帐号为 root 并在执行 ls 指令后退出变回原使用者</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>logout</strong></h3>\n\n<ul>\n	<li>注销用户</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# logout</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487987830210,'2019-06-15 16:26:38','2019-06-15 00:58:15'),(299658971857199150,'<h1>文件属性</h1>','sys','待编辑','<p><strong>1、文件类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">符号</th>\n			<th scope=\"col\">代表含义</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\">-</td>\n			<td>文件</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">d</td>\n			<td>目录</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">b</td>\n			<td>可供储存的接口设备</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">c</td>\n			<td>串行端口设备，例如键盘、鼠标</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">l</td>\n			<td>链接文档</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、用户身份</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">身份</th>\n			<th scope=\"col\" style=\"text-align:center\">代表符号</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>all</td>\n			<td style=\"text-align:center\">a</td>\n			<td>全部</td>\n		</tr>\n		<tr>\n			<td>user</td>\n			<td style=\"text-align:center\">u</td>\n			<td>该文件的所有者，即属主</td>\n		</tr>\n		<tr>\n			<td>group</td>\n			<td style=\"text-align:center\">g</td>\n			<td>所有者的同组用户，即属组</td>\n		</tr>\n		<tr>\n			<td>others</td>\n			<td style=\"text-align:center\">o</td>\n			<td>其他用户&nbsp;&nbsp;&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、用户权限</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">权限</th>\n			<th scope=\"col\" style=\"text-align:center\">代表符号</th>\n			<th scope=\"col\" style=\"text-align:center\">代表分数</th>\n			<th scope=\"col\" style=\"text-align:center\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>read</td>\n			<td style=\"text-align:center\">r</td>\n			<td style=\"text-align:center\">4</td>\n			<td style=\"text-align:center\">可读</td>\n		</tr>\n		<tr>\n			<td>write</td>\n			<td style=\"text-align:center\">w</td>\n			<td style=\"text-align:center\">2</td>\n			<td style=\"text-align:center\">可写</td>\n		</tr>\n		<tr>\n			<td>execute</td>\n			<td style=\"text-align:center\">x</td>\n			<td style=\"text-align:center\">1</td>\n			<td style=\"text-align:center\">可执行</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td style=\"text-align:center\">-</td>\n			<td style=\"text-align:center\">0</td>\n			<td style=\"text-align:center\">无权限</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、文件属性</strong></p>\n\n<pre><code>[root@node01 /]# ll\ntotal 90\ndr-xr-xr-x.  2 root root  4096 Jun 12 04:40 bin\n……</code></pre>\n\n<p>以上述代码为例：</p>\n\n<ul>\n	<li>dr-xr-xr-x\n	<ul>\n		<li>0 位：文件类型</li>\n		<li>1-3 位： owner 的权限</li>\n		<li>4-6 位：&nbsp;group 的权限</li>\n		<li>7-9 位： others 的权限</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>文件硬链接的次数</li>\n	<li>文件属主</li>\n	<li>文件属组</li>\n	<li>文件大小（字节）</li>\n	<li>文件修改时间（时间戳）</li>\n	<li>文件名称</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,299648487988830208,'2019-06-15 16:13:16','2019-06-13 22:08:48'),(299658971857199200,'<h1>用户管理</h1>','sys','待编辑','<h3><strong>useradd</strong></h3>\n\n<ul>\n	<li>新增用户</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-d&lt;目录&gt;</td>\n			<td>设定用户的家目录</td>\n		</tr>\n		<tr>\n			<td>-e&lt;有效期限&gt;</td>\n			<td>设定用户的有效期限</td>\n		</tr>\n		<tr>\n			<td>-g&lt;用户组&gt;</td>\n			<td>设定用户所属的用户组</td>\n		</tr>\n		<tr>\n			<td>-n</td>\n			<td>取消建立以用户名称为名的用户组</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# useradd tt                 //创建tt用户\n# useradd -d /home/myd tt    //创建tt用户，并指定其家目录</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>passwd</strong></h3>\n\n<ul>\n	<li>修改用户密码</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-d</td>\n			<td>删除密码</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>强迫用户下次登录时修改密码</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-l</td>\n			<td>锁定密码，即禁用账号</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-S</td>\n			<td>显示密码</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-u</td>\n			<td>解锁密码</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-x</td>\n			<td>设置密码的有效期</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//语法\npasswd [选项] [username]\n\n\n//示例\n# passwd          //修改当前用户的密码\n# passwd tt       //设置用户 tt 的密码\n# passwd -S tt    //显示账号密码信息</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>userdel</strong></h3>\n\n<ul>\n	<li>删除用户</li>\n</ul>\n\n<pre><code class=\"language-bash\">//语法\nuserdel [选项][用户帐号]\n\n\n//示例\n# userdel tt</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>id</strong></h3>\n\n<ul>\n	<li>显示用户信息</li>\n</ul>\n\n<pre><code class=\"language-bash\"># id root    //查询用户root信息</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>usermod</strong></h3>\n\n<ul>\n	<li>修改用户</li>\n	<li>同 useradd</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>su</strong></h3>\n\n<ul>\n	<li>切换用户</li>\n	<li>备注\n	<ul>\n		<li>尽量少用 root 登录</li>\n		<li>未指定用户名，则切换至 root</li>\n		<li>使用 exit 返回原来的用户</li>\n		<li>切换为权限较低的用户时，不用输密码</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-c command</td>\n			<td>执行&nbsp;command 指令后，将用户切换回去</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code>//示例\n# su -c ls root    //变更帐号为 root 并在执行 ls 指令后退出变回原使用者</code></pre>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>sudo</strong></h3>\n\n<ul>\n	<li>以用户 root 的身份执行指令</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# sudo ls</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487988830208,'2019-06-15 00:40:06','2019-06-15 00:40:06'),(299658971857199300,'<h1>用户组管理</h1>','sys','待编辑','<h3><strong>groupadd</strong></h3>\n\n<ul>\n	<li>新增用户组</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# groupadd group1</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>groupdel</strong></h3>\n\n<ul>\n	<li>删除用户组</li>\n	<li>备注：组内没有用户，才能删除</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# groupdel group1</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>groupmod</strong></h3>\n\n<ul>\n	<li>修改用户组</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-n &lt;新组名&gt;</td>\n			<td>\n			<p>将用户组的名字改为新名字</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//修改用户组名\n# groupmod -n linux linuxso</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>newgrp</strong></h3>\n\n<ul>\n	<li>切换用户的用户组</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# newgrp root</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487988830208,'2019-06-15 01:01:25','2019-06-15 01:01:25'),(299658971857199400,'<h1>修改文件权限</h1>','sys','待编辑','<h3><strong>chgrp</strong></h3>\n\n<ul>\n	<li>更改文件属组</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\">-R</td>\n			<td>递归处理，对所有文件及子目录一并处理</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code>//格式\nchgrp [-R] 属组名 文件名\n\n//示例\n# chgrp group1 test.log\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>chown</strong></h3>\n\n<ul>\n	<li>更改文件属主/属组</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-R</td>\n			<td>递归处理，对所有文件及子目录一并处理</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code>//格式\nchown [–R] 属主名 文件名\nchown [-R] 属主名:属组名 文件名\n\n//示例\n# chown user1 test.log\n# chown user1:group1 test.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>chmod</strong></h3>\n\n<ul>\n	<li>更改权限</li>\n</ul>\n\n<pre><code>//方式一：分数\n//如：权限-rwxr-xr--代表分数[4+2+1][4+0+1][4+0+0]=754\n# chmod 754 test.log\n\n\n//方式二：字符\n# chmod u=rwx,g=rx,o=r test.log\n# chmod a-x test.log\n# chmod a+x test.log</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487988830208,'2019-06-15 16:16:36','2019-06-15 16:16:36'),(299679327984721920,'<h1>Linux 运行级别</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、运行级别</strong></p>\n\n<ul>\n	<li>0：关机</li>\n	<li>1：单用户 [类似安全模式， 这个模式可以帮助找回root密码]</li>\n	<li>2：多用户状态没有网络服务</li>\n	<li>3：多用户状态有网络服务 [使用最多]</li>\n	<li>4：系统未使用保留给用户</li>\n	<li>5：图形界面</li>\n	<li>6：系统重启 &nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、切换运行级别</strong></p>\n\n<pre><code class=\"language-bash\">//示例\n# init 5</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、找回 root 密码</strong></p>\n\n<ul>\n	<li><a href=\"https://www.runoob.com/linux/linux-forget-password.html\" target=\"_blank\">https://www.runoob.com/linux/linux-forget-password.html</a></li>\n	<li>重启系统，3秒内，按回车</li>\n	<li>按 e，选择带 kernel 的项</li>\n	<li>按 e，在行末尾写入1</li>\n	<li>回车</li>\n	<li>按 b 启动</li>\n	<li>进入单用户模式后，用 passwd 命令</li>\n</ul>\n',0,298772070904274944,'2019-06-15 01:23:14','2019-06-15 01:23:14'),(299685396530241600,'<h1>文件管理</h1>','sys','待编辑','<h3><strong>mkdir</strong></h3>\n\n<ul>\n	<li>创建新目录</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-m</td>\n			<td>指定权限</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-p</td>\n			<td>如果有必要，则一并建立上层目录</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# mkdir -p /home/animal/tiger</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>rmdir</strong></h3>\n\n<ul>\n	<li>删除<strong>空</strong>目录</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-p</td>\n			<td>若子目录为空，也一并删除</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# rmdir -p /home/dog</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>rm</strong></h3>\n\n<ul>\n	<li>删除文件或目录&nbsp;</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>强制执行，不进行询问</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-r</td>\n			<td>递归执行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# rm  /home/aaa.txt    //删除目录\n# rm  -r  *            //删除当前目录下的所有文件及目录</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>mv</strong></h3>\n\n<ul>\n	<li>移动文件与目录，或修改名称<strong>&nbsp; </strong></li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>强制执行，不进行询问</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-u</td>\n			<td>源文件较新则覆盖</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令格式</th>\n			<th scope=\"col\">运行结果</th>\n		</tr>\n		<tr>\n			<td>mv 文件名 文件名</td>\n			<td>将源文件名改为目标文件名</td>\n		</tr>\n		<tr>\n			<td>mv 文件名 目录名</td>\n			<td>将文件移动到目标目录</td>\n		</tr>\n		<tr>\n			<td>mv 目录名 目录名</td>\n			<td>\n			<p>目标目录已存在，将源目录移动到目标目录；</p>\n\n			<p>目标目录不存在，则改名</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# mv aaa bbb       //重命名文件\n# mv /usr/*  .     //将/user下所有文件，移到当前目录</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>touch</strong></h3>\n\n<ul>\n	<li>修改文件或者目录的时间属性</li>\n	<li>若文件不存在，系统会建立一个新的文件</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# touch  hello.txt</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>cp</strong></h3>\n\n<ul>\n	<li>复制文件或目录&nbsp;</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-a</td>\n			<td>相当于 -dpr</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-d</td>\n			<td>保留链接</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>强制执行，不进行询问</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-l</td>\n			<td>不复制文件，只是生成链接文件</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-p</td>\n			<td>连同文件的属性一起复制</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-r</td>\n			<td>递归执行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# cp -r /home/ /opt/</code></pre>\n\n<h3><br>\n<strong>ln&nbsp; </strong></h3>\n\n<ul>\n	<li>创建链接</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">软链接（即符号链接）</th>\n			<th scope=\"col\">硬链接</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">\n			<p style=\"text-align:left\">以路径的形式存在。</p>\n\n			<p style=\"text-align:left\">类似于Windows操作系统中的快捷方式。</p>\n			</td>\n			<td>\n			<p>以文件副本的形式存在。</p>\n\n			<p>但不占用实际空间。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>可以跨文件系统</td>\n			<td>不可以跨文件系统</td>\n		</tr>\n		<tr>\n			<td>可以链接目录</td>\n			<td>不可以链接目录</td>\n		</tr>\n		<tr>\n			<td>可以链接一个不存在的文件</td>\n			<td>&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-b</td>\n			<td>覆盖以前建立的链接</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-d</td>\n			<td>允许超级用户制作目录的硬链接</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>强制执行，不进行询问</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-s</td>\n			<td>软链接</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# ln -s /root/ linkToRoot    //创建一个软连接 linkToRoot，连接到 /root 目录</code></pre>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,299687534769643520,'2019-06-16 00:37:33','2019-06-16 00:32:30'),(299685396530241650,'<h1>文件查看</h1>','sys','待编辑','<h3><strong>file</strong></h3>\n\n<ul>\n	<li>判断文件类型</li>\n</ul>\n\n<ul>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# file install.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>pwd</strong></h3>\n\n<ul>\n	<li>Print Working Directory</li>\n	<li>显示当前工作目录的绝对路径</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# pwd</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>ls</strong></h3>\n\n<ul>\n	<li>列出当前工作目录所含的子文件及子目录</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\">-a</td>\n			<td>显示所有文件，包含隐藏的</td>\n		</tr>\n		<tr>\n			<td>\n			<p style=\"text-align:center\">-l</p>\n			</td>\n			<td>显示详细信息</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-t</td>\n			<td>时间排序</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-r</td>\n			<td>反向排序</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-R</td>\n			<td>递归执行</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# ls -R</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>cd</strong></h3>\n\n<ul>\n	<li>Change Directory</li>\n	<li>切换当前工作目录</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# cd /root/runoob/    //绝对路径\n# cd ./runoob/	      //相对路径\n# cd ~	              //回到自己的家目录\n# cd ..	              //返回上一级目录</code></pre>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>wc</strong></h3>\n\n<ul>\n	<li>用于计算字数</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-l</td>\n			<td>只显示行数</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-w</td>\n			<td>只显示字数</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//统计三个文件的信息  \n# wc testfile testfile_1 testfile_2</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>stat</strong></h3>\n\n<ul>\n	<li>显示文件元数据</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">元数据</th>\n			<th scope=\"col\">含义</th>\n		</tr>\n		<tr>\n			<td>Access</td>\n			<td>访问时间</td>\n		</tr>\n		<tr>\n			<td>Modify</td>\n			<td>文件内容的修改时间</td>\n		</tr>\n		<tr>\n			<td>Change</td>\n			<td>元数据的修改时间</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code>//示例\n[jianda@node01 ~]# stat hello.txt \n  File: `hello.txt\'\n  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file\nDevice: 803h/2051d	Inode: 1572866     Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: (  500/  jianda)   Gid: (  500/  jianda)\nAccess: 2019-06-15 18:44:51.816129406 +0800\nModify: 2019-06-15 18:44:51.816129406 +0800\nChange: 2019-06-15 18:44:51.816129406 +0800</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,299687534769643520,'2019-06-16 00:37:29','2019-06-16 00:36:03'),(299685396530241700,'<h1>文本查看</h1>','sys','待编辑','<h3><strong>cat</strong></h3>\n\n<ul>\n	<li>从第一行开始，浏览全部文件内容。</li>\n	<li>加载整个文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-n</td>\n			<td>列出行号</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-b</td>\n			<td>列出行号，空白行不标行号</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-v</td>\n			<td>列出一些看不出来的特殊字符</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# cat -n t1.txt &gt; t2.txt   //把 t1.txt 的文档内容加上行号后输入 t2.txt 中\n# cat -n t1.txt | more     //把 cat 输出结果交给 more 处理</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>tac</strong></h3>\n\n<ul>\n	<li>从最后一行开始，浏览全部文件内容。</li>\n	<li>与 cat 类似</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>nl</strong></h3>\n\n<ul>\n	<li>显示文件内容，并显示行号</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# nl test.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>more</strong></h3>\n\n<ul>\n	<li>是一个基于 vi 编辑器的文本过滤器</li>\n	<li>显示文件内容，一页一页翻动</li>\n	<li>加载整个文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-num</td>\n			<td>一次显示的行数</td>\n		</tr>\n		<tr>\n			<td>+num</td>\n			<td>从第 num 行开始显示</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>空格键</td>\n			<td>向下翻页</td>\n		</tr>\n		<tr>\n			<td>Ctrl+b</td>\n			<td>向上翻页</td>\n		</tr>\n		<tr>\n			<td>回车键</td>\n			<td>向下翻一行</td>\n		</tr>\n		<tr>\n			<td>=</td>\n			<td>输出当前行的行号</td>\n		</tr>\n		<tr>\n			<td>:f&nbsp;</td>\n			<td>当前文件名，当前行数</td>\n		</tr>\n		<tr>\n			<td>q</td>\n			<td>退出</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code>//示例\n# more +20 test.log    //从第 20 行开始显示 testfile 之文档内容。</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>less</strong></h3>\n\n<ul>\n	<li>显示文件内容，一页一页翻动</li>\n	<li>不会加载整个文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-num</td>\n			<td>一次显示的行数</td>\n		</tr>\n		<tr>\n			<td>+num</td>\n			<td>从第 num 行开始显示</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>空格键、[pagedown]</td>\n			<td>向下翻页</td>\n		</tr>\n		<tr>\n			<td>b、[pageup]</td>\n			<td>向上翻页</td>\n		</tr>\n		<tr>\n			<td>回车键</td>\n			<td>向下翻一行</td>\n		</tr>\n		<tr>\n			<td>/字符串</td>\n			<td>向下搜索\"字符串\"</td>\n		</tr>\n		<tr>\n			<td>?字符串</td>\n			<td>向上搜索\"字符串\"</td>\n		</tr>\n		<tr>\n			<td>q</td>\n			<td>退出</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# less test.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>echo</strong></h3>\n\n<ul>\n	<li>输出内容到控制台</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# echo \"Hi !\"\n# echo  $PATH    //打印环境变量</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>head</strong></h3>\n\n<ul>\n	<li>显示文件前面几行</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-n</td>\n			<td>显示前 n 行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# head -n 5 /etc/profile</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>tail</strong></h3>\n\n<ul>\n	<li>显示文件后面几行</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-n</td>\n			<td>显示后 n 行</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>实时追踪该文档的所有更新</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# tail file        //显示文件file的最后10行\n# tail +20 file    //显示文件file的内容，从第20行至文件末尾</code></pre>\n\n<p>&nbsp;</p>\n\n<h3>&nbsp;</h3>\n',0,299687534769643520,'2019-06-16 00:36:09','2019-06-16 00:36:09'),(299685396530241800,'<h1>文本处理</h1>','sys','待编辑','<h3><strong>cut</strong></h3>\n\n<ul>\n	<li>切割文件中的行，并显示结果</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-d</td>\n			<td>自定义分隔符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>选择显示的列</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-s</td>\n			<td>不显示没有分隔符的行</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>sort</strong></h3>\n\n<ul>\n	<li>排序文件的行</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>排序时，忽略大小写</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-k</td>\n			<td>选择进行排序列</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-n</td>\n			<td>按数值排序</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-r</td>\n			<td>倒序</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-t</td>\n			<td>自定义分隔符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-u</td>\n			<td>忽略相同行</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>wc</strong></h3>\n\n<ul>\n	<li>用于计算字数</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-l</td>\n			<td>只显示行数</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-w</td>\n			<td>只显示字数</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>sed</strong></h3>\n\n<ul>\n	<li>行编辑器</li>\n	<li>......</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-e</td>\n			<td>同时执行多个脚本</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>以指定的脚本文件来处理文件内容</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-i</td>\n			<td>直接修改原文件</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-n</td>\n			<td>静默模式，不再默认显示模式空间中的内容</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-r</td>\n			<td>使用扩展正则表达式</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>awk</strong></h3>\n\n<ul>\n	<li>一个强大的文本分析工具</li>\n	<li>......</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299687534769643520,'2019-06-17 03:49:27','2019-06-16 00:21:21'),(299714071367688192,'<h1>重定向</h1>','sys','待编辑','<p><strong>1、文件描述符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">文件描述符</th>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">设备名</th>\n			<th scope=\"col\">硬件</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>0</td>\n			<td>标准输入</td>\n			<td>/dev/stdin</td>\n			<td>键盘</td>\n		</tr>\n		<tr>\n			<td>1</td>\n			<td>标准输出</td>\n			<td>/dev/stdout</td>\n			<td>显示器</td>\n		</tr>\n		<tr>\n			<td>2</td>\n			<td>标准错误输出</td>\n			<td>/dev/stderr</td>\n			<td>显示器</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、输出重定向</strong></p>\n\n<ul>\n	<li>重定向到 file 有两种方式：\n	<ul>\n		<li>覆盖&nbsp; &nbsp;&nbsp;<span style=\"color:#c0392b\"><strong>&gt;</strong></span></li>\n		<li>追加&nbsp; &nbsp;&nbsp;<span style=\"color:#c0392b\"><strong>&gt;&gt;</strong></span></li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>以&nbsp; &gt; 为示例</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>command &gt;file</td>\n			<td>将 stdout 重定向到 file</td>\n		</tr>\n		<tr>\n			<td>command 2&gt;file</td>\n			<td>将 stderr&nbsp;重定向到 file</td>\n		</tr>\n		<tr>\n			<td>command &gt;file&nbsp;2&gt;&amp;1</td>\n			<td>将 stdout、stderr 同时重定向到 file</td>\n		</tr>\n		<tr>\n			<td>command &gt;file1 2&gt;file2</td>\n			<td>将 stdout 重定向到 file1，将 stderr&nbsp;重定向到 file2</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、输入重定向</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>command &lt;file</td>\n			<td>将&nbsp;file 文件内容作为 stdin</td>\n		</tr>\n		<tr>\n			<td>command &lt;&lt;tag</td>\n			<td>将两个 tag 之间的内容作为 stdin</td>\n		</tr>\n		<tr>\n			<td>command &lt;file1 &gt;file2</td>\n			<td>将 file1 作为 stdin，并将 stdout 重定向到 file2</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<pre><code class=\"language-bash\"># echo \"hello world!\" &gt; out.log\n# cat out.log\nhello world!\n\n\n# ls -l &gt;out.log 2&gt;&amp;1</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299648487988830200,'2019-06-15 16:27:08','2019-06-15 16:27:08'),(299803983219695616,'<h1>日期时间</h1>','sys','待编辑','<h3><strong>date</strong></h3>\n\n<ul>\n	<li>显示或设定系统的日期时间</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-d datestr</td>\n			<td>输出 datestr 中所设定的时间 (非系统时间)</td>\n		</tr>\n		<tr>\n			<td>-s datestr</td>\n			<td>将系统时间设为 datestr 中所设定的时间</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//系统日期时间\n# date\nSun Jun 16 01:29:07 CST 2019\n\n//格式化系统日期时间\n# date +\"%Y-%m-%d %H:%M:%S\"\n2019-06-16 01:28:22\n\n//格式化指定时间\n# date -d \"2009-12-12\" +\"%Y/%m/%d %H:%M.%S\"\n2009/12/12 00:00.00\n\n//格式转换后时间游走\n# date -d \"2009-12-12 2 year ago\" +\"%Y/%m/%d %H:%M.%S\"\n2007/12/12 00:00.37\n\n//加减操作：显示前一天的日期\n# date -d \"+1 day\" +%Y%m%d\n\n\n//设定日期时间\n# date -s \"2019-06-15 17:32:30\"\n\n//设置具体时间，不会对日期做更改\n# date -s 01:01:01\n\n\n//检查一组命令花费的时间\n#!/bin/bash\n\nstart=$(date +%s)\nnmap man.linuxde.net &amp;&gt; /dev/null\nend=$(date +%s)\ndifference=$(( end - start ))\necho $difference seconds.</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>cal</strong></h3>\n\n<ul>\n	<li>显示或设定系统日历</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>-n</td>\n			<td>显示近期 n 个月的日历</td>\n		</tr>\n		<tr>\n			<td>-s</td>\n			<td>将星期日作为月的第一天</td>\n		</tr>\n		<tr>\n			<td>-m</td>\n			<td>将星期一作为月的第一天</td>\n		</tr>\n		<tr>\n			<td>-y</td>\n			<td>显示当前年的日历</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# cal\n      June 2019     \nSu Mo Tu We Th Fr Sa\n                   1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487988830200,'2019-06-15 10:07:52','2019-06-15 10:07:52'),(299812442258448384,'<h1>搜索查找</h1>','sys','待编辑','<h3><strong>find</strong></h3>\n\n<ul>\n	<li>在指定目录下查找文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n			<th colspan=\"1\" scope=\"col\">&nbsp;</th>\n		</tr>\n		<tr>\n			<td>-atime&lt;天数&gt;</td>\n			<td>\n			<p>查找在指定天内曾被访问的文件</p>\n			</td>\n			<td>访问时间（-atime/天，-amin/分钟）<br>\n			修改时间（-mtime/天，-mmin/分钟）<br>\n			变化时间（-ctime/天，-cmin/分钟）</td>\n		</tr>\n		<tr>\n			<td>-name&lt;查询样式&gt;</td>\n			<td>查找名称符合样式的文件</td>\n			<td colspan=\"1\">忽略大小写（-iname）</td>\n		</tr>\n		<tr>\n			<td>-typ&lt;文件类型&gt;</td>\n			<td>查找指定类型的文件</td>\n			<td colspan=\"1\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>-user&lt;用户名&gt;</td>\n			<td>查找指定用户的文件</td>\n			<td colspan=\"1\">&nbsp;</td>\n		</tr>\n		<tr>\n			<td>-size&lt;文件大小&gt;</td>\n			<td>查找符合大小的文件</td>\n			<td colspan=\"1\">&nbsp;</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//查找以.txt结尾的文件\n# find /home -name \"*.txt\"\n\n//查找不以.txt结尾的文件\n# find /home ! -name \"*.txt\"\n\n//查找普通文件\n# find . -type f\n\n//搜索超过七天内被访问过的所有文件\n# find . -type f -atime +7</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>locate</strong></h3>\n\n<ul>\n	<li>是 find -name 的另一种写法，查询速度更快</li>\n	<li>基于数据库 /var/lib/locatedb&nbsp; 进行查询，查询前，先使用updatedb命令手动更新数据库。</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# locate test.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>whereis</strong></h3>\n\n<ul>\n	<li>查找文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-b</td>\n			<td>只查找二进制文件</td>\n		</tr>\n		<tr>\n			<td>\n			<p>-m</p>\n			</td>\n			<td>只查找说明文件</td>\n		</tr>\n		<tr>\n			<td>-s</td>\n			<td>只查找原始代码文件</td>\n		</tr>\n		<tr>\n			<td>-u</td>\n			<td>查找不包含指定类型的文件</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n#whereis -m bash</code></pre>\n\n<h3><strong>grep</strong></h3>\n\n<ul>\n	<li>找文件中符合条件的字符串</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-c</td>\n			<td>计算符合样式的列数</td>\n		</tr>\n		<tr>\n			<td>-e</td>\n			<td>多个样式同时查找（并集）</td>\n		</tr>\n		<tr>\n			<td>-E</td>\n			<td>使用正则表达式进行查找</td>\n		</tr>\n		<tr>\n			<td>-n</td>\n			<td>在显示符合范本样式的那一列之前，标示出该列的编号。</td>\n		</tr>\n		<tr>\n			<td>-o</td>\n			<td>只输出文件中匹配到的部分</td>\n		</tr>\n		<tr>\n			<td>-v</td>\n			<td>反转执行</td>\n		</tr>\n		<tr>\n			<td>-r</td>\n			<td>递归执行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//在文件中查找包含 abc 的行\n# grep abc file_name\n\n//在文件中查找不包含 abc 的行\n# grep -v abc file_name\n\n//使用正则表达式进行查找\n# grep -E \"[1-9]+\"\n\n//只输出文件中匹配到的部分\n# grep -o -E \"[a-z]+\\.\"\n\n//计数\n# grep -c \"text\" file_name\n# grep \"text\" -n file_name\n\n//配合管道\n# echo this is a text line | grep -e \"is\" -e \"line\" -o</code></pre>\n\n<p>&nbsp;</p>\n',0,299648487988830200,'2019-06-15 22:07:28','2019-06-15 22:07:28'),(299812455944462336,'<h1>压缩解压</h1>','sys','待编辑','<h3><strong>gzip</strong></h3>\n\n<ul>\n	<li>将文件压缩为 .gz 文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-l</td>\n			<td>列出压缩文件的相关信息</td>\n		</tr>\n		<tr>\n			<td>-r</td>\n			<td>递归执行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//压缩文件\n# gzip test.log\n\n//压缩目录下的所有文件\n# gzip * \n\n//显示压缩文件的信息\n# gzip -l *</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>gunzip</strong></h3>\n\n<ul>\n	<li>解压 .gz 文件</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# gunzip ab.gz</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>zip</strong></h3>\n\n<ul>\n	<li>将文件压缩为 .zip 文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-r</td>\n			<td>递归执行</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip\n# zip -r html.zip /home/html</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>unzip</strong></h3>\n\n<ul>\n	<li>解压&nbsp;.zip 文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-d&lt;目录&gt;</td>\n			<td>指定文件解压缩后所要存储的目录</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//将 mypackge.zip 解压到 /opt/tmp 目录下\n# unzip –d /opt/tmp  mypackage.zip</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>tar</strong></h3>\n\n<ul>\n	<li>备份文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-C</td>\n			<td>指定目标目录</td>\n		</tr>\n		<tr>\n			<td>-c</td>\n			<td>建立新的备份文件</td>\n		</tr>\n		<tr>\n			<td>-f</td>\n			<td>指定备份文件</td>\n		</tr>\n		<tr>\n			<td>-v</td>\n			<td>显示指令执行过程</td>\n		</tr>\n		<tr>\n			<td>-x</td>\n			<td>从备份文件中还原文件</td>\n		</tr>\n		<tr>\n			<td>-z</td>\n			<td>通过 gzip 指令处理备份文件</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//压缩文件\n# tar -zcvf a.tar.gz a1.txt a2.txt\n# tar -zcvf myhome.tar.gz /home/\n\n\n//解压到当前目录\n# tar -zxvf a.tar.gz\n\n//解压到其他目录\n# tar -zxvf myhome.tar.gz -C /opt/tmp2</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299648487988830200,'2019-06-15 16:09:40','2019-06-15 16:09:40'),(299916764250022888,'<h1>磁盘管理</h1>','sys','待编辑','<h3><strong>lsblk</strong></h3>\n\n<ul>\n	<li>列出所有可用块设备的信息，&nbsp;硬盘、U盘、光驱等</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-f</td>\n			<td>显示文件系统信息</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# lsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  398M  0 rom  \nsda      8:0    0  100G  0 disk \n├─sda1   8:1    0  200M  0 part /boot\n├─sda2   8:2    0    2G  0 part [SWAP]\n└─sda3   8:3    0 97.8G  0 part /</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>df</strong></h3>\n\n<ul>\n	<li>查询系统整体磁盘的使用情况</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-a</td>\n			<td>列出所有的文件系统</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-h</td>\n			<td>使用人类可读的格式</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda3        97G  815M   91G   1% /\ntmpfs           491M     0  491M   0% /dev/shm\n/dev/sda1       194M   28M  157M  15% /boot</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>du</strong></h3>\n\n<ul>\n	<li>查询指定目录的磁盘占用情况</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-a</td>\n			<td>显示各个文件的大小</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-c</td>\n			<td>额外显示显示总计</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-h</td>\n			<td>使用人类可读的格式</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">-s</td>\n			<td>仅显示总计</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# du -h /usr</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>实用指令</strong></h3>\n\n<pre><code class=\"language-bash\">//统计指定目录下文件的个数\n# ls -l /home/ | grep \"^-\" | wc -l\n# ls -lR /home/ | grep \"^-\" | wc -l   //递归执行\n\n//统计指定目录下目录的个数\n# ls -l /home/ | grep \"^d\" | wc -l\n# ls -lR /home/ | grep \"^d\" | wc -l   //递归执行\n\n//以树状显示目录结构\n# tree /home\n\n//如果没有tree 指令，可用 yum 进行安装\n# yum install tree</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>fdisk</strong></h3>\n\n<ul>\n	<li>磁盘分区表操作工具</li>\n</ul>\n',0,299648487988830200,'2019-06-15 17:19:47','2019-06-15 17:19:47'),(299924786263269376,'<h1>定时任务</h1>','sys','待编辑','<p><strong>1、定时任务分类</strong></p>\n\n<ul>\n	<li>系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li>\n	<li>个人执行的工作：某个用户定期要做的工作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、时程表格式</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th colspan=\"3\" scope=\"col\" style=\"text-align: center;\">f1 f2 f3 f4 f5 program</th>\n		</tr>\n		<tr>\n			<th scope=\"col\" style=\"text-align: center;\">标志位</th>\n			<th scope=\"col\">含义</th>\n			<th scope=\"col\">取值范围</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\">f1</td>\n			<td>一小时中的第几分钟</td>\n			<td>0-59</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">f2</td>\n			<td>一天中的第几小时</td>\n			<td>0-23</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">f3</td>\n			<td>一个月中的第几天</td>\n			<td>1-31</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">f4</td>\n			<td>一年中的第几月</td>\n			<td>1-12</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">f5</td>\n			<td>一周中的星期几</td>\n			<td>0-7</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">program</td>\n			<td>要执行的程序/命令</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align: center;\">符号</th>\n			<th scope=\"col\">含义</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>*</strong></td>\n			<td>代表任意值</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>，</strong></td>\n			<td>代表不连续的几个值</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>-</strong></td>\n			<td>代表连续的几个值</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>*/n</strong></td>\n			<td>代表以 n 为步进来取值</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n50 22 * * *        //每天22：50\n0 0 1,15 * *       //每月1号和15号的00:00\n00 03 * * 1-5      //每周一至周五的03:00\n0 6-12/3 * 12 *    //在十二月中, 每天的 06 点到 12 点，每隔 3 个小时的 0 分钟</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、设置定时任务</strong></p>\n\n<pre><code class=\"language-bash\">//1、编写任务脚本文件\n以 backupdb.sh 为例\n\n//2、赋予脚本文件执行权限\n# chmod &nbsp;u+x backupdb.sh\n\n//3、启动定时任务\n# crontab -e\n\n//4、添加定时调度指令，保存退出\n* 2 * * *  /home/backupdb.sh\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299648487988830200,'2019-06-15 20:06:56','2019-06-15 20:06:56'),(299969251531202560,'<h1>查看进程</h1>','sys','待编辑','<h3><strong>ps</strong></h3>\n\n<ul>\n	<li>显示进程信息</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-au</td>\n			<td>较详细的显示进程信息</td>\n		</tr>\n		<tr>\n			<td>-aux</td>\n			<td>显示所有进程信息</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# ps            //显示当前进行信息\n# ps -aux       //显示显示所有的进程信息\n# ps -u root    //显示用户root进程信息</code></pre>\n\n<p><img alt=\"20190616-044101-101.png\" src=\"/furesky/images/201906/20190616-044101-101.png\" style=\"height:133px; margin-left:23px; margin-right:23px; width:700px\"></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">列</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>USER</td>\n			<td>进程所属用户</td>\n		</tr>\n		<tr>\n			<td>PID</td>\n			<td>进程号</td>\n		</tr>\n		<tr>\n			<td>%CPU</td>\n			<td>占用CPU的百分比</td>\n		</tr>\n		<tr>\n			<td>%MEM</td>\n			<td>占用物理内存的百分比</td>\n		</tr>\n		<tr>\n			<td>VSZ</td>\n			<td>占用的虚拟内存大小（单位：KB）</td>\n		</tr>\n		<tr>\n			<td>RSS</td>\n			<td>占用的物理内存大小（单位：KB）</td>\n		</tr>\n		<tr>\n			<td>TTY</td>\n			<td>终端名称，缩写</td>\n		</tr>\n		<tr>\n			<td>STAT</td>\n			<td>\n			<p>进程状态，</p>\n\n			<p>S-睡眠、s-先导进程、N-低优先级、</p>\n\n			<p>R-正在运行、D-短期等待、Z-僵死进程、T-暂停执行</p>\n			</td>\n		</tr>\n		<tr>\n			<td>STARTED</td>\n			<td>进程的启动时间</td>\n		</tr>\n		<tr>\n			<td>TIME</td>\n			<td>进程执行的总时间</td>\n		</tr>\n		<tr>\n			<td>COMMAND</td>\n			<td>所执行的指令</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h3><strong>pstree</strong></h3>\n\n<ul>\n	<li>以树状图显示进程信息</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-p</td>\n			<td>显示进程的 PID</td>\n		</tr>\n		<tr>\n			<td>-u</td>\n			<td>显示进程的所属用户</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//示例\n# pstree -u</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>top</strong></h3>\n\n<ul>\n	<li>实时显示进程的动态信息，默认每3秒刷新一次</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-d</td>\n			<td>改变显示的更新速度</td>\n		</tr>\n		<tr>\n			<td>-i</td>\n			<td>不显示闲置或僵死进程</td>\n		</tr>\n		<tr>\n			<td>-p</td>\n			<td>仅监控指定 PID 的进程</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">按键</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>Shift+p</td>\n			<td>以CPU使用率排序</td>\n		</tr>\n		<tr>\n			<td>Shift+m</td>\n			<td>以内存的使用率排序</td>\n		</tr>\n		<tr>\n			<td>Shift+n</td>\n			<td>以 PID 排序</td>\n		</tr>\n		<tr>\n			<td>q</td>\n			<td>退出 top</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n',0,299968191760605184,'2019-06-15 21:18:34','2019-06-15 21:18:34'),(299983883801108480,'<h1>终止进程</h1>','sys','待编辑','<h3><strong>kill</strong></h3>\n\n<ul>\n	<li>通过进程号杀死进程</li>\n</ul>\n\n<pre><code class=\"language-bash\">//示例\n# kill 12345        //杀死进程\n# kill -9 123456    //强制杀死进程</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>killall</strong></h3>\n\n<ul>\n	<li>通过进程名称杀死进程，支持通配符</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-l</td>\n			<td>忽略大小写</td>\n		</tr>\n		<tr>\n			<td>-i</td>\n			<td>杀死进程前先询问</td>\n		</tr>\n		<tr>\n			<td>-p</td>\n			<td>杀死进程所属的进程组</td>\n		</tr>\n		<tr>\n			<td>-r</td>\n			<td>使用正规表达式进行匹配</td>\n		</tr>\n		<tr>\n			<td>-u</td>\n			<td>杀死指定用户的进程</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//杀死所有同名进程\n# killall vi</code></pre>\n\n<p>&nbsp;</p>\n',0,299968191760605184,'2019-06-15 22:05:04','2019-06-15 22:05:04'),(299987839700869120,'<h1>服务管理</h1>','sys','待编辑','<p><strong>服务</strong></p>\n\n<ul>\n	<li>服务(service) 本质就是进程，又称为守护进程</li>\n	<li>服务是运行在后台的，通常都会监听某个端口，等待其它程序的请求。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>service</strong></h3>\n\n<ul>\n	<li>启动、停止、重启和关闭系统服务</li>\n</ul>\n\n<pre><code class=\"language-bash\">//语法\nservice 服务名 [start | stop | restart | reload | status]\n\n//示例\nservice mysqld status     //查询 mysql 服务状态  \nservice mysqld restart    //重启 mysql 服务</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>chkconfig</strong></h3>\n\n<ul>\n	<li>检查，设置系统服务</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>--add</td>\n			<td>增加所指定的系统服务</td>\n		</tr>\n		<tr>\n			<td>--list</td>\n			<td>列出所有的系统服务的信息</td>\n		</tr>\n		<tr>\n			<td>--del</td>\n			<td>删除所指定的系统服务</td>\n		</tr>\n		<tr>\n			<td>--level&lt;运行级别&gt;</td>\n			<td>设定服务在某运行级别下开启/关闭/重启</td>\n		</tr>\n	</thead>\n</table>\n\n<pre>\n<code class=\"language-bash\">//格式\nchkconfig [--add][--del][--list][系统服务] \nchkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset]\n\n//开启Telnet服务\n# chkconfig telnet on\n\n//列出chkconfig所知道的所有的服务的情况\n# chkconfig --list       \n\n//在运行级别为5时，关闭iptables 服务\n# chkconfig --level 5 iptables off</code></pre>\n\n<p>&nbsp;</p>\n',0,299968191760605184,'2019-06-15 21:54:51','2019-06-15 21:54:51'),(299993561083846656,'<h1>监控网络状态</h1>','sys','待编辑','<h3><strong>netstat</strong></h3>\n\n<ul>\n	<li>显示网络状态</li>\n</ul>\n\n<pre><code class=\"language-bash\">//显示详细的网络状况\n# netstat -a  \n\n//\n# netstat -nap  \n\n//显示当前户籍UDP连接状况\n# netstat -nu\n\n//显示UDP端口号的使用情况\n# netstat -apu\n\n//显示网卡列表\n# netstat -i\n\n//显示组播组的关系\n# netstat -g\n\n//显示网络统计信息\n# netstat -s\n\n//显示监听的套接口\n# netstat -l</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,299968191760605184,'2019-06-17 23:34:28','2019-06-17 23:34:28'),(299996218976542720,'<h1>rpm、yum</h1>','sys','待编辑','<h3><strong>rpm</strong></h3>\n\n<ul>\n	<li>软件包的管理工具</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">选项</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>-a</td>\n			<td>查询所有套件</td>\n		</tr>\n		<tr>\n			<td>-e&lt;套件&gt;</td>\n			<td>删除指定的套件</td>\n		</tr>\n		<tr>\n			<td>-f&lt;文件&gt;</td>\n			<td>查询拥有指定文件的套件</td>\n		</tr>\n		<tr>\n			<td>-h</td>\n			<td>进度标记</td>\n		</tr>\n		<tr>\n			<td>-i&lt;套件&gt;</td>\n			<td>安装指定的套件</td>\n		</tr>\n		<tr>\n			<td>-i</td>\n			<td>显示套件的相关信息</td>\n		</tr>\n		<tr>\n			<td>-l</td>\n			<td>显示套件的文件列表</td>\n		</tr>\n		<tr>\n			<td>-v</td>\n			<td>显示指令执行过程</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li><strong>查看 RPM 包</strong></li>\n</ul>\n\n<p><img alt=\"\" src=\"/furesky/images/201906/20190616-062025-025.png\" style=\"height:219px; margin-left:40px; margin-right:40px; width:700px\"></p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li><strong>安装、卸载 RPM 包</strong></li>\n</ul>\n\n<pre><code class=\"language-bash\">//语法\nrpm -ivh RPM包绝对路径   //安装\nrpm -e RPM包            //卸载\n\n//示例\n# rpm -ivh /opt/firefox-xxx.centos.x86_64.rpm\n# rpm -e firefox</code></pre>\n\n<p>&nbsp;</p>\n\n<h3><strong>yum</strong></h3>\n\n<ul>\n	<li>是一个Shell前端软件包管理器</li>\n	<li>提供了查找、安装、删除某一个、一组甚至全部软件包的命令</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>yum check-update</td>\n			<td>列出所有可更新的软件命令</td>\n		</tr>\n		<tr>\n			<td>yum update</td>\n			<td>更新所有软件命令</td>\n		</tr>\n		<tr>\n			<td>yum install &lt;package_name&gt;</td>\n			<td>仅安装指定的软件命令</td>\n		</tr>\n		<tr>\n			<td>yum update &lt;package_name&gt;</td>\n			<td>仅更新指定的软件命令</td>\n		</tr>\n		<tr>\n			<td>yum list</td>\n			<td>列出所有可安裝的软件命令</td>\n		</tr>\n		<tr>\n			<td>yum remove &lt;package_name&gt;</td>\n			<td>删除软件包命令</td>\n		</tr>\n		<tr>\n			<td>yum search &lt;keyword&gt;</td>\n			<td>查找软件包命令</td>\n		</tr>\n		<tr>\n			<td>yum clean</td>\n			<td>清除缓存目录下的软件包及旧的headers</td>\n		</tr>\n		<tr>\n			<td>yum clean packages</td>\n			<td>清除缓存目录下的软件包</td>\n		</tr>\n		<tr>\n			<td>yum clean headers</td>\n			<td>清除缓存目录下的 headers</td>\n		</tr>\n		<tr>\n			<td>yum clean oldheaders</td>\n			<td>清除缓存目录下旧的 headers</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\">//安装火狐\n# yum install firefox    //会下载适合当前系统的最新版本软件包</code></pre>\n\n<p>&nbsp;</p>\n',0,299969176256028672,'2019-06-15 22:35:30','2019-06-15 22:35:30'),(300045831431430145,'<h1>Shell 概述</h1>','sys','待编辑','<p><strong>1、Shell</strong></p>\n\n<ul>\n	<li>是一个<span style=\"color:#c0392b\">命令行解释器</span>，它接收应用程序/用户命令，然后调用操作系统内核。</li>\n	<li>是一个功能相当强大的编程语言，易编写、易调试、灵活性强。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Shell 与 Linux</strong></p>\n\n<ul>\n	<li>通过Shell提供的界面，用户可以访问操作系统内核的服务</li>\n</ul>\n\n<p><img alt=\"20190616-084452-452.png\" src=\"/furesky/images/201906/20190616-084452-452.png\" style=\"height:264px; margin-left:23px; margin-right:23px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Linux 提供的 Shell 解析器</strong></p>\n\n<ul>\n	<li><span style=\"color:#c0392b\">/bin/sh</span></li>\n	<li><span style=\"color:#c0392b\">/bin/bash</span></li>\n	<li>/sbin/nologin</li>\n	<li>/bin/dash</li>\n	<li>/bin/tcsh</li>\n	<li>/bin/csh</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,300045831431430144,'2019-06-16 01:27:32','2019-06-16 01:27:32'),(300045831431430155,'<h1>Shell 脚本示例</h1>','sys','待编辑','<p><strong>1、脚本格式</strong></p>\n\n<ul>\n	<li>脚本以<span style=\"color:#c0392b\"> #!/bin/bash </span>开头（指定解析器）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、脚本示例</strong></p>\n\n<ul>\n	<li>创建脚本</li>\n</ul>\n\n<pre><code class=\"language-bash\">[jianda@node01 ~]$ touch hello.sh\n[jianda@node01 ~]$ vi hello.sh\n\n在hello.sh中输入如下内容\n#!/bin/bash\necho \"hello world\"</code></pre>\n\n<ul>\n	<li>执行脚本</li>\n</ul>\n\n<pre><code class=\"language-bash\">//方式一：sh 或 bash\n[jianda@node01 ~]$ sh hello.sh\n[jianda@node01 ~]$ bash /home/jianda/hello.sh\n\n//方式二：输入脚本路径，须具有执行权限\n[jianda@node01 ~]$ ./hello.sh\n[jianda@node01 ~]$ /home/jianda/hello.sh\n</code></pre>\n\n<p>&nbsp;</p>\n',0,300045831431430144,'2019-06-16 01:22:53','2019-06-16 01:04:14'),(300046510577328128,'<h1>Shell 注释</h1>','sys','待编辑','<p><strong>1、单行注释</strong></p>\n\n<pre><code class=\"language-bash\"># 注释内容...</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、多行注释</strong></p>\n\n<ul>\n	<li>可以用其他符号替代EOF</li>\n	<li>定义成无用函数</li>\n</ul>\n\n<pre><code class=\"language-bash\">:&lt;&lt;EOF\n注释内容...\n注释内容...\n注释内容...\nEOF\n\n\n{\n    注释内容...\n    注释内容...\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,300046265172795392,'2019-06-16 23:23:35','2019-06-16 22:43:36'),(300046527568453632,'<h1>Shell 数组</h1>','sys','待编辑','<p><strong>1、特点</strong></p>\n\n<ul>\n	<li>&nbsp;Shell 只支持一维数组，不限定数组的大小</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义数组</strong></p>\n\n<ul>\n	<li>方式一</li>\n</ul>\n\n<pre><code class=\"language-bash\"># 语法\narray_name=(value1 ... valuen)\n\n# 示例\nmy_array=(A B \"C\" D)</code></pre>\n\n<ul>\n	<li>方式二</li>\n</ul>\n\n<pre><code class=\"language-bash\"># 直接定义数组元素\narray_name[0]=value0\narray_name[1]=value1\narray_name[n]=valuen\n\n# 示例\nmy_array[0]=A\nmy_array[1]=B\nmy_array[2]=C\nmy_array[3]=D</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、读取数组</strong></p>\n\n<ul>\n	<li>@ 或 * 可以获取数组中的所有元素</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>获取数组元素值</p>\n			</td>\n			<td>\n			<p>${array_name[n]}</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>获取数组所有元素</p>\n			</td>\n			<td>\n			<p>${array_name[*]}</p>\n\n			<p>${array_name[@]}</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>获取数组的长度</p>\n			</td>\n			<td>\n			<p>${#array_name[*]}<br>\n			${#array_name[@]}</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>获取数组单个元素的长度</p>\n			</td>\n			<td>\n			<p>${#array_name[n]}</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,300046265172795392,'2019-06-16 23:23:20','2019-06-16 01:55:36'),(300046544375029760,'<h1>Shell 字符串</h1>','sys','待编辑','<p><strong>1、单引号字符串</strong></p>\n\n<ul>\n	<li>单引号里，变量无效</li>\n	<li>单引号里，只能成对的出现单引号</li>\n</ul>\n\n<pre><code class=\"language-bash\">str=\'xiaoming\'</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、双引号字符串</strong></p>\n\n<ul>\n	<li>双引号里可以有变量</li>\n	<li>双引号里可以出现转义字符</li>\n</ul>\n\n<pre><code class=\"language-bash\">str=\"xiaoming\"</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、拼接字符串</strong></p>\n\n<pre><code class=\"language-bash\">str=\"xiaoming\"\n\n# 使用单引号进行拼接变量\necho \'hello, \'$str\' !\'\n\n# 使用双引号拼接变量\necho \"hello, \"$str\" !\"\necho \"hello, $str !\"\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、获取字符串长度</strong></p>\n\n<pre><code class=\"language-bash\">string=\"abcd\"\necho ${#string}    #输出 4</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、提取子字符串</strong></p>\n\n<pre><code class=\"language-bash\"># 从字符串第 2 个字符开始截取 4 个字符\nstring=\"helloworld\"\necho ${string:1:4}    # 输出 ello</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、查找子字符串</strong></p>\n\n<ul>\n	<li>备注：是反引号，不是单引号\'</li>\n</ul>\n\n<pre><code class=\"language-bash\"># 查找字符 i 或 o 的位置\nstring=\"helloworld\"\necho `expr index \"$string\" io`   # 输出 5</code></pre>\n\n<p>&nbsp;</p>\n',0,300046265172795392,'2019-06-16 23:23:21','2019-06-16 02:30:18'),(300046544375029765,'<h1>Shell 转义字符</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>\\a</td>\n			<td>警告字符，通常为ASCII的BEL字符</td>\n		</tr>\n		<tr>\n			<td>\\b</td>\n			<td>后退</td>\n		</tr>\n		<tr>\n			<td>\\c</td>\n			<td>忽略结果中的换行字符</td>\n		</tr>\n		<tr>\n			<td>\\f</td>\n			<td>换页（formfeed）</td>\n		</tr>\n		<tr>\n			<td>\\n</td>\n			<td>换行</td>\n		</tr>\n		<tr>\n			<td>\\r</td>\n			<td>回车（Carriage return）</td>\n		</tr>\n		<tr>\n			<td>\\t</td>\n			<td>水平制表符</td>\n		</tr>\n		<tr>\n			<td>\\v</td>\n			<td>垂直制表符</td>\n		</tr>\n		<tr>\n			<td>\\\\</td>\n			<td>一个字面上的反斜杠字符</td>\n		</tr>\n		<tr>\n			<td>\\ddd</td>\n			<td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td>\n		</tr>\n		<tr>\n			<td>\\0ddd</td>\n			<td>表示1到3位的八进制值字符</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,300046265172795392,'2019-06-16 23:39:28','2019-06-16 23:39:28'),(300046544375029780,'<h1>Shell 变量</h1>','sys','待编辑','<p><strong>1、命名规则</strong></p>\n\n<ul>\n	<li>字母、数字、下划线，不能以数字开头&nbsp;</li>\n	<li>不能有空格、标点符号&nbsp;</li>\n	<li>不能使用关键字</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义变量</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">说明</th>\n			<th scope=\"col\">示例</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>全局变量</td>\n			<td>变量名和等号之间不能有空格</td>\n			<td>myStr=\"abc\"</td>\n		</tr>\n		<tr>\n			<td>局部变量</td>\n			<td>\n			<p>local，只能在函数内部使用</p>\n			</td>\n			<td>local myStr=\"abc\"</td>\n		</tr>\n		<tr>\n			<td>只读变量</td>\n			<td>readonly</td>\n			<td>readonly&nbsp;myStr</td>\n		</tr>\n		<tr>\n			<td>环境变量</td>\n			<td>export</td>\n			<td>export myStr</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、操作变量</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">格式</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>使用变量&nbsp;</td>\n			<td>${变量名}</td>\n			<td>可以省略{}，不推荐</td>\n		</tr>\n		<tr>\n			<td>删除变量</td>\n			<td>unset 变量名</td>\n			<td>不能删除只读变量</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 示例\nmyStr=\"xiaoming\"\necho ${myStr}\necho $myStr\nunset myStr</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、查询变量</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>set</td>\n			<td>显示当前 shell 的变量，包括当前用户的变量;</td>\n		</tr>\n		<tr>\n			<td>env</td>\n			<td>显示当前用户的变量</td>\n		</tr>\n		<tr>\n			<td>export</td>\n			<td>显示当前导出成用户变量的 shell 变量</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、变量作用域</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">作用域</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>局部变量</td>\n			<td>函数内部</td>\n		</tr>\n		<tr>\n			<td>全局变量</td>\n			<td>当前 shell 进程</td>\n		</tr>\n		<tr>\n			<td>临时环境变量</td>\n			<td>当前 shell 进程及其子 shell 进程</td>\n		</tr>\n		<tr>\n			<td>永久环境变量</td>\n			<td>所有 shell 进程</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、引入文件</strong></p>\n\n<ul>\n	<li>引入文件到当前 shell 进程，并执行文件语句。</li>\n	<li>常用于使文件立即生效</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">格式</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>source</td>\n			<td>source filename</td>\n		</tr>\n		<tr>\n			<td>\n			<p><strong><span style=\"background-color:#dddddd\">&nbsp; .&nbsp;&nbsp;</span></strong></p>\n			</td>\n			<td>\n			<p>. filename</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、永久环境变量</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>系统变量</td>\n			<td><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">$HOME</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">、</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">$PWD</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">、</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">$SHELL</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:宋体\">、</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\">$USER等</span></span></td>\n		</tr>\n		<tr>\n			<td>所有用户</td>\n			<td>配置文件：/etc/profile</td>\n		</tr>\n		<tr>\n			<td>特定用户</td>\n			<td>配置文件：$HOME/.bash_profile</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、特殊变量</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>$n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>\n			<td>\n			<p>$0 代表该脚本名称，</p>\n\n			<p>$1 - $9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</p>\n			</td>\n		</tr>\n		<tr>\n			<td>$#</td>\n			<td>参数个数</td>\n		</tr>\n		<tr>\n			<td>$*</td>\n			<td>全部参数（形式：\"$1 $2 … $n\"）</td>\n		</tr>\n		<tr>\n			<td>$@</td>\n			<td>全部参数（形式：\"$1\" \"$2\" … \"$n\"）</td>\n		</tr>\n		<tr>\n			<td>$?</td>\n			<td>最后命令的返回状态。</td>\n		</tr>\n	</tbody>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>$$</td>\n			<td>脚本运行的当前进程ID号</td>\n		</tr>\n		<tr>\n			<td>$!</td>\n			<td>后台运行的最后一个进程的ID号</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,300289641222676480,'2019-06-17 03:07:36','2019-06-17 03:07:36'),(300064593807319040,'<h1>Shell 运算符</h1>','sys','待编辑','<p><strong>1、运算方式</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">方式</th>\n			<th scope=\"col\">示例</th>\n			<th scope=\"col\">注意</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\"><strong>[ ]</strong></td>\n			<td>sum=$[ 2 + 1 ]</td>\n			<td colspan=\"1\" rowspan=\"3\">注意空格</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>(( ))</strong></td>\n			<td>sum=$(( 2 + 1 ))</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>expr</strong></td>\n			<td>sum=`expr 2 + 1`</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\"><strong>let</strong></td>\n			<td>let sum=2+1</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\"># 是反引号，不是单引号\n# 写成 2+2 是不对的\n\nval=`expr 2 + 2`             \necho \"两数之和为 : $val\" \n</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>2、算术运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">+</th>\n			<th scope=\"col\" style=\"text-align:center\">-</th>\n			<th scope=\"col\" style=\"text-align:center\">*</th>\n			<th scope=\"col\" style=\"text-align:center\">/</th>\n			<th scope=\"col\" style=\"text-align:center\">%</th>\n			<th scope=\"col\" style=\"text-align:center\">=</th>\n			<th scope=\"col\" style=\"text-align:center\">==</th>\n			<th scope=\"col\" style=\"text-align:center\">！=</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">加法</td>\n			<td style=\"text-align:center\">减法</td>\n			<td style=\"text-align:center\">乘法</td>\n			<td style=\"text-align:center\">除法</td>\n			<td style=\"text-align:center\">取余</td>\n			<td style=\"text-align:center\">赋值</td>\n			<td style=\"text-align:center\">相等</td>\n			<td style=\"text-align:center\">不相等</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 乘号(*)须先转义\n# 假定变量 a 为 10，变量 b 为 20\n\n`expr $a + $b`      # 30\n`expr $a - $b`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# -10\n`expr $a \\* $b`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 200\n`expr $b / $a`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 2\n`expr $b % $a`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 0\na=$b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 把 b 赋给 a\n[ $a == $b ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ $a != $b ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# true\n</code></pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>3、关系运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">-eq</th>\n			<th scope=\"col\" style=\"text-align:center\">-ne</th>\n			<th scope=\"col\" style=\"text-align:center\">-gt</th>\n			<th scope=\"col\" style=\"text-align:center\">-lt</th>\n			<th scope=\"col\" style=\"text-align:center\">-ge</th>\n			<th scope=\"col\" style=\"text-align:center\">-le</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">相等</td>\n			<td style=\"text-align:center\">不相等</td>\n			<td style=\"text-align:center\">大于</td>\n			<td style=\"text-align:center\">小于</td>\n			<td style=\"text-align:center\">大于等于</td>\n			<td style=\"text-align:center\">小于等于</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 条件表达式要放在方括号之间，并且要有空格\n# 假定变量 a 为 10，变量 b 为 20\n\n[ $a -eq $b ]    # false\n[ $a -ne $b ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ $a -gt $b ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ $a -lt $b ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ $a -ge $b ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ $a -le $b ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、布尔运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:300px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">-a</th>\n			<th scope=\"col\" style=\"text-align:center\">-o</th>\n			<th scope=\"col\" style=\"text-align:center\">!</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">与</td>\n			<td style=\"text-align:center\">或</td>\n			<td style=\"text-align:center\">非</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 假定变量 a 为 10，变量 b 为 20\n\n[ $a -lt 20 -a $b -gt 100 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # false\n[ $a -lt 20 -o $b -gt 100 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # true\n[ ! false ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # true</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、逻辑运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:300px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">&amp;&amp;</th>\n			<th scope=\"col\" style=\"text-align:center\">||</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">逻辑与</td>\n			<td style=\"text-align:center\">逻辑或</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 假定变量 a 为 10，变量 b 为 20\n\n[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]    # false\n[[ $a -lt 100 || $b -gt 100 ]]    # true</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、字符串运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">=</th>\n			<th scope=\"col\" style=\"text-align:center\">!=</th>\n			<th scope=\"col\" style=\"text-align:center\">-z</th>\n			<th scope=\"col\" style=\"text-align:center\">-n</th>\n			<th scope=\"col\" style=\"text-align:center\">str</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">相等</td>\n			<td style=\"text-align:center\">不相等</td>\n			<td style=\"text-align:center\">长度为0</td>\n			<td style=\"text-align:center\">长度不为0</td>\n			<td style=\"text-align:center\">不为空</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 假定变量 a 为 \"abc\"，变量 b 为 \"efg\"\n\n[ $a = $b ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ $a != $b ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -z $a ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ -n \"$a\" ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ $a ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# true</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、文件运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">-b file</th>\n			<th scope=\"col\" style=\"text-align:center\">-c file</th>\n			<th scope=\"col\" style=\"text-align:center\">-d file</th>\n			<th scope=\"col\" style=\"text-align:center\">-f file</th>\n			<th scope=\"col\" style=\"text-align:center\">-p file</th>\n			<th scope=\"col\" style=\"text-align:center\">-r file</th>\n			<th scope=\"col\" style=\"text-align:center\">-w file</th>\n			<th scope=\"col\" style=\"text-align:center\">-x file</th>\n			<th scope=\"col\" style=\"text-align:center\">-s file</th>\n			<th scope=\"col\" style=\"text-align:center\">-e file</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"text-align:center\">块设备文件</td>\n			<td style=\"text-align:center\">字符设备文件</td>\n			<td style=\"text-align:center\">目录</td>\n			<td style=\"text-align:center\">普通文件</td>\n			<td style=\"text-align:center\">有名管道</td>\n			<td style=\"text-align:center\">可读</td>\n			<td style=\"text-align:center\">可写</td>\n			<td style=\"text-align:center\">可执行</td>\n			<td style=\"text-align:center\">不为空</td>\n			<td style=\"text-align:center\">存在</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\"># 假定变量 file 表示文件 /var/test.sh，它的大小为 100 字节，具有 rwx 权限\n\n[ -b $file ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ -c $file ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ -d $file ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ -f $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -p $file ]&nbsp;&nbsp;&nbsp;&nbsp;# false\n[ -r $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -w $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -x $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -s $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true\n[ -e $file ]&nbsp;&nbsp;&nbsp;&nbsp;# true</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,300289641222676480,'2019-06-17 03:37:38','2019-06-17 03:37:38'),(300337444288372736,'<h1>Shell 流程控制</h1>','sys','待编辑','<p><strong>1、if 语句</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td colspan=\"3\">格式</td>\n		</tr>\n		<tr>\n			<td>\n			<p><span style=\"color:#0000ff\"><strong>if&nbsp;&nbsp;</strong></span>[ 条件表达式 ]</p>\n\n			<p><span style=\"color:#0000ff\"><strong>then</strong><br>\n			&nbsp; &nbsp; </span>......<br>\n			<span style=\"color:#0000ff\"><strong>fi</strong></span></p>\n\n			<p>&nbsp;</p>\n\n			<p>&nbsp;</p>\n\n			<p>&nbsp;</p>\n\n			<p>&nbsp;</p>\n			</td>\n			<td>\n			<p><span style=\"color:#0000ff\"><strong>if&nbsp;&nbsp;</strong></span>[ 条件表达式 ]</p>\n\n			<p><span style=\"color:#0000ff\"><strong>then</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>else</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>fi</strong></span></p>\n\n			<p>&nbsp;</p>\n\n			<p>&nbsp;</p>\n			</td>\n			<td>\n			<p><span style=\"color:#0000ff\"><strong>if&nbsp;&nbsp;</strong></span>[ 条件表达式 ]</p>\n\n			<p><span style=\"color:#0000ff\"><strong>then<br>\n			&nbsp;</strong> </span>&nbsp; ......<br>\n			<strong><span style=\"color:#c0392b\">elif</span><span style=\"color:#0000ff\">&nbsp;&nbsp;</span></strong>[ 条件表达式 ]</p>\n\n			<p><span style=\"color:#0000ff\"><strong>then&nbsp;</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>else</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>fi</strong></span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>注意事项\n	<ul>\n		<li>if 后要有空格</li>\n		<li>[ 条件表达式 ] 中括号和条件判断式之间必须有空格</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\nnum1=$[2*3]\nnum2=$[1+5]\nif test $[num1] -eq $[num2]\nthen\n    echo \'两个数字相等!\'\nelse\n    echo \'两个数字不相等!\'\nfi\n\n# test命令：检测是否成立</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、for 循环</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td colspan=\"2\">格式</td>\n		</tr>\n		<tr>\n			<td><strong><span style=\"color:#0000ff\">for&nbsp;&nbsp;((</span></strong> 初始值;循环控制条件;变量变化 <strong><span style=\"color:#0000ff\">))</span></strong><br>\n			<span style=\"color:#0000ff\"><strong>do</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>done</strong></span></td>\n			<td>\n			<p><span style=\"color:#0000ff\"><strong>for&nbsp;&nbsp;</strong></span>var&nbsp;<span style=\"color:#0000ff\"><strong> in&nbsp;&nbsp;</strong></span>item1&nbsp; item2&nbsp; ...&nbsp; itemN<br>\n			<span style=\"color:#0000ff\"><strong>do</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>done</strong></span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\n# 示例一\ns=0\nfor((i=0;i&lt;=100;i++))\ndo\n        s=$[$s+$i]\ndone\n\n# 示例二\nfor str in \'This is a string\'\ndo\n    echo $str\ndone</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、while 语句</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>格式</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#0000ff\"><strong>while&nbsp;&nbsp;</strong></span>[ 条件表达式 ]<br>\n			<span style=\"color:#0000ff\"><strong>do</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>done</strong></span></td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\nint=1\nwhile(( $int&lt;=5 ))\ndo\n    echo $int\n    let \"int++\"\ndone</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、until 语句</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>格式</td>\n		</tr>\n		<tr>\n			<td><span style=\"color:#0000ff\"><strong>until&nbsp;&nbsp;</strong></span>[ 条件表达式 ]<br>\n			<span style=\"color:#0000ff\"><strong>do</strong></span><br>\n			&nbsp; &nbsp; ......<br>\n			<span style=\"color:#0000ff\"><strong>done</strong></span></td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\na=0\nuntil [ ! $a -lt 10 ]\ndo\n   echo $a\n   a=`expr $a + 1`\ndone</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、case 语句</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>格式</td>\n		</tr>\n		<tr>\n			<td>\n			<p><span style=\"color:#0000ff\"><strong>case&nbsp;&nbsp;</strong></span>$变量名<span style=\"color:#0000ff\"><strong>&nbsp; in<br>\n			&nbsp; &nbsp; </strong></span>值1<span style=\"color:#0000ff\"><strong>)&nbsp; &nbsp;&nbsp;</strong></span>......<br>\n			<span style=\"color:#0000ff\"><strong>&nbsp; &nbsp; ;;<br>\n			&nbsp; &nbsp; </strong></span>值2<span style=\"color:#0000ff\"><strong>)&nbsp; &nbsp;&nbsp;</strong></span>......<br>\n			<span style=\"color:#0000ff\"><strong>&nbsp; &nbsp; ;;</strong></span></p>\n\n			<p><span style=\"color:#0000ff\">&nbsp; </span>&nbsp; ......<br>\n			<span style=\"color:#0000ff\">&nbsp; &nbsp; <strong>*)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong></span>......</p>\n\n			<p><span style=\"color:#0000ff\">&nbsp; &nbsp; <strong>;;</strong></span></p>\n\n			<p><span style=\"color:#0000ff\"><strong>esac</strong></span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>备注\n	<ul>\n		<li><span style=\"color:#0000ff\"><strong>;;&nbsp; &nbsp; &nbsp;</strong></span>相当于 Java 中的 break</li>\n		<li><span style=\"color:#0000ff\"><strong>*)&nbsp; &nbsp;&nbsp;</strong></span>相当于 Java 中的 default</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\nread aNum\ncase $aNum in\n    1)  echo \'你选择了 1\'\n    ;;\n    2)  echo \'你选择了 2\'\n    ;;\n    3)  echo \'你选择了 3\'\n    ;;\n    *)  echo \'你没有输入 1 到 3 之间的数字\'\n    ;;\nesac\n\n\n# read 命令：读取控制台输入\n# -p：指定读取值时的提示符；\n# -t：指定读取值时等待的时间（秒）</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、跳出循环</strong></p>\n\n<ul>\n	<li>continue</li>\n	<li>break</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,300289641222676480,'2019-06-17 00:04:34','2019-06-17 00:04:34'),(300355314984591360,'<h1>Shell 函数</h1>','sys','待编辑','<p><strong>1、系统函数</strong></p>\n\n<ul>\n	<li>basename：获取文件名</li>\n</ul>\n\n<pre><code class=\"language-bash\">// 语法\nbasename [string / pathname] [suffix]\n\n// 示例一\n[jianda@node01 ~]$ basename /home/jianda/test.txt \ntest.txt\n\n// 示例二\n[jianda@node01 ~]$ basename /home/jianda/test.txt .txt\ntest\n</code></pre>\n\n<ul>\n	<li>dirname：获取目录</li>\n</ul>\n\n<pre><code class=\"language-bash\">// 语法\ndirname 文件绝对路径\n\n// 示例\n[jianda@node01 ~]$ dirname /home/jianda/test.txt \n/home/jianda</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、自定义函数</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>语法</td>\n		</tr>\n		<tr>\n			<td>\n			<p>[ <span style=\"color:#0000ff\"><strong>function</strong></span> ] funname [()]{</p>\n\n			<p>&nbsp; &nbsp; action;</p>\n\n			<p>&nbsp; &nbsp; [<span style=\"color:#0000ff\"><strong>return</strong></span> int;]</p>\n\n			<p>}</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>定义函数\n	<ul>\n		<li>关键字 function 可省略，不带任何参数</li>\n		<li>隐式返回：默认返回最后一条命令的运行结果</li>\n		<li>显式返回：可用 return n; 显式返回，n为 0-255 的数值</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>调用函数\n	<ul>\n		<li>仅使用函数名即可</li>\n		<li>函数调用前，必须先定义</li>\n		<li>函数内部，以$n的形式获取参数，n大于9时用${n}</li>\n		<li>函数返回值在调用该函数后通过 $? 来获得。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>示例</li>\n</ul>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n\nfunWithReturn(){\n    echo \"请输入一个字符: \"\n    read str\n    return 0\n}\nfunWithReturn\necho \"你输入的字符为 $str\"\necho \"函数运行结果为 $?\"\n\n\n# 运行结果\n{\n请输入一个字符: \na\n你输入的字符为 a\n函数运行结果为 0\n}</code></pre>\n\n<pre><code class=\"language-bash\">#!/bin/bash\nfunWithParam(){\n    echo \"第一个参数为 $1 \"\n    echo \"第二个参数为 $2 \"\n    echo \"第十个参数为 $10 \"\n    echo \"第十个参数为 ${10} \"\n    echo \"第十一个参数为 ${11} \"\n    echo \"参数总数有 $# 个\"\n    echo \"作为一个字符串输出所有参数 $* \"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n# 输出结果：\n第一个参数为 1 \n第二个参数为 2 \n第十个参数为 10 \n第十个参数为 34 \n第十一个参数为 73 \n参数总数有 11 个\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 </code></pre>\n\n<p>&nbsp;</p>\n',0,300289641222676480,'2019-06-16 23:25:44','2019-06-16 23:08:28'),(301059347021996032,'<h1>学习网站</h1>','sys','待编辑','<p>步骤：</p>\n\n<p>1、搭建本地cms网站，先做到能够管理自己的学习笔记。</p>\n\n<p>2、优化，达到个人网站的级别</p>\n\n<p>3、合适时机，将网站搬上互联网</p>\n\n<p>4、一步步优化，添加功能....</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>方向：</p>\n\n<p>1、功能</p>\n\n<ul>\n	<li>用户能快速找到所需要的学习资料，通过浏览资料，产生消费</li>\n	<li>学习资料含金量高，可精简可详细，可简单可深入</li>\n	<li>用户能发布学习资料，通过发布资料赚取佣金</li>\n	<li>用户能编辑自己的学习笔记，作为之后学习之用，也可将笔记进行发布</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、理念</p>\n\n<ul>\n	<li>自驱动：\n	<ul>\n		<li>网站一切行为均依靠用户个人驱动。东西是死的，而人是活的，通过用户的行为，驱动网站内容优化，最为高效</li>\n		<li>根据资料的浏览消费情况，评价情况，进行资料筛选，排行其含金量</li>\n		<li>根据用户发布资料的情况，学习时间、消费情况、浏览哪个程度的资料，进行等级划分</li>\n	</ul>\n	</li>\n	<li>简洁、高效、少广告\n	<ul>\n		<li>专注于学习这一件事，网站界面应极简，去除其他乱七八糟的东西</li>\n		<li>尽量少广告，或直接无广告。弹窗广告必须禁止</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>2、消费点</p>\n\n<ul>\n	<li>用户浏览资料</li>\n	<li>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>3、服务</p>\n\n<ul>\n	<li>用户服务</li>\n	<li>内容服务</li>\n	<li>日志服务</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,301059309214539776,'2019-06-18 21:14:33','2019-06-18 21:14:33'),(302148517094137856,'<h1>概述</h1>','sys','待编辑','<p><strong>1、原理</strong></p>\n\n<ul>\n	<li>点对点模式\n	<ul>\n		<li>一对一，消费者主动拉取数据，消息收到后消息清除</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>发布/订阅模式\n	<ul>\n		<li>一对多，数据生产后，推送给所有订阅者</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190622-043131-331.png\" src=\"/furesky/images/201906/20190622-043131-331.png\" style=\"height:271px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、优点</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>解耦</td>\n			<td>解耦消息处理过程，使得扩展变得容易</td>\n		</tr>\n		<tr>\n			<td>异步</td>\n			<td>允许异步处理消息</td>\n		</tr>\n		<tr>\n			<td>削峰</td>\n			<td>提高峰值处理能力</td>\n		</tr>\n		<tr>\n			<td>缓冲</td>\n			<td>控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况</td>\n		</tr>\n		<tr>\n			<td>保证数据安全</td>\n			<td>消息队列把数据进行持久化直到它们已经被完全处理。这规避了数据丢失风险。</td>\n		</tr>\n		<tr>\n			<td>保证消息的有序性</td>\n			<td>保证数据会按照特定的顺序来处理</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、缺点</strong></p>\n\n<ul>\n	<li>系统可用性降低</li>\n	<li>系统复杂性提高</li>\n	<li>一致性问题</li>\n</ul>\n',0,289637599579893760,'2019-06-21 21:44:42','2019-06-21 21:44:42'),(302148662900727808,'<h1>消息中间件对比</h1>','sys','待编辑','<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">单机吞吐量</th>\n			<th scope=\"col\">时效性</th>\n			<th scope=\"col\">可用性</th>\n			<th scope=\"col\">消息可靠性</th>\n			<th scope=\"col\">功能支持</th>\n		</tr>\n		<tr>\n			<th scope=\"row\">ActiveMQ</th>\n			<td>万级</td>\n			<td>ms 级</td>\n			<td>高，基于主从架构</td>\n			<td>有较低的概率丢失数据</td>\n			<td>MQ领域的功能极其完备</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">RabbitMQ</th>\n			<td>万级</td>\n			<td>微秒级</td>\n			<td>高，基于主从架构</td>\n			<td>&nbsp;</td>\n			<td>\n			<p>基于erlang开发，</p>\n\n			<p>并发能力很强，性能极其好，延时很低</p>\n			</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">RocketMQ</th>\n			<td>10万级</td>\n			<td>ms&nbsp;级</td>\n			<td>非常高，分布式架构</td>\n			<td>可零丢失</td>\n			<td>MQ功能较为完善，还是分布式的，扩展性好</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">Kafka</th>\n			<td>10万级</td>\n			<td>ms&nbsp;级</td>\n			<td>非常高，分布式架构</td>\n			<td>可零丢失</td>\n			<td>\n			<p>功能较为简单，</p>\n\n			<p>在大数据领域的实时计算以及日志采集被大规模使用</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"row\">&nbsp;</th>\n			<th scope=\"col\">topic数量对吞吐量的影响</th>\n			<th scope=\"col\">功能支持</th>\n		</tr>\n		<tr>\n			<th scope=\"row\">ActiveMQ</th>\n			<td>&nbsp;</td>\n			<td>MQ领域的功能极其完备</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">RabbitMQ</th>\n			<td>&nbsp;</td>\n			<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">RocketMQ</th>\n			<td>\n			<p>topic从几百到几千个的级别</p>\n\n			<p>吞吐量会有较小幅度的下降</p>\n			</td>\n			<td>MQ功能较为完善，还是分布式的，扩展性好</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">Kafka</th>\n			<td>\n			<p>topic从几十个到几百个的级别</p>\n\n			<p>吞吐量会大幅度下降</p>\n			</td>\n			<td>\n			<p>功能较为简单，主要支持简单的MQ功能，</p>\n\n			<p>在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p>优劣势总结：</p>\n\n<ul>\n	<li>ActiveMQ\n	<ul>\n		<li>非常成熟，功能强大，在业内大量的公司以及项目中都有应用</li>\n		<li>偶尔会有较低概率丢失消息</li>\n		<li>社区活跃度低，官方对其维护也越来越少</li>\n		<li>而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>RabbitMQ\n	<ul>\n		<li>erlang语言开发，性能极其好，延时很低；</li>\n		<li>吞吐量到万级，MQ功能比较完备</li>\n		<li>而且开源提供的管理界面非常棒，用起来很好用</li>\n		<li>社区相对比较活跃，几乎每个月都发布几个版本</li>\n		<li>RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重</li>\n		<li>erlang语言本身带来的问题。很难读源码，很难定制和掌控</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>RocketMQ\n	<ul>\n		<li>接口简单易用，有阿里品牌保障</li>\n		<li>日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便</li>\n		<li>社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景</li>\n		<li>java系的，可以自己阅读源码，定制自己公司的MQ，可以掌控</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Kafka\n	<ul>\n		<li>仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展</li>\n		<li>kafka最好是支撑较少的topic数量即可，保证其超高吞吐量</li>\n		<li>kafka唯一的一点劣势是有可能消息重复消费，在大数据领域中以及日志采集中，这点轻微影响可以忽略。</li>\n	</ul>\n	</li>\n</ul>\n',0,289637599579893760,'2019-06-21 20:51:00','2019-06-21 20:51:00'),(302152355742130176,'<h1>Kafka</h1>','sys','待编辑','<p><strong>1、Kafka</strong></p>\n\n<ul>\n	<li>一个分布式、支持分区、多副本的，基于zookeeper协调的消息系统。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Kafka 特性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>高吞吐量、低延迟</td>\n			<td>kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</td>\n		</tr>\n		<tr>\n			<td>可扩展性</td>\n			<td>kafka集群支持热扩展</td>\n		</tr>\n		<tr>\n			<td>持久性、可靠性</td>\n			<td>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</td>\n		</tr>\n		<tr>\n			<td>容错性</td>\n			<td>允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</td>\n		</tr>\n		<tr>\n			<td>高并发</td>\n			<td>支持数千个客户端同时读写</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Kafka 使用场景</strong></p>\n\n<ul>\n	<li>日志收集</li>\n	<li>消息系统</li>\n	<li>用户活动跟踪</li>\n	<li>运营指标</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Kafka 术语</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>Producer</td>\n			<td>生产者，生产message发送到topic</td>\n		</tr>\n		<tr>\n			<td>Consumer</td>\n			<td>消费者，订阅topic消费message,</td>\n		</tr>\n		<tr>\n			<td>Consumer Group</td>\n			<td>消费者组，同组的不同消费者不能同时消费同一个分区的数据</td>\n		</tr>\n		<tr>\n			<td>&nbsp;</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>Broker</td>\n			<td>Kafka节点，一个集群由多个Kafka节点组成。</td>\n		</tr>\n		<tr>\n			<td>Topic</td>\n			<td>代表一类消息，相当于Queue</td>\n		</tr>\n		<tr>\n			<td>Partition</td>\n			<td>topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列</td>\n		</tr>\n		<tr>\n			<td>Segment</td>\n			<td>partition物理上由多个segment组成，每个Segment存着message信息</td>\n		</tr>\n		<tr>\n			<td>Offset</td>\n			<td>kafka的存储文件都是按照offset.kafka来命名</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,302152276897603584,'2019-06-21 22:29:57','2019-06-21 22:29:57'),(302155852772450304,'<h1>参考资料</h1>','sys','待编辑','待编辑',0,289637599579893770,'2019-06-21 21:06:19','2019-06-21 21:06:19'),(302176984372256768,'<h1>集群部署</h1>','sys','待编辑','<p><strong>1、集群规划</strong></p>\n\n<ul>\n	<li>hadoop102\n	<ul>\n		<li>zk</li>\n		<li>kafka</li>\n	</ul>\n	</li>\n	<li>hadoop103\n	<ul>\n		<li>zk</li>\n		<li>kafka</li>\n	</ul>\n	</li>\n	<li>hadoop104\n	<ul>\n		<li>zk</li>\n		<li>kafka</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、jar包下载</strong></p>\n\n<ul>\n	<li><a href=\"http://kafka.apache.org/downloads.html\" target=\"_blank\">http://kafka.apache.org/downloads.html</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、集群部署</strong></p>\n\n<ul>\n	<li>解压安装包，并重命名\n	<ul>\n		<li>$ tar -zxvf kafka_2.11-0.11.0.0.tgz -C /opt/module/</li>\n		<li>$ mv kafka_2.11-0.11.0.0/ kafka</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>创建logs文件夹\n	<ul>\n		<li>$ mkdir logs</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>修改配置文件\n	<ul>\n		<li>$ vi config/server.properties</li>\n		<li>详情见下表</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>配置环境变量\n	<ul>\n		<li>$ sudo vi /etc/profile\n		<ul>\n			<li>#KAFKA_HOME<br>\n			export KAFKA_HOME=/opt/module/kafka<br>\n			export PATH=$PATH:$KAFKA_HOME/bin</li>\n		</ul>\n		</li>\n		<li>$ source /etc/profile</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>分发安装包\n	<ul>\n		<li>$ xsync kafka/</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>修改给节点配置</li>\n</ul>\n\n<ul>\n	<li>启动、关闭集群\n	<ul>\n		<li>$ bin/kafka-server-start.sh config/server.properties &amp;</li>\n		<li>$ bin/kafka-server-stop.sh stop</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">配置</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>broker.id=0</td>\n			<td>broker的全局唯一编号，不能重复</td>\n		</tr>\n		<tr>\n			<td>delete.topic.enable=true</td>\n			<td>可删除topic</td>\n		</tr>\n		<tr>\n			<td>log.dirs=/opt/module/kafka/logs</td>\n			<td>kafka运行日志存放的路径</td>\n		</tr>\n		<tr>\n			<td>zookeeper.connect=hadoop102:2181,hadoop103:2181,...</td>\n			<td>配置连接Zookeeper集群地址</td>\n		</tr>\n		<tr>\n			<td>num.network.threads=3</td>\n			<td>处理网络请求的线程数量</td>\n		</tr>\n		<tr>\n			<td>num.io.threads=8</td>\n			<td>用来处理磁盘IO的现成数量</td>\n		</tr>\n		<tr>\n			<td>socket.send.buffer.bytes=102400</td>\n			<td>发送套接字的缓冲区大小</td>\n		</tr>\n		<tr>\n			<td>socket.receive.buffer.bytes=102400</td>\n			<td>接收套接字的缓冲区大小</td>\n		</tr>\n		<tr>\n			<td>socket.request.max.bytes=104857600</td>\n			<td>请求套接字的缓冲区大小</td>\n		</tr>\n		<tr>\n			<td>num.partitions=1</td>\n			<td>topic在当前broker上的分区个数</td>\n		</tr>\n		<tr>\n			<td>num.recovery.threads.per.data.dir=1</td>\n			<td>用来恢复和清理data下数据的线程数量</td>\n		</tr>\n		<tr>\n			<td>log.retention.hours=168</td>\n			<td>segment文件保留的最长时间，超时将被删除</td>\n		</tr>\n	</thead>\n</table>\n',0,302152276897603584,'2019-06-21 22:47:35','2019-06-21 22:47:35'),(302259172296007680,'<h1>命令行操作</h1>','sys','待编辑','<p><strong>1、查看当前服务器中的所有topic</strong></p>\n\n<ul>\n	<li>$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --list</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建topic</strong></p>\n\n<ul>\n	<li>$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 3 --partitions 1 --topic first</li>\n	<li>选项说明\n	<ul>\n		<li>--topic 定义topic名</li>\n		<li>--replication-factor &nbsp;定义副本数</li>\n		<li>--partitions &nbsp;定义分区数</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、删除topic</strong></p>\n\n<ul>\n	<li>$ bin/kafka-topics.sh --zookeeper hadoop102:2181&nbsp;--delete --topic first</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、发送消息</strong></p>\n\n<ul>\n	<li>$ bin/kafka-console-producer.sh&nbsp;--broker-list hadoop102:9092 --topic first</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、消费消息</strong></p>\n\n<ul>\n	<li>$ bin/kafka-console-consumer.sh&nbsp;--zookeeper hadoop102:2181 --from-beginning --topic first</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、查看某个Topic的详情</strong></p>\n\n<ul>\n	<li>$ bin/kafka-topics.sh --zookeeper hadoop102:2181&nbsp;--describe --topic first</li>\n</ul>\n\n<p><br>\n&nbsp;</p>\n',0,302152276897603584,'2019-06-22 04:02:13','2019-06-22 04:02:13'),(302501254524739584,'<h1>生产过程</h1>','sys','待编辑','<p><strong>1、写入方式</strong></p>\n\n<ul>\n	<li>producer采用推（push）模式将消息发布到broker，</li>\n	<li>每条消息都被追加（append）到分区（patition）中，</li>\n	<li>属于顺序写磁盘，顺序写磁盘效率比随机写内存要高，保障kafka吞吐率。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、分区（Partition）</strong></p>\n\n<ul>\n	<li>消息发送时都被发送到一个topic，其本质就是一个目录，而topic是由一些Partition组成，</li>\n	<li>每个Partition中的消息都是有序的，生产的消息被不断追加到Partition上，其中的每一个消息都被赋予了一个唯一的offset值。<br>\n	&nbsp;</li>\n</ul>\n\n<p><strong>3、分区的原因</strong></p>\n\n<ul>\n	<li>方便在集群中扩展</li>\n	<li>提高并发</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、分区的原则</strong></p>\n\n<ul>\n	<li>指定了patition，则直接使用；</li>\n	<li>未指定patition但指定key，通过对key的value进行hash出一个patition；</li>\n	<li>patition和key都未指定，使用轮询选出一个patition。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、副本（Replication）</strong></p>\n\n<ul>\n	<li>同一个partition可能会有多个replication（对应 server.properties 配置中的 default.replication.factor=N）。</li>\n	<li>在这些replication之间选出一个leader，producer和consumer只与这个leader交互，其它replication作为follower从leader 中复制数据。<br>\n	&nbsp;</li>\n</ul>\n\n<p><strong>6、写入流程</strong></p>\n\n<ul>\n	<li>producer先从zookeeper的 \"/brokers/.../state\"节点找到该partition的leader</li>\n	<li>producer将消息发送给该leader</li>\n	<li>leader将消息写入本地log</li>\n	<li>followers从leader pull消息，写入本地log后向leader发送ACK</li>\n	<li>leader收到所有replication的ACK后，向producer发送ACK</li>\n</ul>\n\n<p><img alt=\"20190623-041616-616.png\" src=\"/furesky/images/201906/20190623-041616-616.png\" style=\"height:342px; width:800px\"></p>\n',0,302501160253562880,'2019-06-22 20:21:59','2019-06-22 20:21:59'),(302501277899595776,'<h1>保存消息</h1>','sys','待编辑','<p><strong>1、存储方式</strong></p>\n\n<ul>\n	<li>物理上把topic分成一个或多个patition</li>\n	<li>每个patition物理上对应一个文件夹，该文件夹存储该patition的所有消息和索引文件</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、存储策略</strong></p>\n\n<ul>\n	<li>无论消息是否被消费，kafka都会保留所有消息。</li>\n	<li>有两种策略可以删除旧数据：\n	<ul>\n		<li>基于时间：log.retention.hours=168</li>\n		<li>基于大小：log.retention.bytes=1073741824</li>\n		<li>注意事项：因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,302501160253562880,'2019-06-22 20:27:39','2019-06-22 20:27:39'),(302501299378626560,'<h1>消费过程</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、高级Consumer API</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>高级API 写起来简单</li>\n		<li>不需要自行去管理offset，系统通过zookeeper自行管理。</li>\n		<li>不需要管理分区，副本等情况，.系统自动管理。</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>不能自行控制offset</li>\n		<li>不能细化控制如分区、副本、zk等</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、低级Consumer API</strong></p>\n\n<ul>\n	<li>优点\n	<ul>\n		<li>能够让开发者自己控制offset，想从哪里读取就从哪里读取。</li>\n		<li>自行控制连接分区，对分区自定义进行负载均衡</li>\n		<li>对zookeeper的依赖性降低</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>较复杂，需要自行控制offset，连接哪个分区，找到分区leader 等。</li>\n	</ul>\n	</li>\n</ul>\n\n<p><br>\n<strong>3、消费者组</strong></p>\n\n<ul>\n	<li>消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic</li>\n	<li>每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、消费方式</strong></p>\n\n<ul>\n	<li>consumer采用pull（拉）模式从broker中读取数据，即点对点模式</li>\n</ul>\n',0,302501160253562880,'2019-06-22 20:36:13','2019-06-22 20:36:13'),(302511080801738752,'<h1>环境准备</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、启动zk和kafka集群</strong></p>\n\n<ul>\n	<li>$ bin/kafka-console-consumer.sh&nbsp;--zookeeper hadoop102:2181 --topic first</li>\n</ul>\n\n<p><br>\n<br>\n<strong>2、导入pom依赖</strong></p>\n\n<pre><code class=\"language-xml\">&lt;dependencies&gt;\n&nbsp; &nbsp; &lt;dependency&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;0.11.0.0&lt;/version&gt;\n&nbsp; &nbsp; &lt;/dependency&gt;\n&nbsp; &nbsp; &lt;dependency&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;kafka_2.12&lt;/artifactId&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;0.11.0.0&lt;/version&gt;\n&nbsp; &nbsp; &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n\n<p>&nbsp;</p>\n',0,302511004901613568,'2019-06-22 20:40:21','2019-06-22 20:40:21'),(302511123814326272,'<h1>生产者 API</h1>','sys','待编辑','<p><strong>1、创建生产者</strong></p>\n\n<pre><code class=\"language-java\">public class NewProducer {\n    public static void main(String[] args) {        \n        Properties props = new Properties();\n        // Kafka服务端的主机名和端口号\n        props.put(\"bootstrap.servers\", \"hadoop103:9092\");\n        // 等待所有副本节点的应答\n        props.put(\"acks\", \"all\");\n        // 消息发送最大尝试次数\n        props.put(\"retries\", 0);\n        // 一批消息处理大小\n        props.put(\"batch.size\", 16384);\n        // 请求延时\n        props.put(\"linger.ms\", 1);\n        // 发送缓存区内存大小\n        props.put(\"buffer.memory\", 33554432);\n        // key序列化\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        // value序列化\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n\n        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);\n        for (int i = 0; i &lt; 50; i++) {\n            producer.send(new ProducerRecord&lt;String, String&gt;(\"first\", Integer.toString(i), \"hello world-\" + i));\n        }\n\n        producer.close();\n    }\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建生产者带回调函数</strong></p>\n\n<pre><code class=\"language-java\">public class CallBackProducer {\n    public static void main(String[] args) {\n        Properties props = new Properties();\n        // Kafka服务端的主机名和端口号\n        props.put(\"bootstrap.servers\", \"hadoop103:9092\");\n        // 等待所有副本节点的应答\n        props.put(\"acks\", \"all\");\n        // 消息发送最大尝试次数\n        props.put(\"retries\", 0);\n        // 一批消息处理大小\n        props.put(\"batch.size\", 16384);\n        // 增加服务端请求延时\n        props.put(\"linger.ms\", 1);\n        // 发送缓存区内存大小\n        props.put(\"buffer.memory\", 33554432);\n        // key序列化\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        // value序列化\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n\n        KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(props);\n\n        for (int i = 0; i &lt; 50; i++) {\n            kafkaProducer.send(new ProducerRecord&lt;String, String&gt;(\"first\", \"hello\" + i), new Callback() {\n                @Override\n                public void onCompletion(RecordMetadata metadata, Exception exception) {\n                    if (metadata != null) {\n                        System.err.println(metadata.partition() + \"---\" + metadata.offset());\n                    }\n                }\n            });\n        }\n\n        kafkaProducer.close();\n    }\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、自定义分区生产者</strong></p>\n\n<pre><code class=\"language-java\">public class CustomPartitioner implements Partitioner {\n    @Override\n    public void configure(Map&lt;String, ?&gt; configs) {        \n    }\n\n    @Override\n    public int partition(String topic, \n        Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {\n\n        // 控制分区\n        return 0;\n    }\n\n    @Override\n    public void close() {        \n    }\n}\n\n\npublic class PartitionerProducer {\n    public static void main(String[] args) {        \n        Properties props = new Properties();\n        // Kafka服务端的主机名和端口号\n        props.put(\"bootstrap.servers\", \"hadoop103:9092\");\n        // 等待所有副本节点的应答\n        props.put(\"acks\", \"all\");\n        // 消息发送最大尝试次数\n        props.put(\"retries\", 0);\n        // 一批消息处理大小\n        props.put(\"batch.size\", 16384);\n        // 增加服务端请求延时\n        props.put(\"linger.ms\", 1);\n        // 发送缓存区内存大小\n        props.put(\"buffer.memory\", 33554432);\n        // key序列化\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        // value序列化\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        // 自定义分区\n        props.put(\"partitioner.class\", \"com.atguigu.kafka.CustomPartitioner\");\n\n        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);\n        producer.send(new ProducerRecord&lt;String, String&gt;(\"first\", \"1\", \"atguigu\"));\n\n        producer.close();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,302511004901613568,'2019-06-22 20:47:37','2019-06-22 20:47:37'),(302511138871877632,'<h1>消费者 API</h1>','sys','待编辑','<p><strong>1、高级 API</strong></p>\n\n<ul>\n	<li>在控制台创建发送者\n	<ul>\n		<li>$ bin/kafka-console-producer.sh&nbsp;--broker-list hadoop102:9092 --topic first</li>\n	</ul>\n	</li>\n	<li>创建消费者</li>\n</ul>\n\n<pre><code class=\"language-java\">public class CustomNewConsumer {\n    public static void main(String[] args) {\n        Properties props = new Properties();\n        // 定义kakfa 服务的地址，不需要将所有broker指定上 \n        props.put(\"bootstrap.servers\", \"hadoop102:9092\");\n        // 制定consumer group \n        props.put(\"group.id\", \"test\");\n        // 是否自动确认offset \n        props.put(\"enable.auto.commit\", \"true\");\n        // 自动确认offset的时间间隔 \n        props.put(\"auto.commit.interval.ms\", \"1000\");\n        // key的序列化类\n        props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n        // value的序列化类 \n        props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n        // 定义consumer \n        KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);\n        \n        // 消费者订阅的topic, 可同时订阅多个 \n        consumer.subscribe(Arrays.asList(\"first\", \"second\",\"third\"));\n\n        while (true) {\n            // 读取数据，读取超时时间为100ms \n            ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);            \n            for (ConsumerRecord&lt;String, String&gt; record : records)\n                System.out.printf( \n                    \"offset = %d, key = %s, value = %s%n\",record.offset(), record.key(), record.value());\n        }\n    }\n}\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、低级 API</strong></p>\n\n<ul>\n	<li>主要步骤\n	<ul>\n		<li>根据指定的分区从主题元数据中找到主副本</li>\n		<li>获取分区最新的消费进度</li>\n		<li>从主副本拉取分区的消息</li>\n		<li>识别主副本的变化，重试</li>\n	</ul>\n	</li>\n	<li>方法描述</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">方法</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>findLeader()</td>\n			<td>客户端向种子节点发送主题元数据，将副本集加入备用节点</td>\n		</tr>\n		<tr>\n			<td>getLastOffset()</td>\n			<td>消费者客户端发送偏移量请求，获取分区最近的偏移量</td>\n		</tr>\n		<tr>\n			<td>run()</td>\n			<td>消费者低级AP I拉取消息的主要方法</td>\n		</tr>\n		<tr>\n			<td>findNewLeader()</td>\n			<td>当分区的主副本节点发生故障，客户将要找出新的主副本</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>代码示例</li>\n</ul>\n\n<pre><code class=\"language-java\">public class SimpleExample {\n    private List&lt;String&gt; m_replicaBrokers = new ArrayList&lt;&gt;();\n    public SimpleExample() {\n        m_replicaBrokers = new ArrayList&lt;&gt;();\n    }\n\n    public static void main(String args[]) {\n        SimpleExample example = new SimpleExample();\n        // 最大读取消息数量\n        long maxReads = Long.parseLong(\"3\");\n        // 要订阅的topic\n        String topic = \"test1\";\n        // 要查找的分区\n        int partition = Integer.parseInt(\"0\");\n        // broker节点的ip\n        List&lt;String&gt; seeds = new ArrayList&lt;&gt;();\n        seeds.add(\"192.168.9.102\");\n        seeds.add(\"192.168.9.103\");\n        seeds.add(\"192.168.9.104\");\n        // 端口\n        int port = Integer.parseInt(\"9092\");\n        try {\n            example.run(maxReads, topic, partition, seeds, port);\n        } catch (Exception e) {\n            System.out.println(\"Oops:\" + e);\n            e.printStackTrace();\n        }\n    }\n\n    public void run(long a_maxReads, String a_topic, \n           int a_partition, List&lt;String&gt; a_seedBrokers, int a_port) throws Exception {\n        // 获取指定Topic partition的元数据\n        PartitionMetadata metadata = findLeader(a_seedBrokers, a_port, a_topic, a_partition);\n        if (metadata == null) {\n            System.out.println(\"Can\'t find metadata for Topic and Partition. Exiting\");\n            return;\n        }\n        if (metadata.leader() == null) {\n            System.out.println(\"Can\'t find Leader for Topic and Partition. Exiting\");\n            return;\n        }\n        String leadBroker = metadata.leader().host();\n        String clientName = \"Client_\" + a_topic + \"_\" + a_partition;\n\n        SimpleConsumer consumer = new SimpleConsumer(leadBroker, a_port, 100000, 64 * 1024, clientName);\n        long readOffset = getLastOffset(consumer, \n            a_topic, a_partition, kafka.api.OffsetRequest.EarliestTime(), clientName);\n        int numErrors = 0;\n        while (a_maxReads &gt; 0) {\n            if (consumer == null) {\n                consumer = new SimpleConsumer(leadBroker, a_port, 100000, 64 * 1024, clientName);\n            }\n            FetchRequest req = new FetchRequestBuilder().clientId(clientName).addFetch(\n                a_topic, a_partition, readOffset, 100000).build();\n            FetchResponse fetchResponse = consumer.fetch(req);\n\n            if (fetchResponse.hasError()) {\n                numErrors++;\n                // Something went wrong!\n                short code = fetchResponse.errorCode(a_topic, a_partition);\n                System.out.println(\"Error fetching data from the Broker:\" + leadBroker + \" Reason: \" + code);\n                if (numErrors &gt; 5)\n                    break;\n                if (code == ErrorMapping.OffsetOutOfRangeCode()) {\n                    // We asked for an invalid offset. For simple case ask for\n                    // the last element to reset\n                    readOffset = getLastOffset(consumer, \n                        a_topic, a_partition, kafka.api.OffsetRequest.LatestTime(), clientName);\n                    continue;\n                }\n                consumer.close();\n                consumer = null;\n                leadBroker = findNewLeader(leadBroker, a_topic, a_partition, a_port);\n                continue;\n            }\n            numErrors = 0;\n\n            long numRead = 0;\n            for (MessageAndOffset messageAndOffset : fetchResponse.messageSet(a_topic, a_partition)) {\n                long currentOffset = messageAndOffset.offset();\n                if (currentOffset &lt; readOffset) {\n                    System.out.println(\"Found an old offset: \" + currentOffset + \" Expecting: \" + readOffset);\n                    continue;\n                }\n                readOffset = messageAndOffset.nextOffset();\n                ByteBuffer payload = messageAndOffset.message().payload();\n\n                byte[] bytes = new byte[payload.limit()];\n                payload.get(bytes);\n                System.out.println(String.valueOf(messageAndOffset.offset()) + \": \" + new String(bytes, \"UTF-8\"));\n                numRead++;\n                a_maxReads--;\n            }\n\n            if (numRead == 0) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException ie) {\n                }\n            }\n        }\n        if (consumer != null)\n            consumer.close();\n    }\n\n    public static long getLastOffset(SimpleConsumer consumer, \n            String topic, int partition, long whichTime, String clientName) {\n        TopicAndPartition topicAndPartition = new TopicAndPartition(topic, partition);\n        Map&lt;TopicAndPartition, PartitionOffsetRequestInfo&gt; requestInfo = \n            new HashMap&lt;TopicAndPartition, PartitionOffsetRequestInfo&gt;();\n        requestInfo.put(topicAndPartition, new PartitionOffsetRequestInfo(whichTime, 1));\n        kafka.javaapi.OffsetRequest request = new kafka.javaapi.OffsetRequest(\n            requestInfo, kafka.api.OffsetRequest.CurrentVersion(), clientName);\n        OffsetResponse response = consumer.getOffsetsBefore(request);\n\n        if (response.hasError()) {\n            System.out.println(\n               \"Error fetching data Offset Data the Broker. Reason: \" + response.errorCode(topic, partition));\n            return 0;\n        }\n        long[] offsets = response.offsets(topic, partition);\n        return offsets[0];\n    }\n\n\n    private String findNewLeader(\n            String a_oldLeader, String a_topic, int a_partition, int a_port) throws Exception{\n        for (int i = 0; i &lt; 3; i++) {\n            boolean goToSleep = false;\n            PartitionMetadata metadata = findLeader(m_replicaBrokers, a_port, a_topic, a_partition);\n            if (metadata == null) {\n                goToSleep = true;\n            } else if (metadata.leader() == null) {\n                goToSleep = true;\n            } else if (a_oldLeader.equalsIgnoreCase(metadata.leader().host()) &amp;&amp; i == 0) {\n                // first time through if the leader hasn\'t changed give\n                // ZooKeeper a second to recover\n                // second time, assume the broker did recover before failover,\n                // or it was a non-Broker issue\n                //\n                goToSleep = true;\n            } else {\n                return metadata.leader().host();\n            }\n            if (goToSleep) {\n                    Thread.sleep(1000);\n            }\n        }\n        System.out.println(\"Unable to find new leader after Broker failure. Exiting\");\n        throw new Exception(\"Unable to find new leader after Broker failure. Exiting\");\n    }\n\n    private PartitionMetadata findLeader(List&lt;String&gt; a_seedBrokers, int a_port, String a_topic, int a_partition){\n        PartitionMetadata returnMetaData = null;\n        loop:\n        for (String seed : a_seedBrokers) {\n            SimpleConsumer consumer = null;\n            try {\n                consumer = new SimpleConsumer(seed, a_port, 100000, 64 * 1024, \"leaderLookup\");\n                List&lt;String&gt; topics = Collections.singletonList(a_topic);\n                TopicMetadataRequest req = new TopicMetadataRequest(topics);\n                kafka.javaapi.TopicMetadataResponse resp = consumer.send(req);\n\n                List&lt;TopicMetadata&gt; metaData = resp.topicsMetadata();\n                for (TopicMetadata item : metaData) {\n                    for (PartitionMetadata part : item.partitionsMetadata()) {\n                        if (part.partitionId() == a_partition) {\n                            returnMetaData = part;\n                            break loop;\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                System.out.println(\"Error communicating with Broker [\" + seed + \n                    \"] to find Leader for [\" + a_topic + \", \" + a_partition + \"] Reason: \" + e);\n            } finally {\n                if (consumer != null)\n                    consumer.close();\n            }\n        }\n        if (returnMetaData != null) {\n            m_replicaBrokers.clear();\n            for (BrokerEndPoint replica : returnMetaData.replicas()) {\n                m_replicaBrokers.add(replica.host());\n            }\n        }\n        return returnMetaData;\n    }\n}\n\n</code></pre>\n\n<p>&nbsp;&nbsp; &nbsp;<br>\n&nbsp;&nbsp; &nbsp;<br>\n&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;</p>\n',0,302511004901613568,'2019-06-22 21:02:09','2019-06-22 21:02:09'),(302518254047240192,'<h1>Broker配置</h1>','sys','待编辑','<table border=\"1\" cellspacing=\"0\" class=\"Table\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>属性</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:center\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><strong><span style=\"font-family:宋体\"><span style=\"color:#3f3f3f\">默认值</span></span></strong></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:center\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><strong><span style=\"font-family:宋体\"><span style=\"color:#3f3f3f\">描述</span></span></strong></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">broker.id</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">&nbsp;</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"color:red\">必填参数，</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">broker</span></span><span style=\"color:red\">的唯一标识</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">log.dirs</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">/tmp/kafka-logs</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">Kafka</span></span><span style=\"color:red\">数据存放的目录。可以指定多个目录，中间用逗号分隔，当新</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">partition</span></span><span style=\"color:red\">被创建的时会被存放到当前存放</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">partition</span></span><span style=\"color:red\">最少的目录。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">port</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">9092</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">BrokerServer</span></span><span style=\"color:red\">接受客户端连接的端口号</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">zookeeper.connect</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">null</span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">Zookeeper</span></span><span style=\"color:red\">的连接串，格式为：</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">hostname1:port1,hostname2:port2,hostname3:port3</span></span><span style=\"color:red\">。可以填一个或多个，为了提高可靠性，建议都填上。注意，此配置允许我们指定一个</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">zookeeper</span></span><span style=\"color:red\">路径来存放此</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">kafka</span></span><span style=\"color:red\">集群的所有数据，为了与其他应用集群区分开，建议在此配置中指定本集群存放目录，格式为：</span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">hostname1:port1,hostname2:port2,hostname3:port3/chroot/path </span></span><span style=\"color:red\">。需要注意的是，消费者的参数要和此参数一致。</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>message.max.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1000000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">服务器可以接收到的最大的消息大小。注意此参数要和<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">maximum.message.size</span>大小一致，否则会因为生产者生产的消息太大导致消费者无法消费。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>num.io.threads</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">8</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">服务器用来执行读写请求的IO线程数，此参数的数量至少要等于服务器上磁盘的数量。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>queued.max.requests</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">500</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">I/O线程可以处理请求的队列大小，若实际请求数超过此大小，网络线程将停止接收新的请求。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>socket.send.buffer.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">100 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The SO_SNDBUFF buffer the server prefers for socket connections.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">socket.receive.buffer.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">100 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The SO_RCVBUFF buffer the server prefers for socket connections.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">socket.request.max.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">100 * 1024 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">服务器允许请求的最大值， 用来防止内存溢出，其值应该小于 Java heap size.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>num.partitions</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">默认partition数量，如果topic在创建时没有指定partition数量，默认使用此值，建议改为5</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">log.segment.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1024 * 1024 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">Segment文件的大小，超过此值将会自动新建一个segment，此值可以被topic级别的参数覆盖。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>log.roll.{ms,hours}</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">24 * 7 hours</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">新建segment文件的时间，此值可以被topic级别的参数覆盖。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">log.retention.{ms,minutes,hours}</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">7 days</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">Kafka segment log的保存周期，保存周期超过此时间日志就会被删除。此参数可以被topic级别参数覆盖。数据量大时，建议减小此值。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>log.retention.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">-1</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">每个partition的最大容量，若数据量超过此值，partition数据将会被删除。注意这个参数控制的是每个partition而不是topic。此参数可以被log级别参数覆盖。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">log.retention.check.interval.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">5 minutes</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">删除策略的检查周期</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>auto.create.topics.enable</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">true</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">自动创建topic参数，建议此值设置为false，严格控制topic管理，防止生产者错写topic。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>default.replication.factor</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">默认副本数量，建议改为2。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">replica.lag.time.max.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">10000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">在此窗口时间内没有收到follower的fetch请求，leader会将其从ISR(in-sync replicas)中移除。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">replica.lag.max.messages</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">4000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">如果replica节点落后leader节点此值大小的消息数量，leader节点就会将其从ISR中移除。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>replica.socket.timeout.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">30 * 1000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">replica向leader发送请求的超时时间。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">replica.socket.receive.buffer.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">64 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The socket receive buffer for network requests to the leader for replicating data.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>replica.fetch.max.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1024 * 1024</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The number of byes of messages to attempt to fetch for each partition in the fetch requests the replicas send to the leader.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">replica.fetch.wait.max.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">500</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The maximum amount of time to wait time for data to arrive on the leader in the fetch requests sent by the replicas to the leader.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>num.replica.fetchers</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">Number of threads used to replicate messages from leaders. Increasing this value can increase the degree of I/O parallelism in the follower broker.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">fetch.purgatory.purge.interval.requests</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The purge interval (in number of requests) of the fetch request purgatory.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>zookeeper.session.timeout.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">6000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">ZooKeeper session 超时时间。如果在此时间内server没有向zookeeper发送心跳，zookeeper就会认为此节点已挂掉。 此值太低导致节点容易被标记死亡；若太高，.会导致太迟发现节点死亡。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">zookeeper.connection.timeout.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">6000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">客户端连接zookeeper的超时时间。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">zookeeper.sync.time.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">2000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">H ZK follower落后 ZK leader的时间。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>controlled.shutdown.enable</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">true</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">允许broker shutdown。如果启用，broker在关闭自己之前会把它上面的所有leaders转移到其它brokers上，建议启用，增加集群稳定性。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">auto.leader.rebalance.enable</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">true</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">If this is enabled the controller will automatically try to balance leadership for partitions among the brokers by periodically returning leadership to the “preferred” replica for each partition if it is available.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">leader.imbalance.per.broker.percentage</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">10</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The percentage of leader imbalance allowed per broker. The controller will rebalance leadership if this ratio goes above the configured value per broker.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>leader.imbalance.check.interval.seconds</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">300</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The frequency with which to check for leader imbalance.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">offset.metadata.max.bytes</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">4096</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The maximum amount of metadata to allow clients to save with their offsets.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\">connections.max.idle.ms</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">600000</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">Idle connections timeout: the server socket processor threads close the connections that idle more than this.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p>num.recovery.threads.per.data.dir</p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\">1</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"color:#3f3f3f\">unclean.leader.election.enable</span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"color:#3f3f3f\">true</span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"color:#3f3f3f\">Indicates whether to enable replicas not in the ISR set to be elected as leader as a last resort, even though doing so may result in data loss.</span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">delete.topic.enable</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">false</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:宋体\"><span style=\"color:red\">启用</span></span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">deletetopic</span></span><span style=\"font-family:宋体\"><span style=\"color:red\">参数，建议设置为</span></span><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:red\">true</span></span><span style=\"font-family:宋体\"><span style=\"color:red\">。</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.topic.num.partitions</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">50</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">The number of partitions for the offset commit topic. Since changing this after deployment is currently unsupported, we recommend using a higher setting for production (e.g., 100-200).</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.topic.retention.minutes</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">1440</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">Offsets that are older than this age will be marked for deletion. The actual purge will occur when the log cleaner compacts the offsets topic.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.retention.check.interval.ms</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">600000</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">The frequency at which the offset manager checks for stale offsets.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.topic.replication.factor</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">3</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">The replication factor for the offset commit topic. A higher setting (e.g., three or four) is recommended in order to ensure higher availability. If the offsets topic is created when fewer brokers than the replication factor then the offsets topic will be created with fewer replicas.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.topic.segment.bytes</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">104857600</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">Segment size for the offsets topic. Since it uses a compacted topic, this should be kept relatively low in order to facilitate faster log compaction and loads.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.load.buffer.size</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">5242880</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">An offset load occurs when a broker becomes the offset manager for a set of consumer groups (i.e., when it becomes a leader for an offsets topic partition). This setting corresponds to the batch size (in bytes) to use when reading from the offsets segments when loading offsets into the offset manager’s cache.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:left\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.commit.required.acks</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">-1</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">The number of acknowledgements that are required before the offset commit can be accepted. This is similar to the producer’s acknowledgement setting. In general, the default should not be overridden.</span></span></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:137.05pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">offsets.commit.timeout.ms</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:54.35pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">5000</span></span></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"><span style=\"color:#3f3f3f\">The offset commit will be delayed until this timeout or the required number of replicas have received the offset commit. This is similar to the producer request timeout.</span></span></span></span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n',0,302518227996418048,'2019-06-22 21:09:46','2019-06-22 21:09:46'),(302518271071920128,'<h1>Producer配置</h1>','sys','待编辑','<table border=\"1\" cellspacing=\"0\" class=\"Table\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p>属性</p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:center\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><strong><span style=\"font-family:宋体\"><span style=\"color:#3f3f3f\">默认值</span></span></strong></span></span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:center\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><strong><span style=\"font-family:宋体\"><span style=\"color:#3f3f3f\">描述</span></span></strong></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">metadata.broker.list</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\">&nbsp;</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">启动时<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>查询<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">brokers</span>的列表，可以是集群中所有<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">brokers</span>的一个子集。注意，这个参数只是用来获取<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic</span>的元信息用，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>会从元信息中挑选合适的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">broker</span>并与之建立<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">socket</span>连接。格式是：<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">host1:port1,host2:port2</span>。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">request.required.acks</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">0</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">参见<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">3.2</span>节介绍</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">request.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">10000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Broker</span>等待<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">ack</span>的超时时间，若等待时间超过此值，会返回客户端错误信息。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer.type</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">sync</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">同步异步模式。<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">async</span>表示异步，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">sync</span>表示同步。如果设置成异步模式，可以允许生产者以<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">batch</span>的形式<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">push</span>数据，这样会极大的提高<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">broker</span>性能，推荐设置为异步。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">serializer.class</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">kafka.serializer.DefaultEncoder</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">序列号类，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">.</span>默认序列化成<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"> byte[] </span>。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">key.serializer.class</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\">&nbsp;</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Key</span>的序列化类，默认同上。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">partitioner.class</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">kafka.producer.DefaultPartitioner</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Partition</span>类，默认对<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">key</span>进行<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">hash</span>。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">compression.codec</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">none</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">指定<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>消息的压缩格式，可选参数为：<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\"> “none”, “gzip” and “snappy”</span>。关于压缩参见<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">4.1</span>节</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">compressed.topics</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">null</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">启用压缩的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic</span>名称。若上面参数选择了一个压缩格式，那么压缩仅对本参数指定的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic</span>有效，若本参数为空，则对所有<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic</span>有效。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">message.send.max.retries</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">3</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Producer</span>发送失败时重试次数。若网络出现问题，可能会导致不断重试。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">retry.backoff.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">100</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected. Since leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic.metadata.refresh.interval.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">600 * 1000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The producer generally refreshes the topic metadata from brokers when there is a failure (partition missing, leader not available…). It will also poll regularly (default: every 10min so 600000ms). If you set this to a negative value, metadata will only get refreshed on failure. If you set this to zero, the metadata will get refreshed after each message sent (not recommended). Important note: the refresh happen only AFTER the message is sent, so if the producer never sends a message the metadata is never refreshed</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">queue.buffering.max.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">5000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">启用异步模式时，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>缓存消息的时间。比如我们设置成<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1000</span>时，它会缓存<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1</span>秒的数据再一次发送出去，这样可以极大的增加<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">broker</span>吞吐量，但也会造成时效性的降低。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">queue.buffering.max.messages</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">10000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">采用异步模式时<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer buffer </span>队列里最大缓存的消息数量，如果超过这个数值，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>就会阻塞或者丢掉消息。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">queue.enqueue.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">-1</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">当达到上面参数值时<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>阻塞等待的时间。如果值设置为<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">0</span>，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">buffer</span>队列满时<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>不会阻塞，消息直接被丢掉。若值设置为<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">-1</span>，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>会被阻塞，不会丢消息。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">batch.num.messages</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">200</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">采用异步模式时，一个<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">batch</span>缓存的消息数量。达到这个数量值时<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>才会发送消息。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">send.buffer.bytes</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">100 * 1024</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Socket write buffer size</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">client.id</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">“”</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.</span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n',0,302518227996418048,'2019-06-22 21:10:09','2019-06-22 21:10:09'),(302518284283977728,'<h1>Consumer配置</h1>','sys','待编辑','<table border=\"1\" cellspacing=\"0\" class=\"Table\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p>属性</p>\n			</td>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">默认值</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:center\"><span style=\"font-size:10.5pt\"><span style=\"font-family:&quot;Times New Roman&quot;,serif\"><strong><span style=\"font-family:宋体\"><span style=\"color:#3f3f3f\">描述</span></span></strong></span></span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">group.id</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\">&nbsp;</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Consumer</span>的组<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">ID</span>，相同<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">goup.id</span>的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>属于同一个组。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper.connect</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\">&nbsp;</p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Consumer</span>的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper</span>连接串，要和<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">broker</span>的配置一致。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer.id</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">null</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">如果不设置会自动生成。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">socket.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">30 * 1000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">网络请求的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">socket</span>超时时间。实际超时时间由<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">max.fetch.wait + socket.timeout.ms </span>确定。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">socket.receive.buffer.bytes</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">64 * 1024</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The socket receive buffer for network requests.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">fetch.message.max.bytes</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1024 * 1024</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">查询<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">topic-partition</span>时允许的最大消息大小。<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>会为每个<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">partition</span>缓存此大小的消息到内存，因此，这个参数可以控制<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>的内存使用量。这个值应该至少比<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">server</span>允许的最大消息大小大，以免<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">producer</span>发送的消息大于<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>允许的消息。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">num.consumer.fetchers</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The number fetcher threads used to fetch data.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">auto.commit.enable</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">true</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">如果此值设置为<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">true</span>，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>会周期性的把当前消费的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">offset</span>值保存到<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper</span>。当<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>失败重启之后将会使用此值作为新开始消费的值。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">auto.commit.interval.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">60 * 1000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Consumer</span>提交<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">offset</span>值到<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper</span>的周期。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">queued.max.message.chunks</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">2</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">用来被<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>消费的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">message chunks </span>数量， 每个<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">chunk</span>可以缓存<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">fetch.message.max.bytes</span>大小的数据量。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">auto.commit.interval.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">60 * 1000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Consumer</span>提交<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">offset</span>值到<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper</span>的周期。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">queued.max.message.chunks</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">2</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">用来被<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>消费的<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">message chunks </span>数量， 每个<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">chunk</span>可以缓存<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">fetch.message.max.bytes</span>大小的数据量。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">fetch.min.bytes</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">1</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">fetch.wait.max.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">100</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The maximum amount of time the server will block before answering the fetch request if there isn’t sufficient data to immediately satisfy fetch.min.bytes.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">rebalance.backoff.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">2000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Backoff time between retries during rebalance.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">refresh.leader.backoff.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">200</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Backoff time to wait before trying to determine the leader of a partition that has just lost its leader.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">auto.offset.reset</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">largest</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">What to do when there is no initial offset in ZooKeeper or if an offset is out of range ;smallest : automatically reset the offset to the smallest offset; largest : automatically reset the offset to the largest offset;anything else: throw exception to the consumer</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">-1</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\">若在指定时间内没有消息消费，<span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">consumer</span>将会抛出异常。</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">exclude.internal.topics</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">true</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">Whether messages from internal topics (such as offsets) should be exposed to the consumer.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper.session.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">6000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">ZooKeeper session timeout. If the consumer fails to heartbeat to ZooKeeper for this period of time it is considered dead and a rebalance will occur.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:left\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper.connection.timeout.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">6000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">The max time that the client waits while establishing a connection to zookeeper.</span></p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top; width:134.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">zookeeper.sync.time.ms</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:2.0cm\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">2000</span></p>\n			</td>\n			<td style=\"vertical-align:top; width:219.7pt\">\n			<p style=\"text-align:justify\"><span style=\"font-family:&quot;微软雅黑&quot;,sans-serif\">How far a ZK follower can be behind a ZK leader</span></p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n',0,302518227996418048,'2019-06-22 21:11:51','2019-06-22 21:11:51'),(302597081729507328,'<h1>架构演化</h1>','sys','待编辑','<p><img alt=\"20190623-102424-424.png\" src=\"/furesky/images/201906/20190623-102424-424.png\" style=\"height:240px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、单一应用架构</strong></p>\n\n<ul>\n	<li>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</li>\n	<li>此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</li>\n	<li>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</li>\n	<li>缺点\n	<ul>\n		<li>性能扩展比较难&nbsp;</li>\n		<li>协同开发问题</li>\n		<li>不利于升级维护</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190623-102525-525.png\" src=\"/furesky/images/201906/20190623-102525-525.png\" style=\"height:242px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、垂直应用架构</strong></p>\n\n<ul>\n	<li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</li>\n	<li>此时，用于加速前端页面开发的Web框架(MVC)是关键。</li>\n	<li>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</li>\n	<li>缺点： 公用模块无法重复利用，开发性的浪费</li>\n</ul>\n\n<p>&nbsp;<img alt=\"20190623-102626-626.png\" src=\"/furesky/images/201906/20190623-102626-626.png\" style=\"height:277px; width:500px\"><br>\n&nbsp;</p>\n\n<p><strong>3、分布式服务架构</strong></p>\n\n<ul>\n	<li>当垂直应用越来越多，应用之间交互不可避免，</li>\n	<li>将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</li>\n	<li>此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</li>\n</ul>\n\n<p><img alt=\"20190623-102727-727.png\" src=\"/furesky/images/201906/20190623-102727-727.png\" style=\"height:324px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、流动计算架构</strong></p>\n\n<ul>\n	<li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</li>\n	<li>此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。</li>\n</ul>\n\n<p><img alt=\"20190623-102828-828.png\" src=\"/furesky/images/201906/20190623-102828-828.png\" style=\"height:359px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,302520687695667200,'2019-06-23 02:37:42','2019-06-23 02:37:42'),(302597710107549696,'<h1>参考资料</h1>','sys','待编辑','<p><strong>1、官网</strong></p>\n\n<p><a href=\"http://dubbo.apache.org/zh-cn/\" target=\"_blank\">http://dubbo.apache.org/zh-cn/</a></p>\n',0,302596962502221824,'2019-06-23 02:22:30','2019-06-23 02:22:30'),(302599322364452864,'<h1>分布式系统</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、发展演化</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、RPC</strong></p>\n\n<ul>\n	<li>Remote Procedure Call，远程过程调用，是一种进程间通信方式。</li>\n	<li>是一种技术的思想\n	<ul>\n		<li>允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</li>\n		<li>即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</li>\n	</ul>\n	</li>\n	<li>核心模块\n	<ul>\n		<li>通信</li>\n		<li>序列号</li>\n	</ul>\n	</li>\n	<li>基本原理</li>\n</ul>\n\n<p><img alt=\"20190623-104141-141.png\" src=\"/furesky/images/201906/20190623-104141-141.png\" style=\"height:318px; width:500px\"></p>\n\n<p>&nbsp;</p>\n',0,302520687695667200,'2019-06-23 02:49:22','2019-06-23 02:49:22'),(302606575712772096,'<h1>概述</h1>','sys','待编辑','<p><strong>1、Dubbo</strong></p>\n\n<ul>\n	<li>Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，</li>\n	<li>三大核心能力：\n	<ul>\n		<li>面向接口的远程方法调用</li>\n		<li>智能容错和负载均衡</li>\n		<li>服务自动注册和发现</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、基本概念</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">角色</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>服务提供者（Provider）</td>\n			<td>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</td>\n		</tr>\n		<tr>\n			<td>服务消费者（Consumer）</td>\n			<td>\n			<p>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务。</p>\n\n			<p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n			</td>\n		</tr>\n		<tr>\n			<td>注册中心（Registry）</td>\n			<td>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</td>\n		</tr>\n		<tr>\n			<td>监控中心（Monitor）</td>\n			<td>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</td>\n		</tr>\n	</thead>\n</table>\n\n<p><img alt=\"20190623-110326-326.png\" src=\"/furesky/images/201906/20190623-110326-326.png\" style=\"height:434px; width:600px\"></p>\n\n<ul>\n	<li>调用关系说明\n	<ul>\n		<li>服务容器负责启动，加载，运行服务提供者。</li>\n		<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n		<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n		<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n		<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n		<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;<br>\n&nbsp;</p>\n',0,302604718965694464,'2019-06-23 03:08:31','2019-06-23 03:08:31'),(302610809090908160,'<h1>环境搭建</h1>','sys','待编辑','<p><strong>1、安装JDK</strong></p>\n\n<ul>\n	<li>下载JDK\n	<ul>\n		<li><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>\n	</ul>\n	</li>\n	<li>上传并解压\n	<ul>\n		<li>$ tar -zxvf jdk-8u171-linux-x64.tar.gz -C&nbsp;/usr/local/java/</li>\n	</ul>\n	</li>\n	<li>设置环境变量\n	<ul>\n		<li>$ vi /etc/profile</li>\n		<li>追加配置\n		<ul>\n			<li>export JAVA_HOME=/usr/local/java/jdk1.8.0_171</li>\n			<li>export JRE_HOME=${JAVA_HOME}/jre</li>\n			<li>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</li>\n			<li>export PATH=${JAVA_HOME}/bin:$PATH</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n	<li>使环境变量生效&amp;测试JDK\n	<ul>\n		<li>$ source /etc/profile</li>\n		<li>$ java -version</li>\n	</ul>\n	</li>\n</ul>\n\n<p><br>\n<strong>2、安装Zookeeper</strong></p>\n\n<ul>\n	<li>下载\n	<ul>\n		<li><a href=\"https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/\" target=\"_blank\">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></li>\n	</ul>\n	</li>\n	<li>解压\n	<ul>\n		<li>$ tar -zxvf zookeeper-3.4.11.tar.gz -C&nbsp;/usr/local/zookeeper</li>\n	</ul>\n	</li>\n	<li>开机启动\n	<ul>\n		<li>脚本 zookeeper.sh</li>\n		<li>把脚本注册为Service\n		<ul>\n			<li>$ chkconfig -add zookeeper</li>\n			<li>$ chkconfig --list</li>\n		</ul>\n		</li>\n		<li>增加权限\n		<ul>\n			<li>$ chmod +x /etc/init.d/zookeeper</li>\n			<li>$ ll&nbsp;/etc/init.d</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n	<li>配置zookeeper\n	<ul>\n		<li>初始化配置文件\n		<ul>\n			<li>$ cp&nbsp;zoo_sample.cfg&nbsp; zoo.cfg</li>\n		</ul>\n		</li>\n		<li>启动\n		<ul>\n			<li>$ service zookeeper start</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">#!/bin/bash\n#chkconfig:2345 20 90\n#description:zookeeper\n#processname:zookeeper\nZK_PATH=/usr/local/zookeeper\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_171\ncase $1 in\n         start) sh  $ZK_PATH/bin/zkServer.sh start;;\n         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;\n         status) sh  $ZK_PATH/bin/zkServer.sh status;;\n         restart) sh $ZK_PATH/bin/zkServer.sh restart;;\n         *)  echo \"require start|stop|status|restart\"  ;;\nesac</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、安装Dubbo-admin控制台</strong></p>\n\n<ul>\n	<li>下载\n	<ul>\n		<li><a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\">https://github.com/apache/incubator-dubbo-ops</a></li>\n	</ul>\n	</li>\n	<li>修改配置\n	<ul>\n		<li>进入src\\main\\resources\\application.properties 指定zookeeper地址</li>\n		<li>配置：dubbo.registry.address=zookeeper://127.0.0.1:2181&nbsp;</li>\n	</ul>\n	</li>\n	<li>打包dubbo-admin\n	<ul>\n		<li>mvn clean package -Dmaven.test.skip=true&nbsp;</li>\n	</ul>\n	</li>\n	<li>运行dubbo-admin\n	<ul>\n		<li>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</li>\n	</ul>\n	</li>\n	<li>默认使用root/root 登陆</li>\n</ul>\n\n<p><br>\n<br>\n&nbsp;</p>\n',0,302604718965694464,'2019-06-23 23:42:03','2019-06-23 23:42:03'),(302618430783004672,'<h1>Hello world</h1>','sys','待编辑','<p><strong>1、需求</strong></p>\n\n<ul>\n	<li>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址</li>\n	<li>gmall\n	<ul>\n		<li>gmall-user</li>\n		<li>gmall-order-web</li>\n		<li>gmall-interface</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、pom.xml</strong></p>\n\n<pre><code class=\"language-xml\">&lt;!-- Dubbo Spring Boot Starter --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.7.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、application.yml</strong></p>\n\n<pre><code class=\"language-ini\">#服务提供者配置\nspring:\n  dubbo: \n    application:\n      name: gmall-user                     # 服务名\n    base-package: com.test.gmall           # dubbo服务调用者所在的包\n    registry:\n      protocol: zookeeper                  # 是指定注册中心协议\n      address: 192.168.0.159               # zookeeper注册中心的地址\n      port: 2181                           # zookeeper注册中心的端口\n    protocol:\n      name: dubbo\n    provider:\n      retries: 0                           # 服务调用重试次数，服务提供者不给重试，让服务消费者自己重试\n\n\n\n#服务消费者配置\nspring:\n  dubbo: \n    application:\n      name: gmall-order-web\n    base-package: com.test.gmall           # dubbo服务调用者所在的包  \n    registry:\n      protocol: zookeeper                  # 是指定注册中心协议\n      address: 192.168.0.159               # zookeeper注册中心的地址\n      port: 2181                           # zookeeper注册中心的端口\n    protocol:\n      name: dubbo\n    consumer:\n      timeout: 1000 \n      check: true                          # 服务启动时检查被调用服务是否可用\n      retries: 2                           # 服务调用重试次数 \n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、dubbo注解</strong></p>\n\n<ul>\n	<li>@Service</li>\n	<li>@Reference<br>\n	&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,302604718965694464,'2019-06-24 00:47:45','2019-06-24 00:47:45'),(304778366300364800,'<h1>如何选择职业</h1>','sys','待编辑','<p><strong>1、职业选择</strong></p>\n\n<ul>\n	<li>努力很重要，选择比努力更重要</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、职业选择的误区</strong></p>\n\n<ul>\n	<li>不敢选择\n	<ul>\n		<li>人生不如意十之八九，没有完美的事情。</li>\n		<li>要敢于选择：两利相权取其重、两害相权取其轻</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>一直选择\n	<ul>\n		<li>转行意味着重新开始，也意味着抛弃以前的积累。转行穷3年。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>不知道怎么选择\n	<ul>\n		<li>不要把专业当成职业，专业不是职业。</li>\n		<li>不要把兴趣当成工作，有时候兴趣不能当饭吃。</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、职业选择的考量点</strong></p>\n\n<ul>\n	<li>前途与钱途</li>\n	<li>天赋与特长</li>\n	<li>兴趣与爱好</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、询问他人意见</strong></p>\n\n<ul>\n	<li>注意询问对象，要询问行业内成功的人</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、判断职业是否有前途</strong></p>\n\n<ul>\n	<li>工具--<a href=\"https://zhaopin.baidu.com/\">招聘网站</a></li>\n	<li>工具--<a href=\"http://index.baidu.com\">百度指数</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304778037714395136,'2019-07-02 13:28:55','2019-07-02 13:28:55'),(304784061422804992,'<h1>成为什么样的人</h1>','sys','待编辑','<p><strong>1、能力与心态</strong></p>\n\n<ul>\n	<li>一个人的能力，决定了他的下限</li>\n	<li>一个人的心态，决定了他的上限</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、四种人</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:300px\">\n	<tbody>\n		<tr>\n			<td>人财</td>\n			<td>心态好，能力强</td>\n			<td>是公司的财源</td>\n		</tr>\n		<tr>\n			<td>人材</td>\n			<td>心态好，能力弱</td>\n			<td>可以培养</td>\n		</tr>\n		<tr>\n			<td>人才</td>\n			<td>心态差，能力强</td>\n			<td>非常难用</td>\n		</tr>\n		<tr>\n			<td>人裁</td>\n			<td>心态差，能力差</td>\n			<td>裁掉算了</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、心态</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:300px\">\n	<tbody>\n		<tr>\n			<td>“为啥要我做”</td>\n			<td>团队寄生虫</td>\n		</tr>\n		<tr>\n			<td>“这事不怪我”</td>\n			<td>团队的垃圾</td>\n		</tr>\n		<tr>\n			<td>“这事该找谁”</td>\n			<td>团队的白痴</td>\n		</tr>\n		<tr>\n			<td>“没人来教我”</td>\n			<td>团队的拖累</td>\n		</tr>\n		<tr>\n			<td>“这事我不会”</td>\n			<td>永远是小兵</td>\n		</tr>\n		<tr>\n			<td>“这事我来做”</td>\n			<td>领导左右手</td>\n		</tr>\n		<tr>\n			<td>“这事我顶着”</td>\n			<td>团队顶梁柱</td>\n		</tr>\n		<tr>\n			<td>“这事我负责”</td>\n			<td>团队领导人</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、细节</strong></p>\n\n<ul>\n	<li>你是为了自己工作</li>\n	<li>认真对待工作汇报</li>\n	<li>重视工作中的细节</li>\n	<li>管理好自己的情绪</li>\n	<li>错了就认，认了就改</li>\n	<li>养成反馈的意识和习惯</li>\n	<li>不埋怨，不抱怨，不混日子</li>\n	<li>给结果，说功劳，少秀悲情</li>\n	<li>说数据，说方案，勤于思考</li>\n	<li>提示自身价值，才会有人脉</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304778037714395136,'2019-06-29 03:59:23','2019-06-29 03:59:23'),(304792642264145920,'<h1>应该具备什么样的能力</h1>','sys','待编辑','<p><strong>1、学会谋生的一技之长</strong></p>\n\n<ul>\n	<li>学习的思路\n	<ul>\n		<li>一样精强于百样通</li>\n		<li>一技可以安身立命，之长才能发家致富</li>\n	</ul>\n	</li>\n	<li>学习的方法\n	<ul>\n		<li>获取梗概：招聘网站</li>\n		<li>窃取脉络：培训课程</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、提升综合的职业素养</strong></p>\n\n<ul>\n	<li>例如：办公软件的使用、语言表达的能力</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、企业招聘的隐藏考察点</strong></p>\n\n<ul>\n	<li>招聘最重要的是：匹配</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,304778037714395136,'2019-06-29 15:02:18','2019-06-29 15:02:18'),(304802720971137024,'<h1>编写原则</h1>','sys','待编辑','<p><strong>1、HR 如何刷选简历</strong></p>\n\n<ul>\n	<li>是快速浏览，而不是仔细阅读</li>\n	<li>是寻找关键字，而非逐句分析</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、HR 最讨厌的简历</strong></p>\n\n<ul>\n	<li>又臭又长-----简单有力</li>\n	<li>千篇一律-----与众不同</li>\n	<li>含糊不清-----交代具体</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、简历要好看</strong></p>\n\n<ul>\n	<li>形式上的好看</li>\n	<li>内容上的好看</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、简历编写的原则</strong></p>\n\n<ul>\n	<li>趋利避害</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、简历编写的时机</strong></p>\n\n<ul>\n	<li>时不时更新下简历，总结检讨自己的成长</li>\n</ul>\n',0,304796631336656876,'2019-06-30 04:01:50','2019-06-30 04:01:50'),(304804779376156672,'<h1>注意事项</h1>','sys','待编辑','<p><strong>1、基本资料</strong></p>\n\n<ul>\n	<li>必不可少的选项\n	<ul>\n		<li>不欲盖弥彰</li>\n		<li>如：姓名、性别、出生年月、年龄、婚姻状况、联系方式（手机号、邮箱）</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>可有可无的选项\n	<ul>\n		<li>不自曝其短</li>\n		<li>如：籍贯、民族、照片、显居住地、英文水平</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、求职意向</strong></p>\n\n<ul>\n	<li>意向职位、意向城市\n	<ul>\n		<li>做痴心小种子，别做花心大萝卜</li>\n	</ul>\n	</li>\n	<li>所属行业\n	<ul>\n		<li>不建议自设门槛</li>\n	</ul>\n	</li>\n	<li>期望薪资</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、教育经历</strong></p>\n\n<ul>\n	<li>从高中开始倒序来写</li>\n	<li>学会了什么，而不是学了什么</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、个人技能</strong></p>\n\n<ul>\n	<li>归纳清晰</li>\n	<li>分清主次</li>\n	<li>合理行文</li>\n</ul>\n\n<pre><code>会Linux常用命令，能在Linux上搭建LAMP环境\n掌握Linux日常管理操作，熟悉Linux服务器的LAMP环境部署、优化与安全</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、工作经历</strong></p>\n\n<ul>\n	<li>是怎么做好这份工作的，而不是这份工作是做什么的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、项目经历</strong></p>\n\n<ul>\n	<li>基本原则\n	<ul>\n		<li>who</li>\n		<li>when</li>\n		<li>where</li>\n		<li>how</li>\n		<li>why</li>\n		<li>what</li>\n	</ul>\n	</li>\n	<li>基本标准\n	<ul>\n		<li>真</li>\n		<li>实</li>\n		<li>扩展</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、自我评价</strong></p>\n\n<ul>\n	<li>突出与众不同的能力或经历</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,304796631336656876,'2019-06-30 04:01:48','2019-06-30 04:01:48'),(304815685573189632,'<h1>简历投递</h1>','sys','待编辑','<p><strong>1、胆大</strong></p>\n\n<ul>\n	<li>撑死胆大的，饿死胆小的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、心细</strong></p>\n\n<ul>\n	<li>心中有猛虎，细能嗅蔷薇</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、脸皮厚</strong></p>\n\n<ul>\n	<li>脸皮薄吃不着，脸皮厚吃个够</li>\n	<li>例如\n	<ul>\n		<li>可不可以投之前被拒过的公司</li>\n		<li>过了约定时间可不可以询问结果</li>\n		<li>发了offer我拒绝了，现在想吃回头草</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、纸质简历的小细节</strong></p>\n\n<ul>\n	<li>一定要带简历</li>\n	<li>简历要干净整洁</li>\n	<li>递简历注意细节\n	<ul>\n		<li>双手递</li>\n		<li>文字朝向对方，方便对方直接查看</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,304796631336656876,'2019-06-30 04:01:47','2019-06-30 04:01:47'),(304962863444697088,'<h1>面试要点</h1>','sys','待编辑','<p><strong>1、没拿到offer之前，一切都是虚幻</strong></p>\n\n<ul>\n	<li>如果不是白纸黑字盖了红章的东西，就不能当真</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、面试目的</strong></p>\n\n<ul>\n	<li>判断你的能力\n	<ul>\n		<li>尽可能的展现与职位匹配的能力</li>\n	</ul>\n	</li>\n</ul>\n',0,304962812706201600,'2019-06-29 15:40:33','2019-06-29 15:40:33'),(304963675273207808,'<h1>面试形式</h1>','sys','待编辑','<p><strong>1、电话面试</strong></p>\n\n<ul>\n	<li>提前准备</li>\n	<li>保持礼貌\n	<ul>\n		<li>让面试官先挂电话</li>\n		<li>...</li>\n	</ul>\n	</li>\n	<li>主动选择通话的时间和地点</li>\n	<li>注意语调语气\n	<ul>\n		<li>打电话看不到你的表情，但可以听到你的表情</li>\n		<li>面带微笑</li>\n	</ul>\n	</li>\n	<li>保持专注</li>\n	<li>适当反问\n	<ul>\n		<li>面试什么时候有结果呀</li>\n		<li>这份工作具体做什么呀</li>\n		<li>...</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、视频面试</strong></p>\n\n<ul>\n	<li>做好准备工作</li>\n	<li>建立美好形象\n	<ul>\n		<li>庄重整洁</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、技能测试与性格测试</strong></p>\n\n<ul>\n	<li>不会就是不会，不要胡编乱造，不要找借口</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、一对一面试</strong></p>\n\n<ul>\n	<li>不要紧张，保持放松</li>\n	<li>认真听，仔细答</li>\n	<li>回答简明扼要，有针对性</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、一对多面试</strong></p>\n\n<ul>\n	<li>分辨主面试官\n	<ul>\n		<li>一般话比较少，只问核心问题的是主面试官</li>\n		<li>观察面试官之间的互动</li>\n	</ul>\n	</li>\n	<li>重视每一个面试官</li>\n	<li>发现可能的“同志”</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、多个应聘者面试</strong></p>\n\n<ul>\n	<li>贬低别人永远抬高自己</li>\n	<li>积极让面试官加深对你的印象，记住你</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、背景调查</strong></p>\n\n<ul>\n	<li>永远不要混日子</li>\n	<li>像经营企业一样经营自己</li>\n</ul>\n',0,304962812706201600,'2019-06-29 16:11:24','2019-06-29 16:11:24'),(304973432398716918,'<h1>面试前准备</h1>','sys','待编辑','<p><strong>1、预防求职陷阱</strong></p>\n\n<ul>\n	<li>永远不要相信天上会掉陷阱</li>\n	<li>害人之心不可有，防人之心不可无\n	<ul>\n		<li>谨慎对待面试，比如查询企业信息</li>\n		<li>要交钱的必定是陷阱</li>\n		<li>防止以考察能力为借口，剽窃求职者作品</li>\n	</ul>\n	</li>\n	<li>这个世界终归是美好的，只是你需要在奔跑时，看着点脚下的路</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、接到面试邀约后</strong></p>\n\n<ul>\n	<li>了解公司，了解职位要求\n	<ul>\n		<li>你对公司的了解代表着你的意向性</li>\n		<li>你对公司的认同证明了你的稳定性</li>\n	</ul>\n	</li>\n	<li>面试一定不要迟到\n	<ul>\n		<li>提前5到10分钟</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、凡事预则立，不预则废</strong></p>\n\n<p>&nbsp;</p>\n',0,304796631336656886,'2019-06-30 02:14:32','2019-06-30 02:14:32'),(304973432398716928,'<h1>个人形象</h1>','sys','待编辑','<p><strong>1、准则</strong></p>\n\n<ul>\n	<li>职场讲究庄重保守</li>\n	<li>礼仪讲究尊者为先</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、以貌取人</strong></p>\n\n<ul>\n	<li>我们无法要求别人不以貌取人，但可以要求自己不以貌取人</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、自信</strong></p>\n\n<ul>\n	<li>自信，才是一个人最好看的那张脸</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、形象</strong></p>\n\n<ul>\n	<li>干净整洁</li>\n	<li>大方得体</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、言谈举止</strong></p>\n\n<ul>\n	<li>言谈举止显示性格，细节决定成败</li>\n	<li>坦诚，更容易赢得别人的好感</li>\n	<li>给面试官肯定且正面的回复</li>\n	<li>越是能在紧张的氛围下开玩笑的人，越是有自信的人</li>\n	<li>永远不要打断面试官说话</li>\n	<li>眼睛是心灵的窗户，不要在面试的时候把窗户关上</li>\n	<li>面带微笑</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304796631336656886,'2019-06-30 02:14:16','2019-06-30 02:14:16'),(304989881347514368,'<h1>克服紧张</h1>','sys','待编辑','<p><strong>1、紧张原因</strong></p>\n\n<ul>\n	<li>准备不充分</li>\n	<li>自信心不足</li>\n	<li>负面预想多</li>\n	<li>得失心过重</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、克服紧张</strong></p>\n\n<ul>\n	<li>客观看待</li>\n	<li>做好准备</li>\n	<li>培养自信\n	<ul>\n		<li>先要对自己有信心，才有资格要求别人对你有信心</li>\n		<li>一点一点小的成功会积累你的自信</li>\n		<li>失败不是成功之母，总结才是成功的亲娘</li>\n		<li>我，就是这么优秀</li>\n	</ul>\n	</li>\n	<li>看淡得失\n	<ul>\n		<li>尽人事听天命</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,304796631336656886,'2019-06-30 02:14:25','2019-06-30 02:14:25'),(305108629001773056,'<h1>自我介绍</h1>','sys','待编辑','<p><strong>1、让你自我介绍的目的</strong></p>\n\n<ul>\n	<li>你的自我介绍与简历内容是否一致</li>\n	<li>你初步的岗位胜任能力和价值取向</li>\n	<li>你的语言表达能力、总结概况能力等</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、自我介绍的三件事</strong></p>\n\n<ul>\n	<li>我是谁\n	<ul>\n		<li>姓甚名谁，哪里生人，年龄，毕业学校，所学专业，应聘职位</li>\n		<li>简单快速的说</li>\n	</ul>\n	</li>\n	<li>我做过什么、我做成过什么\n	<ul>\n		<li>代表你的经验和经历</li>\n		<li>代表你的能力和水平</li>\n	</ul>\n	</li>\n	<li>我想做什么\n	<ul>\n		<li>表达一下求职意愿</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、时间分配</strong></p>\n\n<ul>\n	<li>10%-15%，我是谁</li>\n	<li>70%-80%，我做过什么、我做成过什么</li>\n	<li>10%-15%，我想做什么</li>\n	<li>三分钟自我介绍，600字左右，语速不要太快或太慢</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、自我介绍的三条建议</strong></p>\n\n<ul>\n	<li>自我介绍，事先以文字的形式写好背熟</li>\n	<li>切中要害，不谈无关内容</li>\n	<li>条理清楚，层次分明</li>\n</ul>\n',0,304962812706201600,'2019-06-30 02:08:35','2019-06-30 02:08:35'),(305108629001773066,'<h1>自我介绍</h1>','sys','待编辑','<ul>\n	<li><!--StartFragment -->我叫阮剑达，来自中北大学，机械本科毕业。</li>\n	<li>毕业后进入一家机械制造企业，进行的是产品设计工作。</li>\n	<li>之后因兴趣爱好及个人发展的考虑，在自学了Java开发基础后，于16年进入了一家信息技术公司，进行了2年的项目后台开发。这期间的使用的框架是spring、springmvc、mybatis，缓存用的是redis，还有一些常用的开发工具如eclipse、svn、maven、tomcat等。通过这份工作，我积累了项目开发经验，掌握了常用的开发工具，具备了项目开发的技能。</li>\n	<li>之后因为欠薪问题，我离开了这家公司。为开阔眼界，我来到了深圳，进入了一家上市公司。这期间，主要是对华为告警处理平台进行开发升级，负责其中几个微服务。使用的是springcloud技术栈及一些基本的开发框架，如spring、redis、kafka等。期间，我通过学习掌握了springcloud技术栈的基本使用，也积累了大型管理平台的开发经验。因为工作完成较好，薪资评级得到提档。&nbsp;</li>\n	<li>之后，项目组随客户方搬到东莞，我不打算离开深圳，就离开了这家公司。离职后，我休整了一段时间，对自己所学的知识进行了整理巩固。对于以后，我也准备学习大数据，跟上技术的发展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,304778037714395126,'2019-07-02 02:21:18','2019-07-02 02:21:18'),(305108643350487040,'<h1>一些问题</h1>','sys','待编辑','<p><strong>1、为什么转行？</strong></p>\n\n<ul>\n	<li>兴趣、性格</li>\n	<li>比较看重他人对自己的看法</li>\n	<li>希望有一个比较好的未来</li>\n</ul>\n\n<pre><code>    首先，是因为自己的兴趣爱好。我在大学时，就对软件工具比较感兴趣，曾捣鼓过Visual C++、Photoshop及以前的网页三剑客（Dreamweaver、Fireworks和Flash），有借阅过相关书籍。\n    再者，也是由性格使然，我的性格偏内向点，我觉得跟电脑打交道很适合我。\n    再者，我也比较看重他人对自己的看法。因为我是农村出来的嘛。别人不读书下广东打工，一个月同样拿三四千，就说你读大学有什么用。我不想父母辛苦供我上大学，还得被人看不起。\n    最后，还是归结于前途，我不希望靠工龄涨工资。我希望自己的未来多姿多彩而不是一成不变，而互联网这个行业，上限很高，能提供给我广阔的舞台。至于，能到达到什么样的高度，终归要试试才能知道。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、为什么从企凡离职？</strong></p>\n\n<ul>\n	<li>其实是不想离职的，这家公司它提供我转行后的第一份工作，这个机会很不容易，我很感激它。</li>\n	<li>但是没办法，毕竟出来是打工赚钱的，被连续欠薪半年，也不得不离开。直至现在（2019.6.30），欠薪还未发放。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、为什么从中软离职？</strong></p>\n\n<ul>\n	<li>华为要搬到东莞松山湖，项目组需要搬过去。</li>\n	<li>我是来深圳涨见识的，才来深圳一年就跑到东莞去，有悖于我的初衷。</li>\n	<li>在没有达到高级之前，我是不会离开深圳的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304778037714395126,'2019-06-30 02:10:56','2019-06-30 02:10:56'),(305132862046117888,'<h1>典型面试问题</h1>','sys','待编辑','<p><strong>1、没有任何面试官会和你闲聊天</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、你有什么兴趣爱好？</strong></p>\n\n<ul>\n	<li>避免太闲或太险的爱好</li>\n	<li>要给面试官正面的联想</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、你为什么离开上家公司？</strong></p>\n\n<ul>\n	<li>求发展</li>\n	<li>不可抗力</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、你认为自己最大的缺点是什么？</strong></p>\n\n<ul>\n	<li>不要与职位冲突</li>\n	<li>不要是致命的缺点</li>\n	<li>确实是缺点，但对工作影响不大</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、介绍下你的实习经历/项目经验？</strong></p>\n\n<ul>\n	<li>突出重点</li>\n	<li>注意细节</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、你如何评价自己的大学生活？</strong></p>\n\n<ul>\n	<li>学到了什么</li>\n	<li>会做什么</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、与主管意见有分歧，你会怎么做？</strong></p>\n\n<ul>\n	<li>首先服从</li>\n	<li>事后请教</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、你有什么样的职业规划？</strong></p>\n\n<ul>\n	<li>不与职位冲突的前提下，如实回答</li>\n	<li>规划最好与公司的发展相契合</li>\n	<li>强调做好本职工作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>9、为什么选择我们公司？</strong></p>\n\n<ul>\n	<li>对行业的了解</li>\n	<li>对公司的认同</li>\n	<li>对职业的热爱</li>\n	<li>有信心做好这份工作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304962812706201600,'2019-06-30 02:57:00','2019-06-30 02:57:00'),(305143277882875904,'<h1>面对刁难</h1>','sys','待编辑','<p><strong>1、面试官为什么要刁难你？</strong></p>\n\n<ul>\n	<li>可能是故意的，即压力面试，</li>\n	<li>是一种面试手法，测试你的抗压能力、心理素质</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、面对刁难？</strong></p>\n\n<ul>\n	<li>镇定，保持心态平和</li>\n	<li>适当反问</li>\n	<li>保持涵养</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、掌控情绪， 是混迹职场的必要技能</strong></p>\n\n<ul>\n	<li>不要让上一场面试的情绪，影响下一场面试</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、发飙前问自己三个问题？</strong></p>\n\n<ul>\n	<li>这事是别人的错么？</li>\n	<li>这事值得生气么？</li>\n	<li>生气能解决问题么？</li>\n</ul>\n',0,304962812706201600,'2019-06-30 03:12:50','2019-06-30 03:12:50'),(305147369426427904,'<h1>面试谈薪</h1>','sys','待编辑','<p><strong>1、期望薪资</strong></p>\n\n<ul>\n	<li>面试之前，就应该心中有数，确认自己的底线</li>\n	<li>报薪资，稍微留点水分，预留谈判空间</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、薪资范围？</strong></p>\n\n<ul>\n	<li>最低值就是你真实的最低要求</li>\n	<li>最高值不超过最低值的1.5倍</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>3、面试前询问薪资？</strong></p>\n\n<ul>\n	<li>如果手上筹码多，在职，技术强，可以先大概了解下，避免浪费时间</li>\n	<li>如果手上筹码少，先别问，即便薪资不合意，就当增加一次面试经验</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、什么时候开始谈钱？</strong></p>\n\n<ul>\n	<li>面试官问你的时候</li>\n	<li>面试结束的时候，如果觉得有可能面上。</li>\n	<li>不要表现得过于看重钱</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、怎么谈薪？</strong></p>\n\n<ul>\n	<li>面试官心理\n	<ul>\n		<li>要价太高，担心满足不了，即便入职，也担心你的稳定性</li>\n		<li>要价太低，担心你能力不足</li>\n	</ul>\n	</li>\n	<li>理想情况\n	<ul>\n		<li>薪资稍微超出预期</li>\n	</ul>\n	</li>\n	<li>两种误区\n	<ul>\n		<li>不敢谈钱，越卑微越让人觉得你没能力</li>\n		<li>乱要钱：以生活成本为依据谈薪资</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、正确评价自己的身价？</strong></p>\n\n<ul>\n	<li>谈薪要随行就市</li>\n	<li>客观评价自己</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、工资要少了，怎么办？</strong></p>\n\n<ul>\n	<li>愿赌服输，不要去纠结</li>\n	<li>提升自己能力才是王道</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>9、被问到上家公司的薪资？</strong></p>\n\n<ul>\n	<li>可以说年薪</li>\n	<li>可以说些隐形福利\n	<ul>\n		<li>年终奖</li>\n		<li>公司租房补贴</li>\n	</ul>\n	</li>\n	<li>不要解释，解释就是掩饰</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>10、这份工作你能学到很多东西？</strong></p>\n\n<ul>\n	<li>画大饼，是非常虚幻的东西</li>\n	<li>画大饼，是HR的常规动作，是他的工作职责</li>\n	<li>记住，不要这个饼少影响你的薪资期望。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>11、如果没有更好的选择，眼前的选择就是最好的选择</strong></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,304962812706201600,'2019-06-30 03:58:49','2019-06-30 03:58:49'),(305159725623713792,'<h1>你有什么问题要问我吗？</h1>','sys','待编辑','<p><strong>1、面试官这个问题的潜台词</strong></p>\n\n<ul>\n	<li>你还想了解什么，才会选择我们公司</li>\n	<li>你到底多想到我们公司工作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、避免犯错</strong></p>\n\n<ul>\n	<li>千万不要傻了吧唧的说“我没有问题了”</li>\n	<li>不要直不楞登的问薪酬福利，加不加班</li>\n	<li>别不走心的问很容易找到答案的问题</li>\n	<li>也不要自曝其短</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、问题示例</strong></p>\n\n<ul>\n	<li>公司对这个职位有什么期望么？</li>\n	<li>这个部门这个项目组有多少人？</li>\n	<li>入职后有相关的技能培训么？</li>\n	<li>为了更好的胜任这份工作，我还需要补充哪些技能呀？</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,305159181966417920,'2019-06-30 04:16:35','2019-06-30 04:16:35'),(305163267927351296,'<h1>你回去等通知吧！</h1>','sys','待编辑','<p><strong>1、可以询问下回复时间</strong></p>\n\n<ul>\n	<li>“我大概什么时候能得到贵公司的回复呀？”</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、可以请教下面试官</strong></p>\n\n<ul>\n	<li>我哪方面表现不好，</li>\n	<li>我哪方面能力有欠缺，需要补充什么，希望你给点建议</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,305159181966417920,'2019-06-30 04:21:55','2019-06-30 04:21:55'),(305164737401757696,'<h1>失败不是成功之母，总结才是成功的亲娘</h1>','sys','待编辑','<p><strong>1、面试官为什么不直接拒绝你</strong></p>\n\n<ul>\n	<li>拒绝人需要花费成本</li>\n	<li>面试官没拿定主意</li>\n	<li>拒绝人也不是愉快的事情</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、没接到offer之前，面试结果都是未知数。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、不要影响自己的信心，影响自己的情绪，全身心投入下一家面试</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、一般来说，没回复就是没面上</strong></p>\n',0,305159181966417920,'2019-06-30 04:31:24','2019-06-30 04:31:24'),(305169102497816576,'<h1>如何选择工作</h1>','sys','待编辑','<p><strong>1、面对HR画的大饼</strong></p>\n\n<ul>\n	<li>你的决定，与饼无关</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、考虑标准</strong></p>\n\n<ul>\n	<li>第一是职业</li>\n	<li>第二是城市</li>\n	<li>第三是行业</li>\n	<li>第四是公司</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、小城市？大城市？小公司？大公司？</strong></p>\n\n<ul>\n	<li>利于你的成长，尤其是职业生涯的前5年</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、选择工作的考量点</strong></p>\n\n<ul>\n	<li>工作内容，两点之间直线最短</li>\n	<li>部门情况，站在巨人的肩膀上</li>\n	<li>公司发展，锅里有碗里才能有</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、职业发展</strong></p>\n\n<ul>\n	<li>先做一条小河沟的小鱼</li>\n	<li>再做一条大河沟的小鱼</li>\n	<li>然后做一条大河沟的大鱼</li>\n	<li>时机成熟的时候，自己挖池塘养点鱼</li>\n</ul>\n',0,304778037714395136,'2019-06-30 04:55:31','2019-06-30 04:55:31'),(305173578692599808,'<h1>如何选择offer</h1>','sys','待编辑','<p><strong>1、基本原则</strong></p>\n\n<ul>\n	<li>没有完美的工作，当下没有，未来也不会有</li>\n	<li>当你没有更好的选择，眼前就是最好的选择</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、找工作</strong></p>\n\n<ul>\n	<li>两害相权取其轻</li>\n	<li>两利相权取其重</li>\n	<li>只要一份工作符合你主要的考量点，就是好工作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、如何拒绝offer</strong></p>\n\n<ul>\n	<li>前提：确认自己是否真的要拒绝</li>\n	<li>步骤：\n	<ul>\n		<li>真诚的表达感谢</li>\n		<li>说明拒绝的理由</li>\n		<li>表达下有机会再合作的意愿</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、拒绝offer又后悔了，怎么办？</strong></p>\n\n<ul>\n	<li>脸皮厚</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、辞职时，需要坦白已经有offer了么？</strong></p>\n\n<ul>\n	<li>不要以辞职要挟来谈条件</li>\n	<li>最好是愉快的分手，站好最后一班岗</li>\n</ul>\n',0,305173532265848832,'2019-06-30 05:16:42','2019-06-30 05:16:42'),(305178867286319104,'<h1>入职前需要确认的事</h1>','sys','待编辑','<p><strong>1、丑话不说在前面，丑事就会发生在后面</strong></p>\n\n<ul>\n	<li>试用期多久？</li>\n	<li>是否需要长期出差？</li>\n	<li>公司上下班是几点？</li>\n	<li>挑一些自己重点关注的问，其他含糊的问：贵公司还有什么福利待遇呀？</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,305173532265848832,'2019-06-30 05:24:48','2019-06-30 05:24:48'),(305180762277060608,'<h1>如何通过试用期</h1>','sys','待编辑','<p><strong>1、三个时间节点</strong></p>\n\n<ul>\n	<li>入职第一天，建立美好的第一印象</li>\n	<li>入职第一周，树立专业的职业形象</li>\n	<li>入职第一个月，做到非你莫属</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、第一天</strong></p>\n\n<ul>\n	<li>任人摆布，让你做什么就做什么</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、第一周</strong></p>\n\n<ul>\n	<li>注意你的态度、方法、效率</li>\n	<li>比如阶段性的反馈进度</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、第一个月，努力做个好员工</strong></p>\n\n<ul>\n	<li>出活第一\n	<ul>\n		<li>我办事你放心</li>\n		<li>汇报工作说结果</li>\n	</ul>\n	</li>\n	<li>听话第二\n	<ul>\n		<li>服从命令听指挥</li>\n		<li>积极主动，有反馈</li>\n	</ul>\n	</li>\n</ul>\n',0,305173532265848832,'2019-06-30 05:45:21','2019-06-30 05:45:21'),(305185643159265280,'<h1>如何写转正申请</h1>','sys','待编辑','<p><strong>1、职业思维</strong></p>\n\n<ul>\n	<li>主动汇报阶段性的工作总结和计划</li>\n	<li>把你的思想动态进行汇报，这是表现机会</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、转正申请</strong></p>\n\n<ul>\n	<li>成绩：你做成了什么</li>\n	<li>进步：你以后还能做什么</li>\n	<li>不足：你的自我认知（适度）</li>\n	<li>吆喝：喊口号，画大饼，表感激</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、阶段性工作汇报</strong></p>\n\n<ul>\n	<li>即便每天都是“吃饭睡觉打豆豆”\n	<ul>\n		<li>有没有吃的多了点</li>\n		<li>有没有睡得早了点</li>\n		<li>有没有换个花样打豆豆</li>\n		<li>有没有想过优化一下上菜的顺序</li>\n		<li>琢没琢磨睡觉姿势要不要改改</li>\n		<li>计没计划下周把豆豆打成什么样</li>\n	</ul>\n	</li>\n	<li>要求\n	<ul>\n		<li>成绩要有数字</li>\n		<li>行动要有进度</li>\n		<li>计划要有思考</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、光说不练假把式</strong></p>\n\n<p><strong>5、光练不说傻把式</strong></p>\n',0,305173532265848832,'2019-06-30 06:09:46','2019-06-30 06:09:46'),(305505208460288000,'<h1>笔试题</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,283963385795473408,'2019-07-17 07:43:21','2019-07-17 07:43:21'),(306215180584263680,'<h1>并发编程</h1>','sys','待编辑','<p><strong>1、线程安全问题产生原因</strong></p>\n\n<ul>\n	<li>多线程环境</li>\n	<li>存在共享数据</li>\n	<li>多条线程共同修改共享数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>2、</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,306214857434112000,'2019-07-03 02:16:58','2019-07-03 02:16:58'),(309280338063826944,'<h1>版本控制工具功能</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、协同修改</strong></p>\n\n<ul>\n	<li>多人并行不悖的修改服务器端的同一个文件。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、数据备份</strong></p>\n\n<ul>\n	<li>不仅保存目录和文件的当前状态， 还能够保存每一个提交过的历史状态。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、版本管理</strong></p>\n\n<ul>\n	<li>在保存每一个版本的文件信息的时候要做到不保存重复数据， 以节约存储空间， 提高运行效率。</li>\n	<li>SVN 采用的是增量式管理的方式</li>\n	<li>Git 采取了文件系统快照的方式。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、权限控制</strong></p>\n\n<ul>\n	<li>对团队中参与开发的人员进行权限控制。</li>\n	<li>对团队外开发者贡献的代码进行审核——Git 独有。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、历史记录</strong></p>\n\n<ul>\n	<li>查看修改人、 修改时间、 修改内容、 日志信息。</li>\n	<li>将本地文件恢复到某一个历史状态。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、分支管理</strong></p>\n\n<ul>\n	<li>允许开发团队在工作过程中多条生产线同时推进任务， 进一步提高效率</li>\n</ul>\n',0,309280225044111360,'2019-07-11 13:02:42','2019-07-11 13:02:42'),(309282002766307228,'<h1>Git 与 SVN</h1>','sys','待编辑','<p><strong>1、Git 是分布式的，SVN 不是</strong></p>\n\n<ul>\n	<li>这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Git 把内容按元数据方式存储，而 SVN 是按文件</strong></p>\n\n<ul>\n	<li>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Git 分支和 SVN 的分支不同</strong></p>\n\n<ul>\n	<li>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Git 没有一个全局的版本号，而 SVN 有</strong></p>\n\n<ul>\n	<li>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Git 的内容完整性要优于 SVN</strong></p>\n\n<ul>\n	<li>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li>\n</ul>\n',0,309280225044111360,'2019-07-11 13:19:16','2019-07-11 13:19:16'),(309282002766307328,'<h1>Git 概述</h1>','sys','待编辑','<p><strong>1、Git</strong></p>\n\n<ul>\n	<li>Git 是一个开源的<strong>分布式</strong>版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Git 优势</strong></p>\n\n<ul>\n	<li>大部分操作在本地完成，不需要联网</li>\n	<li>完整性保证</li>\n	<li>尽可能添加数据而不是删除或修改数据</li>\n	<li>分支操作非常快捷流畅</li>\n	<li>与 Linux 命令全面兼容</li>\n</ul>\n',0,309280225044111360,'2019-07-12 03:11:24','2019-07-12 03:11:24'),(309288925288898560,'<h1>Git 结构</h1>','sys','待编辑','<p><strong>1、工作区</strong></p>\n\n<ul>\n	<li>就是你在电脑里能看到的目录。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、暂存区</strong></p>\n\n<ul>\n	<li>stage，也称作索引（index）。</li>\n	<li>一般存放在&nbsp; .git/index&nbsp; 中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、版本库</strong></p>\n\n<ul>\n	<li>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,309288856988852224,'2019-07-12 03:13:05','2019-07-12 03:13:05'),(309290051501465600,'<h1>Git 工作流程</h1>','sys','待编辑','<p><img alt=\"20190711-212727-727.png\" src=\"/furesky/images/201907/20190711-212727-727.png\" style=\"height:325px; width:550px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,309288856988852224,'2019-07-11 13:49:01','2019-07-11 13:49:01'),(309297085043089408,'<h1>创建本地库</h1>','sys','待编辑','<p><strong>1、将当前目录作为本地库</strong></p>\n\n<pre><code class=\"language-bash\">git init</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、&nbsp;拷贝一个 Git 库到本地</strong></p>\n\n<pre><code class=\"language-bash\"># repo:Git 仓库。\n# directory:本地目录。\n\ngit clone &lt;repo&gt; [directory]\n</code></pre>\n\n<p>&nbsp;</p>\n',0,309295405190782976,'2019-07-11 14:35:20','2019-07-11 14:35:20'),(309303653465759744,'<h1>设置签名</h1>','sys','待编辑','<p><strong>1、形式</strong></p>\n\n<ul>\n	<li>用户名：tom</li>\n	<li>Email 地址：goodMorning@163.com</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、作用</strong></p>\n\n<ul>\n	<li>区分不同开发人员的身份</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、辨析</strong></p>\n\n<ul>\n	<li>这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系。</li>\n</ul>\n\n<p><br>\n<strong>4、命令</strong></p>\n\n<ul>\n	<li>项目级别/仓库级别：\n	<ul>\n		<li>仅在当前本地库范围内有效</li>\n		<li>信息保存位置：./.git/config 文件git&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">git config user.name tom\ngit config user.email goodMorning@163.com</code></pre>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n\n<ul>\n	<li>系统用户级别\n	<ul>\n		<li>登录当前操作系统的用户范围</li>\n		<li>信息保存位置：~/.gitconfig 文件</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">git config --global user.name tom\ngit config --global user.email goodMorning@163.com</code></pre>\n\n<p>&nbsp;</p>\n',0,309295405190782976,'2019-07-11 14:33:39','2019-07-11 14:33:39'),(309313071095914496,'<h1>常用命令</h1>','sys','待编辑','<h4><strong>git help</strong></h4>\n\n<ul>\n	<li>\n	<p>查看帮助文档</p>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git help status\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git status</strong></h4>\n\n<ul>\n	<li>查看工作区、暂存区状态</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git status -s</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git add</strong></h4>\n\n<ul>\n	<li>将工作区的文件添加到暂存区</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git add test.log\n$ git add .          #添加当前项目的所有文件</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git commit</strong></h4>\n\n<ul>\n	<li>将暂存区的文件提交到本地库</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git commit -m \'第一次版本提交\'</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git log</strong></h4>\n\n<ul>\n	<li>查看提交历史</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>git reflog</td>\n			<td>单行显示，带 HEAD</td>\n		</tr>\n		<tr>\n			<td>git log --oneline</td>\n			<td>单行显示</td>\n		</tr>\n		<tr>\n			<td>git log --pretty=oneline</td>\n			<td>单行显示</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-bash\">$ git log\n\n# 如果记录过多，则会分屏显示\n# 空格向下翻页、b 向上翻页、q 退出</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git reset&nbsp;HEAD</strong></h4>\n\n<ul>\n	<li>版本回退/前进</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">参数</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>--soft</td>\n			<td>在本地库移动 HEAD 指针</td>\n		</tr>\n		<tr>\n			<td>--mixed</td>\n			<td>在本地库移动 HEAD 指针、重置暂存区</td>\n		</tr>\n		<tr>\n			<td>--hard</td>\n			<td>在本地库移动 HEAD 指针、重置暂存区、重置工作区</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 指向给定索引值\n$ git reset --hard a6ace91\n\n# 后退 n 步\n$ git reset --hard HEAD^^     # n 为 ^ 的个数\n$ git reset --hard HEAD~2     # n 为 ~ 后的数字</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git diff</strong></h4>\n\n<ul>\n	<li>比较文件差异</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>git diff</td>\n			<td>查看尚未缓存的改动</td>\n		</tr>\n		<tr>\n			<td>git diff --cached</td>\n			<td>查看已经缓存的改动</td>\n		</tr>\n		<tr>\n			<td>git diff HEAD</td>\n			<td>查看已缓存与未缓存的所有改动</td>\n		</tr>\n		<tr>\n			<td>git diff --stat</td>\n			<td>显示摘要</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<h4><strong>git rm</strong></h4>\n\n<ul>\n	<li>删除文件</li>\n</ul>\n\n<pre><code class=\"language-bash\"># 删除工作区文件\n$ git rm test.log\n\n# 删除暂存区文件\n$ git rm --cached test.log</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git mv</strong></h4>\n\n<ul>\n	<li>移动或重命名一个文件</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git mv test.log test.txt</code></pre>\n\n<p>&nbsp;</p>\n',0,309295405190782976,'2019-07-16 13:25:43','2019-07-16 13:25:43'),(309510949156331520,'<h1>分支管理</h1>','sys','待编辑','<p><strong>1、分支</strong></p>\n\n<ul>\n	<li>在版本控制过程中， 使用多条线同时推进多个任务。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、分支的好处</strong></p>\n\n<ul>\n	<li>同时并行推进多个功能开发， 提高开发效率</li>\n	<li>各个分支在开发过程中， 如果某一个分支开发失败， 不会对其他分支有任何影响。 失败的分支删除重新开始即可。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、git branch</strong></p>\n\n<ul>\n	<li>分支操作</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">命令</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>git branch</td>\n			<td>查看分支</td>\n		</tr>\n		<tr>\n			<td>git branch [分支名]</td>\n			<td>创建分支</td>\n		</tr>\n		<tr>\n			<td>git branch -d [分支名]</td>\n			<td>删除分支</td>\n		</tr>\n	</thead>\n</table>\n\n<pre><code class=\"language-bash\"># 查看\n$ git branch -v\n\n# 创建\n$ git branch testing\n\n# 删除\n$ git branch -d testing</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、git checkout</strong></p>\n\n<ul>\n	<li>切换分支</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git checkout testing</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、git merge</strong></p>\n\n<ul>\n	<li>合并分支</li>\n</ul>\n\n<pre><code class=\"language-bash\"># 将testing分支合并到当前分支\n$ git merge testing</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、合并冲突</strong></p>\n\n<ul>\n	<li>修改冲突文件：删除特殊符号，并保存</li>\n	<li>提交文件\n	<ul>\n		<li>git add&nbsp;[文件名]</li>\n		<li>git commit -m \"日志信息\"</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190712-125858-858.png\" src=\"/furesky/images/201907/20190712-125858-858.png\" style=\"height:193px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,309295405190782976,'2019-07-12 05:47:07','2019-07-12 05:47:07'),(309534966575702016,'<h1>Git 原理</h1>','sys','待编辑','<p><strong>1、哈希</strong></p>\n\n<ul>\n	<li>哈希是一个系列的加密算法</li>\n	<li>特点\n	<ul>\n		<li>不管输入数据的数据量有多大， 输入同一个哈希算法， 得到的加密结果长度固定。</li>\n		<li>哈希算法确定， 输入数据确定， 输出数据能够保证不变</li>\n		<li>哈希算法确定， 输入数据有变化， 输出数据一定有变化， 而且通常变化很大</li>\n		<li>哈希算法不可逆</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Git 底层</strong></p>\n\n<ul>\n	<li>Git 底层采用的是哈希的 SHA-1 算法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Git 的文件管理机制</strong></p>\n\n<ul>\n	<li>Git 把数据看作是小型文件系统的一组快照。</li>\n	<li>每次提交更新时 Git 都会对当前的全部文件制作一个快照并保存这个快照的索引。</li>\n	<li>为了高效， 如果文件没有修改，Git 不再重新存储该文件， 而是只保留一个链接指向之前存储的文件。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,309280225044111360,'2019-07-12 05:51:34','2019-07-12 05:51:34'),(310774924879765504,'<h1>创建远程库</h1>','sys','待编辑','<p><strong>1、GitHub</strong></p>\n\n<ul>\n	<li><a href=\"https://github.com/\">https://github.com/</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、步骤</strong></p>\n\n<p><img alt=\"20190716-205901-901.png\" src=\"/furesky/images/201907/20190716-205901-901.png\" style=\"height:277px; width:600px\"></p>\n\n<p><img alt=\"20190716-210012-012.png\" src=\"/furesky/images/201907/20190716-210012-012.png\" style=\"height:798px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、远程库地址</strong></p>\n\n<p><img alt=\"20190716-210352-352.png\" src=\"/furesky/images/201907/20190716-210352-352.png\" style=\"height:335px; width:600px\"></p>\n\n<p>&nbsp;</p>\n',0,310774903040024576,'2019-07-16 13:08:35','2019-07-16 13:08:35'),(311099418366353398,'<h1>添加远程库</h1>','sys','待编辑','<p><strong>1、添加远程库</strong></p>\n\n<ul>\n	<li>git remote add [shortname] [url]</li>\n</ul>\n\n<pre><code>$ git remote add origin https://github.com/jianda-int/furesky-cms.git\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、SSH 登录</strong></p>\n\n<ul>\n	<li>生成 SSH Key 文件\n	<ul>\n		<li>$ ssh-keygen -t rsa -C \"youremail@example.com\"</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>打开&nbsp;id_rsa.pub，复制里面的&nbsp;key\n	<ul>\n		<li>~/.ssh/id_rsa.pub</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>回到 github 上，\n	<ul>\n		<li>进入Settings</li>\n		<li>选择&nbsp;SSH and GPG keys</li>\n		<li>点击&nbsp;New SSH key，设置标题，粘贴 key</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>验证\n	<ul>\n		<li>$ ssh -T git@github.com</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ ssh -T git@github.com\nHi origin! You\'ve successfully authenticated, but GitHub does not provide shell access.</code></pre>\n\n<ul>\n</ul>\n',0,310774903040024576,'2019-07-17 02:01:26','2019-07-17 02:01:26'),(311099418366353408,'<h1>远程库管理</h1>','sys','待编辑','<h4><strong>git remote</strong></h4>\n\n<ul>\n	<li>查看远程库</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git remote -v\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git remote add</strong></h4>\n\n<ul>\n	<li>新增远程库</li>\n	<li>git remote add [库别名] [远程地址]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git remote add origin https://github.com/jianda-int/furesky-cms.git\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git remote rm</strong></h4>\n\n<ul>\n	<li>删除远程库</li>\n	<li>git remote rm [库别名]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git remote rm origin</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git push</strong></h4>\n\n<ul>\n	<li>推送</li>\n	<li>git push [库别名] [分支名]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git push origin master</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git clone</strong></h4>\n\n<ul>\n	<li>克隆</li>\n	<li>git clone&nbsp;[远程地址]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git clone https://github.com/jianda-int/furesky-cms.git</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git fetch</strong></h4>\n\n<ul>\n	<li>拉取</li>\n	<li>git fetch [库别名] [分支名]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git fetch origin\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git merge</strong></h4>\n\n<ul>\n	<li>合并</li>\n	<li>git merge [库别名 / 分支名]</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git merge origin\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h4><strong>git pull</strong></h4>\n\n<ul>\n	<li>拉取</li>\n	<li>git pull [库别名] [分支名]</li>\n	<li>pull=fetch+merge</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git pull origin</code></pre>\n\n<p>&nbsp;</p>\n',0,310774903040024576,'2019-07-17 02:00:35','2019-07-17 02:00:35'),(311120141889740800,'<h1>初始化为本地库</h1>','sys','待编辑','<p><strong>1、打开 git 选项</strong></p>\n\n<ul>\n	<li>工程，右键</li>\n	<li>Team</li>\n	<li>Share Project</li>\n	<li>Git</li>\n</ul>\n\n<p><img alt=\"20190716-225236-236.png\" src=\"/furesky/images/201907/20190716-225236-236.png\" style=\"height:345px; margin-left:25px; margin-right:25px; width:550px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Create Repository</strong></p>\n\n<p><img alt=\"20190716-225548-548.png\" src=\"/furesky/images/201907/20190716-225548-548.png\" style=\"height:345px; margin-left:25px; margin-right:25px; width:550px\"></p>\n\n<p>&nbsp;</p>\n',0,311119956631527424,'2019-07-16 15:02:51','2019-07-16 15:02:51'),(311124251330387968,'<h1>忽略特定文件</h1>','sys','待编辑','<p><strong>1、说明</strong></p>\n\n<ul>\n	<li>Eclipse 为了管理工程而维护的文件， 和开发的代码没有直接关系。 最好不要在 Git 中进行追踪， 即把它们忽略。<br>\n	&nbsp;</li>\n</ul>\n\n<p><strong>2、编辑本地忽略配置文件</strong></p>\n\n<ul>\n	<li><a href=\"https://github.com/github/gitignore/blob/master/Java.gitignore\">样例文件</a></li>\n</ul>\n\n<pre><code class=\"language-bash\">.classpath\n.project\n.settings\ntarget</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、在~/.gitconfig 文件中引入上述文件</strong></p>\n\n<pre><code class=\"language-bash\">[core]\n    excludesfile = C:/Users/jianda/Java.gitignore</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、或直接编辑工程目录的 .gitignore 文件</strong></p>\n',0,311119956631527424,'2019-07-16 15:22:39','2019-07-16 15:22:39'),(311134318893113344,'<h1>日常操作</h1>','sys','待编辑','<p><img alt=\"20190716-235555-555.png\" src=\"/furesky/images/201907/20190716-235555-555.png\" style=\"height:555px; width:900px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,311119956631527424,'2019-07-16 15:59:44','2019-07-16 15:59:44'),(311138430548353024,'<h1>推送到远程库</h1>','sys','待编辑','<p><strong>1、打开选项</strong></p>\n\n<ul>\n	<li>工程右击</li>\n	<li>Team</li>\n	<li>Remote</li>\n	<li>Push...</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、步骤</strong></p>\n\n<p><img alt=\"20190717-000901-901.png\" src=\"/furesky/images/201907/20190717-000901-901.png\" style=\"height:492px; margin-left:25px; margin-right:25px; width:650px\"></p>\n\n<p><img alt=\"20190717-000901-950.png\" src=\"/furesky/images/201907/20190717-000901-950.png\" style=\"height:530px; margin-left:25px; margin-right:25px; width:650px\"></p>\n\n<p><img alt=\"20190717-000949-949.png\" src=\"/furesky/images/201907/20190717-000949-949.png\" style=\"height:374px; margin-left:25px; margin-right:25px; width:650px\"></p>\n\n<p>&nbsp;</p>\n',0,311119956631527424,'2019-07-17 02:05:05','2019-07-17 02:05:05'),(311284532039819264,'<h1>报错：fatal: refusing to merge unrelated histories</h1>','sys','待编辑','<p><strong>1、原因</strong></p>\n\n<ul>\n	<li>远程库与本地库提交历史不一致。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、解决方法</strong></p>\n\n<ul>\n	<li>--allow-unrelated-histories允许不相关历史进行提交</li>\n</ul>\n\n<pre><code class=\"language-bash\">$ git pull origin master --allow-unrelated-histories</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,309278468985495552,'2019-07-17 01:45:12','2019-07-17 01:45:12'),(311292495097929728,'<h1>团队协作</h1>','sys','待编辑','<p><strong>1、邀请团队成员</strong></p>\n\n<ul>\n	<li>邀请人生成邀请链接，并发给成员</li>\n	<li>成员登录自己的 GitHub账号， 访问邀请链接，并接受</li>\n</ul>\n\n<p><img alt=\"20190717-101548-548.png\" src=\"/furesky/images/201907/20190717-101548-548.png\" style=\"height:117px; margin-left:25px; margin-right:25px; width:900px\"></p>\n\n<p><img alt=\"20190717-101617-617.png\" src=\"/furesky/images/201907/20190717-101617-617.png\" style=\"height:237px; margin-left:25px; margin-right:25px; width:900px\"></p>\n\n<p><img alt=\"20190717-101643-643.png\" src=\"/furesky/images/201907/20190717-101643-643.png\" style=\"height:247px; margin-left:25px; margin-right:25px; width:900px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,310774903040024576,'2019-07-17 02:25:32','2019-07-17 02:25:32'),(311298531317948416,'<h1>报错：rejected-non-fast-forward</h1>','sys','待编辑','<p><strong>1、原因</strong></p>\n\n<ul>\n	<li>所提交的代码与远程库冲突</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、方案一</strong></p>\n\n<ul>\n	<li>每次本地修改代码前先从git仓库pull下想要提交的分支的最新代码，改完了commit并push到git仓库。</li>\n	<li>前提：修改、commit和push期间没人动你修改的文件</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、方案二</strong></p>\n\n<ul>\n	<li>期间文件在git仓库被改了，那么重新从git仓库获取最新的分支代码，然后把自己的修改放上去提交</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、方案三</strong></p>\n\n<ul>\n	<li>通过merge来解决冲突。识别哪些文件有冲突，一个一个改，改好了再pull下最新代码，然后提交到远程仓库。</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,309278468985495552,'2019-07-17 02:40:40','2019-07-17 02:40:40'),(311300156971458560,'<h1>克隆工程</h1>','sys','待编辑','待编辑',0,311119956631527424,'2019-07-17 02:42:31','2019-07-17 02:42:31'),(315079774731931548,'<h1>Kettle 基本概念</h1>','sys','待编辑','<p><strong>1、Kettle 设计原则</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>易于开发<br>\n			避免自定义开发<br>\n			所有的功能都通过用户界面完成<br>\n			没有命名限制</td>\n			<td>\n			<p>透明<br>\n			灵活的数据通道<br>\n			只映射需要映射的字段</p>\n\n			<p>&nbsp;</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Kettle 设计模块</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>转换<br>\n			作业<br>\n			转换或作业的元数据</td>\n			<td>\n			<p>工具<br>\n			资源库<br>\n			虚拟文件系统</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、参数和变量</strong></p>\n\n<ul>\n	<li>参数\n	<ul>\n		<li>位置参数：通过位置获取参数值</li>\n		<li>命名参数：通过名称获取参数值</li>\n	</ul>\n	</li>\n	<li>变量\n	<ul>\n		<li>使用变量：${变量名}</li>\n		<li>定义变量\n		<ul>\n			<li>系统内置</li>\n			<li>用户定义\n			<ul>\n				<li>通过文件：~/.kettle/kettle.properties</li>\n				<li>通过步骤：\"Set Variables\" 步骤</li>\n			</ul>\n			</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、可视化编程</strong></p>\n\n<ul>\n	<li>Kettle 可以使用图形化的方法定义复杂的 ETL 程序和工作流，是一种可视化编程语言。</li>\n	<li>Kettle 里的图就是转换和作业</li>\n	<li>Kettle 可以快速的构建复杂的 ETL 作业和减低维护工作量</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318728151894892544,'2019-09-09 14:57:11','2019-09-09 14:57:11'),(315079774731931638,'<h1>ETL 入门</h1>','sys','待编辑','<p><strong>1、OLTP 与 OLAP</strong></p>\n\n<ul>\n	<li>OLTP\n	<ul>\n		<li>联机事务处理，On-Line Transaction Processing</li>\n		<li>是传统关系型数据库的主要应用，主要是基本的、日常的事务处理</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>OLAP\n	<ul>\n		<li>联机分析处理，On-Line Analytical Processing</li>\n		<li>是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">OLTP</th>\n			<th scope=\"col\">OLAP</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>用户</td>\n			<td>操作人员，低层管理人员</td>\n			<td>决策人员，高级管理人员</td>\n		</tr>\n		<tr>\n			<td>功能</td>\n			<td>日常操作处理</td>\n			<td>分析决策</td>\n		</tr>\n		<tr>\n			<td>DB设计</td>\n			<td>面向应用</td>\n			<td>面向主题</td>\n		</tr>\n		<tr>\n			<td>数据</td>\n			<td>当前的、最新的、细节的、二维的、分立的</td>\n			<td>历史的、聚焦的、多维的、集成的、统一的</td>\n		</tr>\n		<tr>\n			<td>存取</td>\n			<td>读/写数十条数据</td>\n			<td>读上百万条记录</td>\n		</tr>\n		<tr>\n			<td>工作单位</td>\n			<td>简单的事务</td>\n			<td>复杂的查询</td>\n		</tr>\n		<tr>\n			<td>用户数</td>\n			<td>上千个</td>\n			<td>上百万个</td>\n		</tr>\n		<tr>\n			<td>DB大小</td>\n			<td>100MB-GB</td>\n			<td>\n			<p>100GB-TB</p>\n			</td>\n		</tr>\n		<tr>\n			<td>时间要求</td>\n			<td>具有实时性</td>\n			<td>对时间的要求不严格</td>\n		</tr>\n		<tr>\n			<td>主要应用</td>\n			<td>数据库</td>\n			<td>\n			<p>数据仓库</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、ETL 的定义</strong></p>\n\n<ul>\n	<li>将数据从 OLTP 系统中转移到数据仓库中的一系列操作的集合。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>抽取 - Extract</td>\n			<td>此过程需要连接到不同的数据源，以便为后续步骤提供数据</td>\n		</tr>\n		<tr>\n			<td>转换 - Transform</td>\n			<td>在抽取、加载之间，任何对数据的处理过程都是转换</td>\n		</tr>\n		<tr>\n			<td>加载 - Load</td>\n			<td>将数据加载到目标系统的所有操作</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、ETL 基本构成</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>作业</td>\n			<td>ETL解决方案的代理</td>\n		</tr>\n		<tr>\n			<td>转换</td>\n			<td>基础的构建部分</td>\n		</tr>\n		<tr>\n			<td>步骤</td>\n			<td>组成一个转换业务流程</td>\n		</tr>\n		<tr>\n			<td>跳 -&nbsp;hop</td>\n			<td>步骤之间的连接关系由跳来决定</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、ETL 工具的通用特性</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>连接数据源<br>\n			平台独立<br>\n			数据规模<br>\n			设计灵活性<br>\n			复用性</td>\n			<td>扩展性<br>\n			数据转换<br>\n			测试和调试<br>\n			血统和影响分析<br>\n			日志和审计</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、ETL 的其他用途</strong></p>\n\n<ul>\n	<li>自动化数据迁移</li>\n	<li>数据同步</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、概念扩展：ELT、EII</strong></p>\n\n<ul>\n	<li>ELT：抽取、加载、转换</li>\n	<li>EII：企业信息集成，Enterprise Information Integration</li>\n</ul>\n',0,318728151894892534,'2019-08-08 15:31:42','2019-08-08 15:31:42'),(315079774731931643,'<h1>ETL 子系统</h1>','sys','待编辑','<p><strong>1、抽取</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>抽取系统</p>\n\n			<p>数据剖析系统<br>\n			增量数据捕获系统</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、清洗和更正数据</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>数据清洗和质量处理系统<br>\n			错误事件处理<br>\n			审计维度<br>\n			排除重复记录系统<br>\n			数据一致性</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、数据发布</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>缓慢变更维度处理<br>\n			代理键生成系统<br>\n			层次维度构建<br>\n			特殊维度生成系统</p>\n\n			<p>&nbsp;</p>\n			</td>\n			<td>\n			<p>事实表加载<br>\n			代理键管道<br>\n			多值维度桥接表生成系统<br>\n			迟到数据处理</p>\n\n			<p>&nbsp;</p>\n			</td>\n			<td>维度管理系统<br>\n			事实表管理系统<br>\n			聚集构建<br>\n			OLAP Cube 构建系统<br>\n			数据整合管理系统</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、管理 ETL 环境</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>作业调度<br>\n			备份系统<br>\n			恢复和重新启动系统<br>\n			版本控制系统</p>\n			</td>\n			<td>\n			<p>版本移植系统<br>\n			工作流监控<br>\n			排序系统<br>\n			血统和依赖分析</p>\n			</td>\n			<td>问题报告系统<br>\n			并行和管道系统<br>\n			安全系统<br>\n			合规报告系统<br>\n			元数据资源库管理系统</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,318728151894892534,'2019-08-11 05:57:33','2019-08-11 05:57:33'),(315079774731931648,'<h1>Kettle - 转换</h1>','sys','待编辑','<p><strong>1、转换，transformation</strong></p>\n\n<ul>\n	<li>并行执行</li>\n	<li>处理抽取、转换、加载各种对数据的操作，是 ETL 解决方案中最主要的部分。</li>\n	<li>转换包含一个或多个步骤，如读取文件等</li>\n	<li>转换里的步骤通过跳来连接，跳定义一个单向通道，允许数据从一个步骤向另一个步骤流动</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、步骤，step</strong></p>\n\n<ul>\n	<li>即控件，是转换里的基本的组成部分</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>关键特性</td>\n			<td>\n			<p>1、步骤名称在转换中唯一</p>\n\n			<p>2、每个步骤都会读、写数据行<br>\n			3、步骤可以有多个输出跳，可以将数据进行分发或复制</p>\n\n			<p>4、步骤将数据写到与之相连的输出跳，再传送到跳的另一端的步骤</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、转换跳，hop</strong></p>\n\n<ul>\n	<li>即步骤之间带箭头的连线</li>\n	<li>定义了步骤之间的数据通路</li>\n	<li>跳实际上是两个步骤之间的被称为行集（row set）的数据行缓存\n	<ul>\n		<li>当行集满了，向行集写数据的步骤将停止写入，直到行集里又有了空间</li>\n		<li>当行集空了，从行集读数据的步骤将停止读取，直到行集里又有了数据</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、数据行</strong></p>\n\n<ul>\n	<li>在Kettle里，数据的单位是行，数据流就是数据行从一个步骤到另一个步骤的移动</li>\n	<li>数据行是字段的集合</li>\n	<li>对字段的描述就是元数据</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>数据类型</td>\n			<td>String、Number、Integer、BigNumber<br>\n			Date、Boolean、Binary</td>\n		</tr>\n		<tr>\n			<td>元数据</td>\n			<td>\n			<p>名称、数据类型、格式、长度、精度</p>\n\n			<p>货币符号、小数点符号、分组符号</p>\n			</td>\n		</tr>\n		<tr>\n			<td>数据行规则</td>\n			<td>\n			<p>1、行级中的所有行都应该有同样的数据结构</p>\n\n			<p>2、字段元数据不会在转换中发生变化</p>\n\n			<p>3、空字符串被认为与null相等</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、并行</strong></p>\n\n<ul>\n	<li>对于Kettle的转换，所有的步骤都以并发的方式执行</li>\n	<li>由于跳是基于行集缓存，所以\n	<ul>\n		<li>允许每个步骤都由一个独立的线程运行</li>\n		<li>允许以最小消耗内存的数据流方式来处理数据</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、转换的运行过程</strong></p>\n\n<ul>\n	<li>当转换启动后，所有的步骤都同时启动，从它们的输入跳中读取数据，并把处理过的数据写入输出跳</li>\n	<li>直到输入跳里不再有数据，就终止步骤的运行。</li>\n	<li>当所有的步骤都中止了，整个转换就中止了</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,318728151894892544,'2019-09-09 15:32:01','2019-09-09 15:32:01'),(315079774731931652,'<h1>Kettle - 作业</h1>','sys','待编辑','<p><strong>1、作业，job</strong></p>\n\n<ul>\n	<li>串行执行</li>\n	<li>相较于转换，是更加高级的操作，</li>\n	<li>一个作业里包括多个作业项，一个作业项代表了一项工作，而转换是一种作业项，即作业里面可以包括多个转换。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、作业项</strong></p>\n\n<ul>\n	<li>作业的基本构成部分，类似转换中的步骤</li>\n	<li>作业项可以影子拷贝，影子拷贝中的信息始终保持相同</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>3、<strong>作业跳</strong></p>\n\n<ul>\n	<li>作业项之间的连线，定义了作业的执行路径。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>执行路径</td>\n			<td>\n			<p>1、无条件执行</p>\n\n			<p>2、当运行结果为真时执行</p>\n\n			<p>3、当运行结果为假时执行</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>回溯算法</p>\n			</td>\n			<td>假设执行到了图里的一条路径的某个节点时，要依次执行这个节点的所有子路径<br>\n			直到没有可以执行的子路径，然后返回该节点的上一节点。<br>\n			如此，再反复这个过程</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、结果对象</strong></p>\n\n<ul>\n	<li>作业项间可以传递一个结果对象（result object），结果对象中包含数据行</li>\n	<li>当一个作业项执行完成，才会将结果对象传递给下一个作业项</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<td>结果对象</td>\n			<td>\n			<p>1、一组数据行</p>\n\n			<p>2、一组数据行<br>\n			3、一组文件名</p>\n\n			<p>4、读、写、输入、输出、更新、删除、拒绝的行数、转换的错误数<br>\n			5、脚本作用项的退出状态（见《PDI构建ETL》P27）</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,318728151894892544,'2019-09-09 15:43:39','2019-09-09 15:43:39'),(315079774731931658,'<h1>Kettle 设计模块</h1>','sys','待编辑','<p><strong>1、转换</strong></p>\n\n<p><strong>2、作业</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、转换或作业的元数据</strong></p>\n\n<ul>\n	<li>名字、文件名、目录、描述、扩展描述</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、数据库连接</strong></p>\n\n<ul>\n	<li>指数据库连接的描述，实际连接只是在运行时才建立\n	<ul>\n		<li>连接选项：连接名称、连接类型、访问方式</li>\n		<li>连接参数：主机名、数据库名、端口号、用户名密码、其他选项</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>连接和事务\n	<ul>\n		<li>每一个作业项都打开和关闭一个独立的数据库连接</li>\n		<li>每一个转换步骤都打开一个独立的数据库连接并开始一个事务（因为是并行执行）</li>\n		<li>为解决打开多个连接而产生的问题，kettle可以在一个事务中完成转换</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>数据库集群\n	<ul>\n		<li>见《PDI构建ETL》P30</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、工具</strong></p>\n\n<ul>\n	<li>Spoon：图形界面工具</li>\n	<li>Kitchen：运行作业的，命令行工具</li>\n	<li>Pan：运行转换的，命令行工具</li>\n	<li>Cart：轻量级Web服务器，用来远程执行转换或作业</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、资源库</strong></p>\n\n<ul>\n	<li>常见资源库\n	<ul>\n		<li>数据库资源库</li>\n		<li>文件资源库</li>\n		<li>Pentaho资源库</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>资源库特性\n	<ul>\n		<li>中央存储</li>\n		<li>文件加锁</li>\n		<li>修订管理</li>\n		<li>依赖完整性检查</li>\n		<li>安全性</li>\n		<li>引用</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、虚拟文件系统</strong></p>\n\n<ul>\n	<li>Kettle 使用 Apache 的通用 VFS 作为文件处理接口</li>\n	<li>关于 VFS：<a href=\"http://commons.apache.org/vfs/\" target=\"_blank\">http://commons.apache.org/vfs/</a></li>\n	<li>见《PDI 构建 ETL》P32</li>\n</ul>\n',0,318728151894892544,'2019-09-09 15:44:33','2019-09-09 15:44:33'),(315243158462959616,'<h1>Kettle 安装和配置</h1>','sys','待编辑','<p><strong>1、Kettle 概览</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<tbody>\n		<tr>\n			<td>Spoon</td>\n			<td>开发集成环境，用于创建和设计转换或作业</td>\n		</tr>\n		<tr>\n			<td>\n			<p>Kitchen</p>\n\n			<p>Pan</p>\n			</td>\n			<td>\n			<p>命令行启动程序</p>\n\n			<p>执行作业：Kitchen</p>\n\n			<p>执行转换：Pan</p>\n			</td>\n		</tr>\n		<tr>\n			<td>Carte</td>\n			<td>HTTP服务，可以远程执行 Kettle 作业</td>\n		</tr>\n		<tr>\n			<td>Encr.bat</td>\n			<td>加密密码工具</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Kettle 安装</strong></p>\n\n<ul>\n	<li>Java 环境</li>\n	<li>kettle 安装\n	<ul>\n		<li>下载并解压缩</li>\n		<li>启动spoon.bat</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置文件</strong></p>\n\n<ul>\n	<li>配置文件目录：~/.kettle</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">文件</th>\n			<th scope=\"col\">作业</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>.spoonrc</td>\n			<td>\n			<p>保存 spoon 运行参数和状态</p>\n			</td>\n			<td>\n			<p>1、通用的设置和默认值</p>\n\n			<p>2、外观，如字体和颜色</p>\n\n			<p>3、程序状态数据</p>\n			</td>\n		</tr>\n		<tr>\n			<td>jdbc.properties</td>\n			<td>保存 JNDI 连接对象的连接参数</td>\n			<td>type、driver、url、user、password</td>\n		</tr>\n		<tr>\n			<td>kettle.properties</td>\n			<td>保存 kettle 通用属性，即变量</td>\n			<td>用于把作业和转换参数化，通过 ${变量名} 进行引用</td>\n		</tr>\n		<tr>\n			<td>kettle.pwd</td>\n			<td>为 Carte 服务执行提供授权</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>repositories.xml</td>\n			<td>保存着 kettle 资源库</td>\n			<td>\n			<p>Carte服务优先读取当前启动目录下的repositories.xml</p>\n\n			<p>未读取到，再使用~/.kettle/repositories.xml</p>\n			</td>\n		</tr>\n		<tr>\n			<td>shared.xml</td>\n			<td>保存共享对象</td>\n			<td>共享对象：一次定义，在作业和转换里，多次引用的对象</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Shell 脚本</strong></p>\n\n<ul>\n	<li>增加jar包\n	<ul>\n		<li>将jar放到libext目录下</li>\n		<li>修改启动脚本文件，添加对应jar目录</li>\n		<li>新版本，修改launcher.properties</li>\n	</ul>\n	</li>\n	<li>修改虚拟机堆大小\n	<ul>\n		<li>修改启动脚本文件</li>\n		<li>set OPT=-Xmx512M ...</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、管理 JDBC 驱动</strong></p>\n\n<ul>\n	<li>Kettle 将所有 JDBC 驱动，都保存在 libext/JDBC 目录下</li>\n	<li>添加新的 JDBC 驱动 jar 包，需重启才能生效</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,318728151894892544,'2019-08-08 15:14:29','2019-08-08 15:14:29'),(318698553365581824,'<h1>与 Git 共用密钥</h1>','sys','待编辑','<p><strong>1、现象</strong></p>\n\n<ul>\n	<li>git使用命令ssh-keygen产生的密钥在TortoiseGit中不能用。</li>\n	<li>TortoiseGit 操作远程库，需要输入密码</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、原因</strong></p>\n\n<ul>\n	<li>TortoiseGit&nbsp;使用扩展名为ppk的密钥，而不是ssh-keygen生成的rsa密钥。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、解决方案</strong></p>\n\n<ul>\n	<li>方式一：安装 TortoiseGit 安装过程中，选择使用OpenSSH方式</li>\n	<li>方式二：设置&nbsp;TortoiseGit 网络的ssh客户端位置为 Git\\usr\\bin\\ssh.exe</li>\n</ul>\n\n<p><img alt=\"20190806-210101-101.png\" src=\"/furesky/images/201908/20190806-210101-101.png\" style=\"height:438px; margin-left:35px; margin-right:35px; width:600px\"></p>\n\n<p>&nbsp;</p>\n',0,318698504812318720,'2019-08-06 13:03:21','2019-08-06 13:03:21'),(319999207347625984,'<h1>目录树中，小图标含义</h1>','sys','待编辑','<p><a href=\"http://help.eclipse.org/kepler/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-icons.htm\" target=\"_blank\">http://help.eclipse.org/kepler/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-icons.htm</a></p>\n\n<p>&nbsp;</p>\n',0,319999186439020544,'2019-08-10 02:51:30','2019-08-10 02:51:30'),(320084040480497664,'<h1>数据抽取</h1>','sys','待编辑','<p><strong>1、文件抽取</strong></p>\n\n<ul>\n	<li>文本文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">相关步骤</th>\n			<th scope=\"col\">\n			<p>分类</p>\n			</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>“文本文件输入”</p>\n\n			<p>“CSV文件输入”</p>\n\n			<p>“固定宽度文件输入”</p>\n			</td>\n			<td>\n			<p>分隔符文件（CSV）：每个字段或列都由特定字符或制表符分隔</p>\n\n			<p>固定宽度文件：每个字段或列都有指定的宽度和长度</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>XML文件</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">相关步骤</th>\n			<th scope=\"col\">\n			<p>验证 XML</p>\n			</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>“XML 输入”</p>\n\n			<p>“增加 XML 序列”</p>\n\n			<p>“XSL 转换”</p>\n\n			<p>“XSD转换”</p>\n			</td>\n			<td>\n			<p>验证xml结构</p>\n\n			<p>DTD验证</p>\n\n			<p>XSD验证（作业）</p>\n\n			<p>XSD验证（转换）</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<ul>\n	<li>特殊文件类型</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">相关步骤</th>\n			<th scope=\"col\">\n			<p>其他类型</p>\n			</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>“Access输入”</p>\n\n			<p>“XBase输入”</p>\n\n			<p>“Excel文件输入”</p>\n			</td>\n			<td>\n			<p>LDAP</p>\n\n			<p>LDIF</p>\n\n			<p>ESRI Shape ......&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、数据库抽取</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">相关步骤</th>\n			<th scope=\"col\">\n			<p>其他类型</p>\n			</th>\n		</tr>\n		<tr>\n			<td>\n			<p>“表输入”</p>\n			</td>\n			<td>\n			<p>......&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n			</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Web数据抽取</strong></p>\n\n<ul>\n	<li>Web 上的数据只有格式化，Kettle 转换才能读取</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\n	<thead>\n		<tr>\n			<th scope=\"col\">类型</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n		<tr>\n			<td>文本的Web 数据</td>\n			<td>\n			<p>步骤：“文本文件输入”<br>\n			说明：kettle使用VFS系统，类似处理本地文件一样，处理HTTP文件，所以在“文本文件输入”中可以直接将url作为文件名</p>\n			</td>\n		</tr>\n		<tr>\n			<td>HTTP客户端</td>\n			<td>步骤：“HTTP客户端”<br>\n			前提：此为查询类步骤，需要一个输入类步骤（如“生成记录”）激活它<br>\n			过程：调用URL，并返回一个字符串（CSV文本或XML格式字符串）作为结果</td>\n		</tr>\n		<tr>\n			<td>使用SOAP</td>\n			<td>Simple Object Access Protocol</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p>4、<strong>基于流的和实时的抽取</strong></p>\n\n<ul>\n	<li>kettle是和流程类型无关的工具</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,318728726812336128,'2019-08-11 09:54:20','2019-08-11 09:54:20'),(320402822113566720,'<h1>数据剖析</h1>','sys','待编辑','<p><strong>1、数据剖析</strong></p>\n\n<ul>\n	<li>指从不同源系统中，搜集数据的统计信息或其他相关信息的过程</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、数据剖析工作层次</strong></p>\n\n<ul>\n	<li>列特征分析：搜集某一列数据的统计信息，例如：\n	<ul>\n		<li>不同值的个数</li>\n		<li>null值和空字符串的个数</li>\n		<li>最大最小值</li>\n		<li>数据类型的合计、中位数、平均数、标准差</li>\n		<li>字符串模式和长度</li>\n		<li>单词个数、大小写的个数</li>\n		<li>词频统计</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>依赖性特征分析\n	<ul>\n		<li>分析表中不同列之间的依赖关系</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>连接特征分析\n	<ul>\n		<li>分析不同表之间的依赖关系</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、插件：DataCleaner</strong></p>\n\n<ul>\n	<li>数据剖析</li>\n	<li>数据验证\n	<ul>\n		<li>创建验证规则，并验证数据是否符合规则</li>\n	</ul>\n	</li>\n	<li>数据比较\n	<ul>\n		<li>比较不同模式、不同表里的数据是否一致</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,318728726812336128,'2019-08-11 05:52:53','2019-08-11 05:52:53'),(320407935309881344,'<h1>增量数据捕获</h1>','sys','待编辑','<p><strong>1、CDC</strong></p>\n\n<ul>\n	<li>Change Data Capture</li>\n	<li>变更数据捕获：识别出变化的数据并只抽取这些变化的数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、基于源数据的 CDC</strong></p>\n\n<ul>\n	<li>要求源数据里有相关属性列（例如时间戳、自增序列），来判断出增量数据</li>\n	<li>缺点\n	<ul>\n		<li>区别插入操作与更新操作</li>\n		<li>捕捉删除记录的操作</li>\n		<li>多次更新检测</li>\n		<li>时实能力</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、基于触发器的 CDC</strong></p>\n\n<ul>\n	<li>当执行更新sql语句时，激活数据库的触发器，并执行一些动作（一般用得不多）。</li>\n	<li>优点\n	<ul>\n		<li>能做到准实时的加载</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>入侵性强</li>\n		<li>需要DBA的允许</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、基于快照的 CDC</strong></p>\n\n<ul>\n	<li>快照表\n	<ul>\n		<li>一次性抽取源系统中的全部数据，把这些数据加载到数据仓库的缓冲区中，形成一个快照版本。</li>\n		<li>下次再抽取作为另一个版本，然后再比较这两个版本的数据。</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>可以检测到插入/更新/删除的数据</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>消耗大量的存储空间</li>\n		<li>性能问题</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、基于日志的 CDC</strong></p>\n\n<ul>\n	<li>数据库操作日志\n	<ul>\n		<li>数据库会把每个插入、更新、删除操作记录到日志里。</li>\n		<li>可以准实时的，从这些日志中读取到所有数据库操作，以便更新数据仓库中的数据</li>\n	</ul>\n	</li>\n	<li>优点\n	<ul>\n		<li>最高级、最没有入侵性</li>\n	</ul>\n	</li>\n	<li>缺点\n	<ul>\n		<li>只能处理特定数据库</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、CDC 比较</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:950px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">项目</th>\n			<th scope=\"col\" style=\"text-align:center\">时间戳方式</th>\n			<th scope=\"col\" style=\"text-align:center\">快照方式</th>\n			<th scope=\"col\" style=\"text-align:center\">触发器方式</th>\n			<th scope=\"col\" style=\"text-align:center\">日志方式</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>能区分插入/更新</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>周期内，检测到多次更新</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>能检测到删除</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>不具有入侵性</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>支持实时</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>需要 DBA</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n		</tr>\n		<tr>\n			<td>不依赖数据库</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">是</td>\n			<td style=\"text-align:center\">/</td>\n			<td style=\"text-align:center\">/</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>7、发布所变更的数据</strong></p>\n\n<ul>\n	<li>使用表输出步骤</li>\n	<li>文本文件输出</li>\n	<li>XML 输出</li>\n	<li>串行化到文件</li>\n	<li>复制记录到结果</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,318728726812336128,'2019-08-11 06:30:52','2019-08-11 06:30:52'),(320417561766043648,'<h1>数据清洗</h1>','sys','待编辑','<p><strong>1、数据质量原则</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">原则</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>属性值域约束</td>\n			<td>每个属性的取值范围域的约束</td>\n		</tr>\n		<tr>\n			<td>关系完整性规则</td>\n			<td>数据的唯一性和参照性约束</td>\n		</tr>\n		<tr>\n			<td>历史数据规则</td>\n			<td>对时间相关的数据，要进行时间轴的约束，时间格式的匹配</td>\n		</tr>\n		<tr>\n			<td>对象的状态依赖规则</td>\n			<td>数据是否满足所谓的状态机模型的约束</td>\n		</tr>\n		<tr>\n			<td>一般依赖规则</td>\n			<td>描述复杂的属性关系，包括冗余、派生等</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、相关步骤</strong></p>\n\n<ul>\n	<li>Kettle 中没有单一的数据清洗步骤，一般由多个步骤组合起来完成数据清洗功能。</li>\n	<li>输入步骤\n	<ul>\n		<li>很多输入步骤，可以设定特定的数据格式来读取数据。</li>\n		<li>弊端：数据进入 Kettle 时就已经被清洗了，导致不能进行数据审计。</li>\n		<li>例如：“表输入”</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>转换步骤\n	<ul>\n		<li>“计算器”</li>\n		<li>“字符串替换”</li>\n		<li>“拆分字段”</li>\n		<li>“拆分字段成行”</li>\n		<li>“字符串剪切”</li>\n		<li>“值映射”</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>校验步骤\n	<ul>\n		<li>“信用卡号码校验”</li>\n		<li>“电子邮箱校验”</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>查询步骤\n	<ul>\n		<li>“模糊匹配”</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">相似度算法（“模糊匹配”“计算器”）</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>Levenshtein、Damerau-Levenshtein</p>\n			</td>\n			<td>\n			<p>将一个字符串编辑成另一个字符串，需要的步骤。根据步骤数，衡量相似度</p>\n			</td>\n		</tr>\n		<tr>\n			<td>Needleman-Wunsch</td>\n			<td>以差异扣分的方式，来衡量相似度</td>\n		</tr>\n		<tr>\n			<td>Jaro、Jaro-Winkler</td>\n			<td>计算两个字符串的相似度，范围0~1</td>\n		</tr>\n		<tr>\n			<td>Pair Letters similarity</td>\n			<td>\n			<p>把两个字符串都分割成多个字符串，再比较这些字符。</p>\n\n			<p>相似度 = 相等的字符对个数 *2/ 字符对总数</p>\n			</td>\n		</tr>\n		<tr>\n			<td>\n			<p>Metaphone、Double Metaphone</p>\n\n			<p>Soundex、RefinedSoundEx</p>\n			</td>\n			<td>利用单词的发音来做匹配</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、使用参照表</strong></p>\n\n<ul>\n	<li>使用查询表使数据一致\n	<ul>\n		<li>提供一个输入字段，去查询参照表。</li>\n		<li>如果字段值没有匹配上，则将对应的数据行，打上错误标记。</li>\n	</ul>\n	</li>\n	<li>使用参照表使数据一致\n	<ul>\n		<li>将参照表作为数据确认主表</li>\n		<li>例如：性别编码</li>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n	</tbody>\n</table>\n\n<p><strong>4、数据校验</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:350px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">步骤</th>\n			<th scope=\"col\">特点</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>“数据校验”</td>\n			<td>可以给一个列设置多个约束<br>\n			校验数据类型<br>\n			错误合并<br>\n			正则表达式匹配<br>\n			查询值</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729439978233856,'2019-08-12 16:12:51','2019-08-12 16:12:51'),(320926243570360320,'<h1>错误处理</h1>','sys','待编辑','<p><strong>1、分类</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">种类</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>处理过程错误</td>\n			<td>因为技术原因导致处理过程不能继续的错误</td>\n		</tr>\n		<tr>\n			<td>数据校验错误</td>\n			<td>一些数据不能通过数据校验步骤</td>\n		</tr>\n		<tr>\n			<td>过滤器错误</td>\n			<td>“过滤器”步骤需要两个输出步骤，一个接收通过过滤器的数据、一个接收不通过的数据。</td>\n		</tr>\n		<tr>\n			<td>一般步骤错误</td>\n			<td>kettle中很多步骤中，都可定义错误处理步骤，用来接收当前步骤处理错误的数据</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、处理过程错误</strong></p>\n\n<ul>\n	<li>当转换里所有的步骤都运行成功，则会返回“Success”信号，否则返回“Failure”信号</li>\n	<li>作业最后执行的作业项决定着一个作业是否执行成功</li>\n	<li>方案\n	<ul>\n		<li>在作业的每个转换后面，都连接一个“发送邮件”的错误处理作业项。</li>\n		<li>通过邮件，监测运行结果\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n	<li>步骤\n	<ul>\n		<li>“Mail Failure”</li>\n		<li>“About Job”</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、处理转换中的错误</strong></p>\n\n<ul>\n	<li>转换中所有步骤都是同时启动的</li>\n	<li>方案\n	<ul>\n		<li>将相关联的步骤打包成一个转换，当成作业项，放入一个作业中。</li>\n		<li>然后再监测运行结果</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、处理数据的校验错误</strong></p>\n\n<ul>\n	<li>方案\n	<ul>\n		<li>通过步骤右键的“定义错误处理”选项</li>\n		<li>定义错误数据的处理方式</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729439978233856,'2019-08-12 16:50:21','2019-08-12 16:50:21'),(321216428093530112,'<h1>审计数据、过程质量</h1>','sys','待编辑','<p><strong>1、审计数据</strong></p>\n\n<ul>\n	<li>提高数据质量\n	<ul>\n		<li>第一步：数据剖析</li>\n		<li>第二步：检验和错误处理</li>\n		<li>第三步：审计数据</li>\n		<li>第四步：基于审计结果再更新数据，以此往复</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、审计质量</strong></p>\n\n<ul>\n	<li>错误事件表</li>\n	<li>审计维度表\n	<ul>\n		<li>提供审计事实细节</li>\n		<li>提供基本的数据质量指标和统计</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729439978233856,'2019-08-13 12:17:47','2019-08-13 12:17:47'),(321220092254281728,'<h1>数据排重</h1>','sys','待编辑','<p><strong>1、完全重复的数据</strong></p>\n\n<ul>\n	<li>步骤：“Unique rows”、“Unique rows(HashSet)”</li>\n	<li>只能识别完全相同的数据行，而且检查可以只限制在某几个字段</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、不完全重复的数据</strong></p>\n\n<ul>\n	<li>步骤：“模糊匹配”</li>\n	<li>方案\n	<ul>\n		<li>步骤1：模糊匹配</li>\n		<li>步骤2：选择出疑似记录</li>\n		<li>步骤3：查询校验值\n		<ul>\n			<li>将准确的字段信息作为校验值，进行匹配</li>\n		</ul>\n		</li>\n		<li>步骤4：过滤重复记录</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729439978233856,'2019-08-13 12:01:33','2019-08-13 12:01:33'),(321229691929812992,'<h1>事实表、维度表</h1>','sys','待编辑','<p><strong>1、维度表</strong></p>\n\n<ul>\n	<li>可以看成是用户用来分析一个事实的角度</li>\n	<li>例如：时间维度表，\n	<ul>\n		<li>其内部就是一些日，周，月，季，年，日期等数据，</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、事实表</strong></p>\n\n<ul>\n	<li>是数据聚合后依据某个维度生成的结果表</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、总之</strong></p>\n\n<ul>\n	<li>事实表就是你要关注的内容</li>\n	<li>维度表就是你观察该事务的角度，是从哪个角度去观察这个内容的&nbsp;</li>\n	<li>事实数据和维度数据的识别，必须依据具体的主题问题</li>\n	<li>一个事实表都要和一个或多个维度表相关联</li>\n</ul>\n',0,318729562703568896,'2019-08-14 16:08:53','2019-08-14 16:08:53'),(321287816080039936,'<h1>星型模型、雪花模型</h1>','sys','待编辑','<p><strong>1、星型模型</strong></p>\n\n<ul>\n	<li>是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度。</li>\n	<li>缺点：数据有一定的冗余</li>\n</ul>\n\n<p><img alt=\"20190815-001310-310.png\" src=\"/furesky/images/201908/20190815-001310-310.png\" style=\"height:410px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、雪花模型</strong></p>\n\n<ul>\n	<li>有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上。</li>\n	<li>其图解就像多个雪花连接在一起，故称雪花模型</li>\n	<li>优点\n	<ul>\n		<li>去除了数据冗余</li>\n		<li>提升了查询性能</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190815-001313-313.png\" src=\"/furesky/images/201908/20190815-001313-313.png\" style=\"height:388px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729562703568896,'2019-08-14 16:23:05','2019-08-14 16:23:05'),(321649998336663552,'<h1>处理维度表</h1>','sys','待编辑','<p><strong>1、管理各种键</strong></p>\n\n<ul>\n	<li>两种键：\n	<ul>\n		<li>业务键：在源系统中，用来唯一标识业务实体的键</li>\n		<li>代理键：在数据仓库中，用来唯一标识维度表中一行的键。（数据仓库中，以维度表来表现业务实体）</li>\n	</ul>\n	</li>\n	<li>生成代理键\n	<ul>\n		<li>“增加序列”步骤\n		<ul>\n			<li>基于计数器</li>\n			<li>基于数据库序列</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、加载维度表</strong></p>\n\n<ul>\n	<li>雪花维度表</li>\n	<li>星型维度表</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、缓慢变更维度</strong></p>\n\n<ul>\n	<li>Slowly Changing Dimensions，在现实世界中，维度的属性会随着时间的流失发生缓慢的变化。</li>\n	<li>类型：\n	<ul>\n		<li>type 1：重写</li>\n		<li>type&nbsp;2：增加新行</li>\n		<li>type&nbsp;3：增加新属性</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>更新方式\n	<ul>\n		<li>type 1：对源系统的更新，会直接更新目标的维度表。维度表总是保存当前的状态</li>\n		<li>type&nbsp;2：对源系统的更新，会往目标维度表插入一行数据。通过不同的时间戳来维护同一条维度数据的多个版本</li>\n		<li>type&nbsp;3：对源系统的更新，会在目标维度里增加列，来保存新的数据</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>特点\n	<ul>\n		<li>type 1：最容易实现，但是没有保留历史数据，无法分析历史变化信息</li>\n		<li>type&nbsp;2：可以按照时间跟踪到维度的变化</li>\n		<li>type&nbsp;3：优点是可以同时分析当前及前一次变化的属性值，缺点是只保留了最后一次变化信息</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>相关步骤\n	<ul>\n		<li>type 1：“维度查询/更新”、“联合查询/更新”、“插入更新”</li>\n		<li>type 2：“维度查询/更新”</li>\n		<li>type&nbsp;3：“数据库查询”、“更新”、“表里的列是否存在”</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、更多维度</strong></p>\n\n<ul>\n	<li>生成维度\n	<ul>\n		<li>日期和时间维度</li>\n		<li>小型维度</li>\n	</ul>\n	</li>\n	<li>杂项维度\n	<ul>\n		<li>“联合查询/更新”</li>\n	</ul>\n	</li>\n	<li>递归层次\n	<ul>\n		<li>“生成封闭表”</li>\n	</ul>\n	</li>\n</ul>\n',0,318729562703568896,'2019-08-17 14:47:27','2019-08-17 14:47:27'),(322716915797368832,'<h1>加载事实表</h1>','sys','待编辑','<p><strong>1、事实表</strong></p>\n\n<ul>\n	<li>事实表是用于分析的详细的业务数据的集合</li>\n	<li>事实表数据量大，会消耗大量的存储空间</li>\n	<li>为了把数据从源系统中加载到数据仓库中，需要一个快速的加载机制</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、批量加载</strong></p>\n\n<ul>\n	<li>加载方式\n	<ul>\n		<li>基于文件：数据在文本文件里，要从磁盘读取</li>\n		<li>基于API：不用再存储到中间文件，使用数据库提供的批量加载 API 或 STDIN，把数据流里的数据直接加载到数据库</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>加载方法\n	<ul>\n		<li>标准输入 STDIN</li>\n		<li>命名管道 FIFO</li>\n		<li>依靠Kettle 中个类型数据库的批量加载步骤</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>注意事项\n	<ul>\n		<li>涉及中间文件时，要确保文件系统有足够的空间</li>\n		<li>平衡可靠性和性能</li>\n		<li>批量加载：插入操作前是否清空表</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、维度查询</strong></p>\n\n<ul>\n	<li>维护参照完整性\n	<ul>\n		<li>在传统事务数据库中，一般通过外键约束来强制执行参照完整性</li>\n		<li>方式一：不使用外键，但不能删除维度记录，这样已加载的事实表里总能找到对应的维度</li>\n		<li>方式二：使用外键，在事实表加载完之后，再使用外键</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>代理键管道：\n	<ul>\n		<li>由若干个步骤组成的，实现了查询维度代理键的一个工作流程</li>\n		<li>从内存中查询：“数据库查询”步骤中的“使用缓存”“从表中加载所有数据”</li>\n		<li>从流中查询：“流查询”步骤</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>处理迟到的事实数据\n	<ul>\n		<li>使用 valid_from 和 valid_to 时间戳获取正确的维度代理键</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>处理迟到的维度数据\n	<ul>\n		<li>加载事实表时，当查询维度代理键失败，则以业务主键创建一条维度记录，其他字段设置为“未知”</li>\n		<li>当接收到迟到的维度数据时，则将维度记录里的“未知”字段进行更新</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、处理事实表</strong></p>\n\n<ul>\n	<li>事实表种类\n	<ul>\n		<li>标准的事务型事实表\n		<ul>\n			<li>事实表里每一行都代表了一个交易事件，</li>\n			<li>例如：产品销售量</li>\n		</ul>\n		</li>\n		<li>周期快照表\n		<ul>\n			<li>用来定期存储某种信息的状态</li>\n			<li>例如：银行账户余额</li>\n		</ul>\n		</li>\n		<li>累积快照表\n		<ul>\n			<li>是一种特殊的事务型事实表，它会定时更新</li>\n			<li>例如：订单事实数据</li>\n		</ul>\n		</li>\n		<li>面向状态的事实表\n		<ul>\n			<li>只在事实表中保存状态和状态在源系统中变化的时间</li>\n			<li>例如：房子火灾保险</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>加载周期快照表\n	<ul>\n		<li>使用一个简单的批量加载即可</li>\n		<li>注意事项\n		<ul>\n			<li>每个周期的时间点都应该完全相同</li>\n			<li>对于计算每个月账户余额，这是个非常麻烦的过程，应该交给操作系统去做</li>\n			<li>事实表里应该有一个快照的周期 ID 字段</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>加载累积快照表\n	<ul>\n		<li>加载累积快照表要用 update 方式</li>\n		<li>方式一：“插入/更新”</li>\n		<li>方式二：设立活动分区/表，所有插入更新都在活动分区/表中操作，累积加载完后，才将记录追加到只读分区/表</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>加载面向状态的事实表\n	<ul>\n		<li>“维度查询/更新”</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>加载聚集表\n	<ul>\n		<li>加载聚集表增加了 ETL 流程的复杂度和负载，但可以提高分析的性能</li>\n		<li>方式一：\n		<ul>\n			<li>使用额外步骤扩展加载事实表的转换，排序需要汇总的字段，</li>\n			<li>然后使用“内存分组”步骤把数据聚集，</li>\n			<li>最后使用“表输出““批量加载”步骤写入到聚集表</li>\n		</ul>\n		</li>\n		<li>方式二：\n		<ul>\n			<li>使用“表输入”步骤，直接生成聚集表的数据</li>\n		</ul>\n		</li>\n		<li>方式三：\n		<ul>\n			<li>使用“执行 SQL 脚本”步骤，类似方式二</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729562703568896,'2019-08-18 11:56:01','2019-08-18 11:56:01'),(323035970488016896,'<h1>处理 OLAP 数据</h1>','sys','待编辑','<p><strong>1、OLAP 的价值</strong></p>\n\n<ul>\n	<li>快速的分析查询性能</li>\n	<li>上卷和下钻的能力</li>\n	<li>切片和组合的能力</li>\n	<li>多模型易于理解</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、OLAP 的挑战</strong></p>\n\n<ul>\n	<li>如何从 OLAP cube里集成数据</li>\n	<li>如何获得不同聚集层的数据</li>\n	<li>每个 OLAP 服务提供商都按照自己定义的格式提供数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、OLAP 存储类型</strong></p>\n\n<ul>\n	<li>MOLAP：多维 OLAP，数据以多维的方式存储</li>\n	<li>ROLAP：关系型 OLAP，数据以关系型数据库方式存储</li>\n	<li>HOLAP：混合 OLAP，细粒度的数据存储在关系型数据库中，聚集后的数据存储在 LOAP 数据库中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、OLAP 在系统中的位置</strong></p>\n\n<ul>\n	<li>大多数情况下，被用作数据集市</li>\n	<li>在少数情况下，被用作数据仓库</li>\n</ul>\n\n<p><img alt=\"20190818-213218-218.png\" src=\"/furesky/images/201908/20190818-213218-218.png\" style=\"height:313px; margin-left:45px; margin-right:45px; width:450px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Kettle 中 OLAP 的相关选项</strong></p>\n\n<ul>\n	<li>“Mondrian 输入”步骤</li>\n	<li>“OLAP 输入”步骤</li>\n	<li>&nbsp; &nbsp;Palo 插件（详见《 PDI 构建 ETL 》P197）</li>\n</ul>\n',0,318729562703568896,'2019-08-18 13:52:23','2019-08-18 13:52:23'),(323065262219501568,'<h1>ETL 开发生命周期</h1>','sys','待编辑','<p><strong>1、解决方案设计</strong></p>\n\n<ul>\n	<li>好习惯\n	<ul>\n		<li>先进行数据仓库模型设计，后进行 ETL 设计</li>\n		<li>定期组织评审</li>\n		<li>标准化，在项目开始前，先开发一些标准或模板</li>\n		<li>数据映射</li>\n		<li>制定合理的名称和注释规则</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>坏习惯\n	<ul>\n		<li>一上来就编码</li>\n		<li>不和最终用户交流</li>\n		<li>基于其他项目的经验假设</li>\n		<li>忽略变化的需求</li>\n		<li>忽略生产环节的需求</li>\n		<li>过于追求完美</li>\n		<li>没有测试</li>\n		<li>不备份数据</li>\n	</ul>\n	</li>\n	<li>ETL 流设计\n	<ul>\n		<li>ETL 解决方案是一个整体的过程</li>\n		<li>要像处理业务流程一样去处理一个 ETL 流程</li>\n	</ul>\n	</li>\n	<li>可重用性和可维护性\n	<ul>\n		<li>“复制/粘贴”</li>\n		<li>使用变量</li>\n		<li>子转换/子作业</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、敏捷开发</strong></p>\n\n<ul>\n	<li>Pentaho 和&nbsp;Kettle 不只是敏捷 BI 的解决方案，更提供了一种敏捷开发的工作方式</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、测试和调试</strong></p>\n\n<ul>\n	<li>测试活动\n	<ul>\n		<li>静态测试：文档检查，代码走查</li>\n		<li>动态测试：使用被测试的软件，验证软件是否满足要求</li>\n		<li>单元测试：把某个独立的组件作为测试对象</li>\n		<li>集成测试：对完整解决方案的测试</li>\n		<li>回归测试：某个组件发生了变化后的测试，保证整个解决方案在某个组件变化后，仍可以正常工作</li>\n		<li>用户确认测试</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>ETL 测试\n	<ul>\n		<li>测试数据要求：\n		<ul>\n			<li>要测试 ETL 流程，就要有一组测试数据</li>\n			<li>测试数据要考虑几方面：数量、私有性、相对性</li>\n		</ul>\n		</li>\n		<li>完整性测试\n		<ul>\n			<li>要保证所有的数据都被处理</li>\n			<li>方法：计算记录数、哈希合计、校验值</li>\n		</ul>\n		</li>\n		<li>测试数据转换\n		<ul>\n			<li>对于给定输入，是否获得期望的输出</li>\n		</ul>\n		</li>\n		<li>测试自动化和持续集成\n		<ul>\n			<li>测试应该自动运行，建好一套测试用例后，就应该定期的跑这个测试</li>\n			<li>当新增或修改一个作业时，要将其加入到自动测试中，以实现持续集成</li>\n		</ul>\n		</li>\n		<li>升级测试\n		<ul>\n			<li>Kettle 版本升级时的测试</li>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>调试\n	<ul>\n		<li>Kettle 中 Spoon 图形界面中，可进行预览与调试</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190818-233711-711.png\" src=\"/furesky/images/201908/20190818-233711-711.png\" style=\"height:76px; margin-left:65px; margin-right:65px; width:400px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>4、解决方案文档化</strong></p>\n\n<ul>\n	<li>误区\n	<ul>\n		<li>软件可以自我解释</li>\n		<li>文档和软件比，总是会过时的</li>\n		<li>没有人读文档</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Kettle 的文档功能\n	<ul>\n		<li>描述性的名称</li>\n		<li>注释</li>\n		<li>在转换和作业设置里的描述字段</li>\n		<li>参数</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>生成文档\n	<ul>\n		<li>......</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,319463499105083392,'2019-08-18 15:46:42','2019-08-18 15:46:42'),(323094213792931840,'<h1>调度和监控</h1>','sys','待编辑','<p><strong>1、术语</strong></p>\n\n<ul>\n	<li>在生产环境中，ETL 任务一般都是以固定时间间隔来运行的。</li>\n	<li><strong>调度：</strong>这些自动定期执行的任务</li>\n	<li><strong>调度程序：</strong>用于定义和管理这些定期执行的任务的程序</li>\n	<li><strong>监控程序</strong>：监控调度过程和运行结果的程序</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、调度</strong></p>\n\n<ul>\n	<li>操作系统级调度\n	<ul>\n		<li>基于命令行：通过 Shell 脚本执行一个特定的程序，并通过参数控制程序的执行过程</li>\n		<li>通过命令行执行 Kettle 转换和作业\n		<ul>\n			<li>Kettle 中的 Pan 和 Kitchen只是在 Kettle 执行引擎上的包装</li>\n		</ul>\n		</li>\n		<li>类 Unix 系统的 cron 调度命令</li>\n		<li>Windows 系统下的at命令和计划任务</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>使用 Pentaho 内置的调度程序\n	<ul>\n		<li>详见《PDI 构建 ETL》P228</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、监控</strong></p>\n\n<ul>\n	<li>监控方式：日志和邮件</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、日志</strong></p>\n\n<ul>\n	<li>查看日志\n	<ul>\n		<li>在Spoon里，在执行窗口的日志标签下，可以查看日志</li>\n		<li>在Pan、Kitchen里，可以使用参数logfile来指定一个日志文件，否则日志将输出到标准输出</li>\n		<li>注意：Kitchen中，只会输出根作业的日志，对于每个子作业则需要另外单独配置</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>日志级别\n	<ul>\n		<li>没有日志、<strong>错误日志、</strong>最少日志、<strong>基本日志</strong></li>\n		<li>详细日志、调试日志、<strong>行级日志</strong></li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>用户自定义日志\n	<ul>\n		<li>“写日志”步骤</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、邮件</strong></p>\n\n<ul>\n	<li>“发送邮件”步骤</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,319463499105083392,'2019-08-19 16:16:45','2019-08-19 16:16:45'),(323437092985937920,'<h1>版本和移植</h1>','sys','待编辑','<p><strong>1、版本控制系统</strong></p>\n\n<ul>\n	<li>基于文件的版本控制系统</li>\n	<li>内容管理系统</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Kettle 元数据</strong></p>\n\n<ul>\n	<li>元数据\n	<ul>\n		<li>描述数据的数据</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>XML 元数据\n	<ul>\n		<li>转换 XML</li>\n		<li>作业 XML</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>资源库元数据\n	<ul>\n		<li>数据库资源库</li>\n		<li>文件资源库</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、管理资源库</strong></p>\n\n<ul>\n	<li>导入和导出资源库\n	<ul>\n		<li>Spoon 的“工具--&gt;资源库导出”</li>\n	</ul>\n	</li>\n	<li>资源库升级\n	<ul>\n		<li>将资源库导出成XML文件</li>\n		<li>备份资源库数据库本身</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、版本移植系统</strong></p>\n\n<ul>\n	<li>管理 XML 文件</li>\n	<li>管理资源库</li>\n	<li>解决方案参数化</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,319463499105083392,'2019-08-19 14:59:57','2019-08-19 14:59:57'),(323444711834296320,'<h1>血统和审计</h1>','sys','待编辑','<p><strong>1、血统分析</strong></p>\n\n<ul>\n	<li>以某个元数据为终止节点，其前与其有关系的所有元数据，反应数据的来源与加工过程</li>\n	<li>使用血统分析可分析数据来源和数据质量问题的定位</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、影响分析</strong></p>\n\n<ul>\n	<li>以某个元数据为起始节点，其后与其有关系的所有元数据，反应数据的流向与加工过程</li>\n	<li>使用影响分析可分析数据流向和数据转换中错误的定位</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、日志基础</strong></p>\n\n<ul>\n	<li>查看日志\n	<ul>\n		<li>在Spoon里，在执行窗口的日志标签下，可以查看日志</li>\n		<li>在Pan、Kitchen里，可以使用参数logfile来指定一个日志文件，否则日志将输出到标准输出</li>\n		<li>注意：Kitchen中，只会输出根作业的日志，对于每个子作业则需要另外单独配置</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>日志级别\n	<ul>\n		<li>没有日志、<strong>错误日志</strong>、最少日志、<strong>基本日志</strong></li>\n		<li>详细日志、调试日志、<strong>行级日志</strong></li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>用户自定义日志\n	<ul>\n		<li>“写日志”步骤</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、日志架构</strong></p>\n\n<ul>\n	<li>所有的日志行都被保留在一个中心缓存中。\n	<ul>\n		<li>日期和时间</li>\n		<li>日志级别</li>\n		<li>递增的唯一编号</li>\n		<li>日志文本内容</li>\n		<li>日志通道ID</li>\n	</ul>\n	</li>\n	<li>设置缓存大小</li>\n	<li>设置日志行最长保留时间</li>\n	<li>日志通道</li>\n	<li>在一个作业中捕获日志</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、日志表</strong></p>\n\n<ul>\n	<li>转换日志表\n	<ul>\n		<li>转换日志表</li>\n		<li>步骤日志表</li>\n		<li>性能日志表</li>\n		<li>日志通道日志表</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>作业日志表\n	<ul>\n		<li>作业日志表</li>\n		<li>作业项日志表</li>\n		<li>日志通道日志表</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,319463499105083392,'2019-08-19 16:16:17','2019-08-19 16:16:17'),(323470625112629248,'<h1>性能调优</h1>','sys','待编辑','<p><strong>1、找到性能瓶颈</strong></p>\n\n<ul>\n	<li>简化步骤\n	<ul>\n		<li>一出部分步骤，以观察所能提升的性能</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>度量值\n	<ul>\n		<li>监控标签的性能度量图</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>复制数据行\n	<ul>\n		<li>数据行被复制到多个步骤，慢的步骤会拖累快的步骤</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、提高转换性能</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:800px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">提高性能</th>\n			<th scope=\"col\">方式</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>读文本文件</td>\n			<td>使用延迟转换<br>\n			单一文件并发读取<br>\n			多行文件并行读取<br>\n			配置 NIO 块大小<br>\n			改变磁盘和读取文本文件</td>\n		</tr>\n		<tr>\n			<td>写文本文件</td>\n			<td>使用延迟转换<br>\n			改变磁盘和写文本文件<br>\n			修改为写入多个文件</td>\n		</tr>\n		<tr>\n			<td>数据库</td>\n			<td>\n			<p>避免动态SQL</p>\n\n			<p>处理数据的往返操作</p>\n\n			<p>减少网络延迟</p>\n\n			<p>网络速度</p>\n\n			<p>关系型数据库的优化手段</p>\n			</td>\n		</tr>\n		<tr>\n			<td>数据排序</td>\n			<td>\n			<p>对于在数据库中的数据，应尽可能使用数据库排序</p>\n\n			<p>集群排序</p>\n			</td>\n		</tr>\n		<tr>\n			<td>减少CPU消耗</td>\n			<td>\n			<p>优化JavaScript的使用</p>\n\n			<p>启动一个步骤的多个拷贝</p>\n\n			<p>选择和移去字段</p>\n\n			<p>管理线程优先级</p>\n\n			<p>给数据行添加静态数据</p>\n\n			<p>限制步骤拷贝的数量</p>\n\n			<p>避免过多的日志</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、提高作业性能</strong></p>\n\n<ul>\n	<li>避免低效的作业循环</li>\n	<li>数据库连接中，勾选“使用连接池”</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,323467252497948672,'2019-09-11 14:44:28','2019-09-11 14:44:28'),(323754048392572928,'<h1>Kettle 插件</h1>','sys','待编辑','<p><strong>1、插件类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:300px\">\n	<tbody>\n		<tr>\n			<td>转换步骤插件<br>\n			作业项插件<br>\n			数据库类型插件<br>\n			资源库类型插件</td>\n			<td>\n			<p>分区方法插件<br>\n			视图插件<br>\n			大数据插件</p>\n\n			<p>&nbsp;</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、标识插件的属性</strong></p>\n\n<ul>\n	<li>插件类型\n	<ul>\n		<li>由 PluginTypeInterface 接口定义，</li>\n		<li>例如：StepPluginType</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>插件ID\n	<ul>\n		<li>一个字符串数组，唯一标识一个插件</li>\n		<li>例如：“表输入”步骤的ID是TableInput</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、配置文件</strong></p>\n\n<ul>\n	<li>位于Kettle的.jar文件中</li>\n	<li>内部转换步骤：kettle-steps.xml</li>\n	<li>内部作业项：kettle-job-entries.xml</li>\n	<li>内部分区类型：kettle-partition-plugins.xml</li>\n	<li>内部数据库类型：kettle-database-types.xml</li>\n	<li>内部资源库类型：kettle-repositories.xml</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、加载插件</strong></p>\n\n<ul>\n	<li>初始化 Kettle 环境</li>\n	<li>插件注册系统，加载所有的内部对象，其配置文件如上</li>\n	<li>插件注册系统，加载 plugins/ 目录下的外部插件，通过特定注解定位</li>\n	<li>因为内部对象加载后才加载插件，所以插件会替代相同ID的内部对象</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、部署插件</strong></p>\n\n<ul>\n	<li>将插件打jar包</li>\n	<li>将jar放入plugins目录下</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729562703568900,'2019-08-24 18:25:43','2019-08-24 18:25:43'),(323828167479173120,'<h1>转换步骤插件</h1>','sys','待编辑','<p><strong>1、转换步骤插件</strong></p>\n\n<ul>\n	<li>包括四个Java类，分别实现四个接口</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、StepMetaInterface</strong></p>\n\n<ul>\n	<li>负责步骤里所有和元数据相关的任务</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>\n			<p>getXML()、loadXML()</p>\n\n			<p>saveRep()、readRep()</p>\n			</td>\n			<td>元数据和XML（或资源库）之间的序列化和反序列化</td>\n		</tr>\n		<tr>\n			<td>getField()</td>\n			<td>描述输出数据行的结构</td>\n		</tr>\n		<tr>\n			<td>setDefault()</td>\n			<td>设置元数据缺省值</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、StepDataInterface</strong></p>\n\n<ul>\n	<li>维护步骤的执行状态，以及存储临时对象</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、StepDialogInterface</strong></p>\n\n<ul>\n	<li>提供一个用户界面，让用户输入元数据</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、StepInterface</strong></p>\n\n<ul>\n	<li>利用StepMetaInterface对象里定义的元数据，</li>\n	<li>逐行转换和处理上个步骤传入的数据行</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>init()</td>\n			<td>初始化步骤</td>\n		</tr>\n		<tr>\n			<td>dispose()</td>\n			<td>释放资源</td>\n		</tr>\n		<tr>\n			<td>processRow()</td>\n			<td>现具体步骤处理逻辑，这个方法返回true，转换引擎就会重复调用这个方法</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,318729562703568900,'2019-08-24 17:01:22','2019-08-24 17:01:22'),(323828167479173130,'<h1>转换步骤插件：StepMetaInterface</h1>','sys','待编辑','<p><strong>1、</strong><strong>messages_en_US.properties</strong></p>\n\n<pre><code>name=Hello world\ndescription=A very simple step that adds a new \"Helllo world\" field to the incoming stream\ncategoryDescription=Plugin samples \n\nHelloworldMeta.CHECK_ERR_NO_FIELD=No field name was specified\nHelloworldMeta.CHECK_OK_FIELD=A field name is specified\n\nHelloworldDialog.Shell.Title=Hello world\nHelloworldDialog.Stepname.Label=Step name\nHelloworldDialog.Fieldname.Label=Field name</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、HelloworldStepMeta.java</strong></p>\n\n<pre><code>// @Step 注解：通知插件注册系统，这是一个步骤类型插件\n@Step(\n    id=\"Helloworld\", //ID\n    name=\"name\", //名称\n    description=\"description\", //描述\n    categoryDescription=\"categoryDescription\",  //类别\n    image=\"org/kettlesolutions/plugin/step/helloworld/HelloWorld.png\", //图标\n    i18nPackageName=\"org.kettlesolutions.plugin.step.helloworld\"//资源文件的包名\n) \npublic class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {\n    //定义了资源文件的位置\n    private static Class&lt;?&gt; PKG = HelloworldStep.class; //for i18n\n\n    //用于保存用户输入    \n    private String fieldName;\n    public String getFieldName() {\n        return fieldName;\n    }\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    //校验参数，并将校验结果添加到问题列表\n    public void check(List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, \n            RowMetaInterface prev, String input[], String output[], RowMetaInterface info) {\n        \n        if (Const.isEmpty(fieldName)) {\n            CheckResultInterface error = new CheckResult(\n                CheckResult.TYPE_RESULT_ERROR, \n                BaseMessages.getString(PKG, \"HelloworldMeta.CHECK_ERR_NO_FIELD\"), \n                stepMeta\n            );\n            remarks.add(error);\n        } else {\n            CheckResultInterface ok = new CheckResult(\n                CheckResult.TYPE_RESULT_OK, \n                BaseMessages.getString(PKG, \"HelloworldMeta.CHECK_OK_FIELD\"), \n                stepMeta\n            );\n            remarks.add(ok);\n        }\n    }\n\n\n    //与其他接口之间的桥梁\n    public StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        return new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    }\n    public StepDataInterface getStepData() {\n        return new HelloworldStepData();\n    }    \n    public String getDialogClassName() {\n        return HelloworldStepDialog.class.getName();\n    }\n\n    //将元数据保存到XML文件或资源库中，或者从XML文件或资源库读取元数据\n    public enum Tag {\n        field_name,\n    };\n    public void loadXML(Node stepDomNode, List&lt;DatabaseMeta&gt; databases,\n            Map&lt;String, Counter&gt; sequenceCounters) throws KettleXMLException {\n        fieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());\n    }\n    public String getXML() throws KettleException {\n        StringBuilder xml = new StringBuilder();\n        xml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));\n        return xml.toString();\n    }\n    public void readRep(Repository repository, ObjectId stepIdInRepository,\n            List&lt;DatabaseMeta&gt; databases, Map&lt;String, Counter&gt; sequenceCounters)\n            throws KettleException {\n        fieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());\n    }\n    public void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)\n            throws KettleException {\n        repository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);\n    }\n\n    //给变量设置默认值\n    public void setDefault() {\n        fieldName = \"helloField\";\n    }\n\n    //描述输出数据行的结构\n    //需要修改RowMetaInterface对象，使其和输出格式匹配，可以为其添加一个ValueMetaInterface对象\n    public void getFields(RowMetaInterface inputRowMeta, String name,\n            RowMetaInterface[] info, StepMeta nextStep, VariableSpace space)\n            throws KettleStepException {\n        String realFieldName = space.environmentSubstitute(fieldName);\n        ValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);\n        field.setOrigin(name);        \n        inputRowMeta.addValueMeta(field);\n    }\n}\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、值的元数据：ValueMetaInterface</strong></p>\n\n<ul>\n	<li>描述数据流里的一个字段，</li>\n	<li>定义了字段的名字，数据类型，长度，精度等</li>\n</ul>\n\n<pre><code class=\"language-java\">ValueMetaInterface dataMeta = new ValueMeta(\"birthdate\", ValueMetaInterface.TYPE_Date);\ndataMeta.setConversionMask(\"yyyy/MM/dd\");\n\n//ValueMetaInterface 也负责转换数据格式\nString birthdateString=dataMeta.getString(new Date());</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、行的元数据：RowMetaInterface</strong></p>\n\n<ul>\n	<li>描述数据行的元数据，包含了一组 ValueMetaInterface 对象</li>\n	<li>规则：行中列名必须唯一，同名列会加“_2、_3、...”的后缀</li>\n</ul>\n\n<pre><code class=\"language-java\">//示例：获取数据行中第四列的销售值\nDouble sales=getInputRowMeta().getNumber(rowData,3);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、其他方法</strong></p>\n\n<ul>\n	<li>接口间交互\n	<ul>\n		<li>getStep()</li>\n		<li>getStepData()</li>\n		<li>getDialogClassName()</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>其他方法\n	<ul>\n	</ul>\n	</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"margin-left:60px; width:920px\">\n	<tbody>\n		<tr>\n			<td>check()</td>\n			<td>检验元数据是否正确</td>\n			<td>getUsedLibraries()</td>\n			<td>描述使用的库</td>\n		</tr>\n		<tr>\n			<td>setDefault()</td>\n			<td>给元数据设置默认值</td>\n			<td>getUsedDatabaseConnections()</td>\n			<td>描述使用的数据库连接</td>\n		</tr>\n		<tr>\n			<td>analyseImpact()</td>\n			<td>\n			<p>完成对数据库的影响分析</p>\n			</td>\n			<td>getRequiredFields()</td>\n			<td>描述这个步骤需要的数据库表</td>\n		</tr>\n		<tr>\n			<td>getSQLStatements()</td>\n			<td>\n			<p>获取步骤相应的sql语句，</p>\n\n			<p>使步骤能正确运行</p>\n			</td>\n			<td colspan=\"1\">exportResources()<br>\n			getResourceDependencies()</td>\n			<td colspan=\"1\">导出元数据资源</td>\n		</tr>\n		<tr>\n			<td>getStep()<br>\n			getStepData()<br>\n			getDialogClassName()</td>\n			<td>接口间交互</td>\n			<td colspan=\"1\" rowspan=\"3\">getStepIOMeta()，<br>\n			searchInfoAndTargetSteps()<br>\n			handleStreamSelection()<br>\n			getOptionalStreams()<br>\n			resetStepIoMeta()</td>\n			<td colspan=\"1\" rowspan=\"3\">描述各类输入和输出流</td>\n		</tr>\n		<tr>\n			<td>supportsErrorHandling()<br>\n			excludeFromRowLayoutVerification()<br>\n			excludeFromCopyDistributeVerification()</td>\n			<td>描述步骤是否具有某些功能</td>\n		</tr>\n	</tbody>\n</table>\n',0,318729562703568900,'2019-08-24 17:34:56','2019-08-24 17:34:56'),(325166006573768704,'<h1>转换步骤插件：StepInterface</h1>','sys','待编辑','<p><strong>1、HelloworldStep.java</strong></p>\n\n<pre><code class=\"language-java\">public class HelloworldStep extends BaseStep implements StepInterface {\n    public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n        // TODO Auto-generated constructor stub\n    }\n    \n    public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n        HelloworldStepData data = (HelloworldStepData) sdi;\n        \n&nbsp;       //getRow()：从上一个步骤，获取一行数据\n        Object[] row = getRow();\n        if (row==null) {\n            setOutputDone();\n            return false;\n        } \n\n        // first：内部成员，其内部代码只在处理第一行数据时执行  \n        if (first) {\n            first=false;\n\n            //getInputRowMeta()：获取输入数据行的元数据\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n        }\n        \n        String value = \"Hello, world!\";        \n        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);        \n        \n        //putRow()：把数据传到下一个步骤\n        putRow(data.outputRowMeta, outputRow);        \n        return true;\n    }\n}</code></pre>\n\n<pre>\n&nbsp;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、其他方法</strong></p>\n\n<ul>\n	<li>setOutputDone()：通知其他步骤，本步骤已经没有输出数据行了</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、从指定的步骤读取数据行</strong></p>\n\n<pre><code class=\"language-java\">RowSet rowSet=findInputRowSet(Source StepName);\n//获取数据\nObject[] rowData=getRowFrom(rowSet);\n//获取元数据\nRowMetaInterface rowMeta=rowSet.getRowMeta()</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、把数据行写入到错误处理步骤</strong></p>\n\n<pre><code class=\"language-java\">Object[] rowData=getRow();\n...\ntry{\n    ...\n    putRow(...);\n}catch(Exception e){\n    if(getStepMeta().isDoingErrorHandling()){\n        putError(getInputRowMeta(),rowData,1,e.getMessage(),errorMessage,errorFieldname,errorCode);\n    }else{\n        throw(e);\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、识别一个步骤拷贝</strong></p>\n\n<ul>\n	<li>原因：一个步骤可以有多个拷贝</li>\n	<li>方法\n	<ul>\n		<li>getCopy()：获取拷贝号</li>\n		<li>getUniqueStepNrAcrossSlaves()：集群模式下，获取运行的步骤拷贝号</li>\n		<li>getUniqueStepcountAcrossSlaves()：集群模式下，获取运行的步骤拷贝总数</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、结果反馈</strong></p>\n\n<ul>\n	<li>调用getRow()、putRow()时，引擎会自动计算两类度量值：读行数、写行数</li>\n	<li>操作方法\n	<ul>\n		<li>incrementLinesRead()：增加从前面步骤读取到的行数</li>\n		<li>incrementLinesWritten()：增加写入到后面步骤中的行数</li>\n		<li>incrementLinesInput()：增加从文件、数据库、网络等资源读取到的行数</li>\n		<li>incrementLinesOutput()：增加写入到文件、数据库、网络等资源读的行数</li>\n		<li>incrementLinesUpdated():增加更新的行数</li>\n		<li>incrementLinesSkipped():增加跳过的数据行的行数</li>\n		<li>incrementLinesRejected():增加决绝的数据行的行数</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-java\">//addResultFile：把步骤用到的文件保留下来\nResultFile resultFile = new ResultFile(\n    ResultFile.FILE_TYPE_GENERAL,\n    fileObject,\n    getTransMeta().getName(),\n    getStepName()\n);\nresultFile.setComment(\"File was read by a Csv input step\");\naddResultFile(resultFile);</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、变量替换</strong></p>\n\n<ul>\n	<li>如果输入框需要支持变量，可使用environmentSubstitute()</li>\n</ul>\n\n<pre><code class=\"language-java\">String realFieldName = space.environmentSubstitute(fieldName);\nString value = environmentSubstitute(meta.getStringWithVariables());</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>8、Apache VFS</strong></p>\n\n<ul>\n	<li>Kettle 里所有操作文件的步骤，都使用&nbsp;Apache VFS 系统的方式操作文件</li>\n</ul>\n\n<pre><code class=\"language-java\">FileObject fileObject = KettleVFS.getFileObject(\n    \"zip:http://www.example.com/archive.zip!file.txt\"\n);</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,318729562703568900,'2019-08-24 18:18:27','2019-08-24 18:18:27');
INSERT INTO `article_info` VALUES (325306756397572096,'<h1>转换步骤插件：StepDataInterface、StepDialogInterface</h1>','sys','待编辑','<p><strong>1、StepDataInterface</strong></p>\n\n<pre><code class=\"language-java\">public class HelloworldStepData extends BaseStepData implements StepDataInterface {\n    public RowMetaInterface outputRowMeta;\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、StepDialogInterface</strong></p>\n\n<pre><code class=\"language-java\">public class HelloworldStepDialog extends BaseStepDialog implements StepDialogInterface {\n\n    private static Class&lt;?&gt; PKG = HelloworldStepMeta.class; // for i18n purposes, needed by Translator2!!\n\n    private HelloworldStepMeta input;\n\n    private TextVar wFieldname;\n\n    public HelloworldStepDialog(Shell parent, Object baseStepMeta,\n            TransMeta transMeta, String stepname) {\n        super(parent, (BaseStepMeta)baseStepMeta, transMeta, stepname);\n        input = (HelloworldStepMeta)baseStepMeta;\n    }\n    \n    public String open() {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n         props.setLook(shell);\n         setShellImage(shell, input);\n        \n        ModifyListener lsMod = new ModifyListener() \n        {\n            public void modifyText(ModifyEvent e) \n            {\n                input.setChanged();\n            }\n        };\n        changed = input.hasChanged();\n\n        FormLayout formLayout = new FormLayout ();\n        formLayout.marginWidth  = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(BaseMessages.getString(PKG, \"HelloworldDialog.Shell.Title\")); //$NON-NLS-1$\n        \n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        // Stepname line\n        wlStepname=new Label(shell, SWT.RIGHT);\n        wlStepname.setText(BaseMessages.getString(PKG, \"HelloworldDialog.Stepname.Label\")); //$NON-NLS-1$\n         props.setLook(wlStepname);\n        fdlStepname=new FormData();\n        fdlStepname.left = new FormAttachment(0, 0);\n        fdlStepname.right= new FormAttachment(middle, -margin);\n        fdlStepname.top  = new FormAttachment(0, margin);\n        wlStepname.setLayoutData(fdlStepname);\n        wStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wStepname.setText(stepname);\n         props.setLook(wStepname);\n        wStepname.addModifyListener(lsMod);\n        fdStepname=new FormData();\n        fdStepname.left = new FormAttachment(middle, 0);\n        fdStepname.top  = new FormAttachment(0, margin);\n        fdStepname.right= new FormAttachment(100, 0);\n        wStepname.setLayoutData(fdStepname);\n        Control lastControl = wStepname;\n        \n        // Fieldname line\n        Label wlFieldname = new Label(shell, SWT.RIGHT);\n        wlFieldname.setText(BaseMessages.getString(PKG, \"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n         props.setLook(wlFieldname);\n        FormData fdlFieldname = new FormData();\n        fdlFieldname.left = new FormAttachment(0, 0);\n        fdlFieldname.right= new FormAttachment(middle, -margin);\n        fdlFieldname.top  = new FormAttachment(lastControl, margin);\n        wlFieldname.setLayoutData(fdlFieldname);\n        wFieldname=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wFieldname);\n        wFieldname.addModifyListener(lsMod);\n        FormData fdFieldname = new FormData();\n        fdFieldname.left = new FormAttachment(middle, 0);\n        fdFieldname.top  = new FormAttachment(lastControl, margin);\n        fdFieldname.right= new FormAttachment(100, 0);\n        wFieldname.setLayoutData(fdFieldname);\n        lastControl = wFieldname;\n        \n        // Some buttons\n        wOK=new Button(shell, SWT.PUSH);\n        wOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n        wCancel=new Button(shell, SWT.PUSH);\n        wCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n\n        setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n        // Add listeners\n        lsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n        lsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n        \n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener    (SWT.Selection, lsOK    );\n        \n        lsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n        \n        wStepname.addSelectionListener( lsDef );\n        wFieldname.addSelectionListener( lsDef );\n        \n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(    new ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n        // Populate the data of the controls\n        //\n        getData();\n\n        // Set the shell size, based upon previous time...\n        setSize();\n        \n        input.setChanged(changed);\n    \n        shell.open();\n        while (!shell.isDisposed()){\n                if (!display.readAndDispatch()) display.sleep();\n        }\n        return stepname;\n    }\n\n    /**\n     * Copy information from the meta-data input to the dialog fields.\n     */ \n    public void getData(){\n        wStepname.selectAll();\n        wFieldname.setText(Const.NVL(input.getFieldName(), \"\"));\n    }\n    \n    private void cancel(){\n        stepname=null;\n        input.setChanged(changed);\n        dispose();\n    }\n    \n    private void ok(){\n        if (Const.isEmpty(wStepname.getText())) return;\n        stepname = wStepname.getText(); // return value        \n        input.setFieldName(wFieldname.getText());        \n        dispose();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n',0,318729562703568900,'2019-08-24 18:26:12','2019-08-24 18:26:12'),(325466139815354368,'<h1>Hive 概述</h1>','sys','待编辑','<p><strong>1、Hive</strong></p>\n\n<ul>\n	<li>是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能</li>\n	<li>用于解决海量结构化日志的数据统计</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Hive 本质</strong></p>\n\n<ul>\n	<li>将 HQL 转化成 MapReduce 程序\n	<ul>\n		<li>Hive 处理的数据存储在 HDFS</li>\n		<li>Hive 分析数据底层的实现是 MapReduce</li>\n		<li>执行程序运行在 Yarn 上</li>\n	</ul>\n	</li>\n</ul>\n\n<p><img alt=\"20190825-125916-125.png\" src=\"/furesky/images/201908/20190825-125916-125.png\" style=\"height:287px; margin-left:40px; margin-right:40px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Hive 的优点</strong></p>\n\n<ul>\n	<li>操作接口采用类SQL语法\n	<ul>\n		<li>提供快速开发的能力</li>\n		<li>简单、容易上手</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>避免了去写MapReduce\n	<ul>\n		<li>减少开发人员的学习成本</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Hive 的执行延迟比较高\n	<ul>\n		<li>因此Hive常用于数据分析，对实时性要求不高的场合</li>\n		<li>优势在于处理大数据，对于处理小数据没有优势</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Hive 支持用户自定义函数\n	<ul>\n		<li>用户可以根据自己的需求来实现自己的函数</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、Hive 的缺点</strong></p>\n\n<ul>\n	<li>Hive的HQL表达能力有限\n	<ul>\n		<li>迭代式算法无法表达</li>\n		<li>数据挖掘方面不擅长</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Hive的效率比较低\n	<ul>\n		<li>Hive自动生成的MapReduce作业，通常情况下不够智能化</li>\n		<li>Hive调优比较困难，粒度较粗</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,325466112309108736,'2019-08-25 05:12:40','2019-08-25 05:12:40'),(325471102738145280,'<h1>Hive 架构原理</h1>','sys','待编辑','<p><strong>1、原理</strong></p>\n\n<p><img alt=\"20190825-132607-132.png\" src=\"/furesky/images/201908/20190825-132607-132.png\" style=\"height:439px; margin-left:35px; margin-right:35px; width:500px\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2、架构</strong></p>\n\n<ul>\n	<li>用户接口：Client\n	<ul>\n		<li>CLI：命令行访问 Hive</li>\n		<li>JDBC：Java 访问 Hive</li>\n		<li>WEBUI：浏览器访问 Hive</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>元数据：Meta store\n	<ul>\n		<li>默认存储在自带的derby数据库中，推荐使用MySQL存储Meta Store</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>Hadoop\n	<ul>\n		<li>使用HDFS进行存储</li>\n		<li>使用MapReduce进行计算</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>驱动器：Driver\n	<ul>\n		<li>解析器：SQL Parser</li>\n		<li>编译器：Physical Plan</li>\n		<li>优化器：Query Optimizer</li>\n		<li>执行器：Execution</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、运行机制</strong></p>\n\n<ul>\n	<li>Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，</li>\n	<li>使用自己的Driver，结合元数据(MetaStore)，</li>\n	<li>将这些指令翻译成MapReduce，提交到Hadoop中执行，</li>\n	<li>最后，将执行返回的结果输出到用户交互接口。</li>\n</ul>\n\n<p><img alt=\"20190825-133915-133.png\" src=\"/furesky/images/201908/20190825-133915-133.png\" style=\"height:389px; margin-left:35px; margin-right:35px; width:800px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,325466112309108736,'2019-08-25 05:44:17','2019-08-25 05:44:17'),(325479056057081856,'<h1>Hive VS 数据库</h1>','sys','待编辑','<p><strong>1、总述</strong></p>\n\n<ul>\n	<li>Hive 和数据库除了拥有类似的查询语言外，再无类似之处</li>\n	<li>数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查询语言</strong></p>\n\n<ul>\n	<li>HQL：Hive Query Languag</li>\n	<li>Hive 采用了类似 SQL 的查询语言 HQL</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、数据存储位置</strong></p>\n\n<ul>\n	<li>Hive 的数据存储在 HDFS 中</li>\n	<li>数据库的数据存储在块设备或者本地文件系统中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、数据更新</strong></p>\n\n<ul>\n	<li>Hive中不建议对数据的改写\n	<ul>\n		<li>数据仓库的内容读多写少</li>\n		<li>所有的数据都是在加载的时候确定好的</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>数据库中的数据通常是需要经常进行修改的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、索引</strong></p>\n\n<ul>\n	<li>Hive 不可以建立索引\n	<ul>\n		<li>条件查询需要暴力扫描整个数据</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>数据库中可以建立索引\n	<ul>\n		<li>对于少量数据，条件查询能够高效率低延迟</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>6、执行</strong></p>\n\n<ul>\n	<li>Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的</li>\n	<li>数据库通常有自己的执行引擎</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>7、执行延迟</strong></p>\n\n<ul>\n	<li>Hive 执行有较高延迟，但对于大数据，其并行计算仍具有优势</li>\n	<li>数据库对于少量数据，执行效率高延迟低</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>8、可扩展性</strong></p>\n\n<ul>\n	<li>Hive 的可扩展性是和Hadoop的一致</li>\n	<li>数据库由于 ACID 语义的严格限制，扩展行非常有限</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>9、数据规模</strong></p>\n\n<ul>\n	<li>由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据</li>\n	<li>数据库可以支持的数据规模较小</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,325466112309108736,'2019-08-25 09:43:20','2019-08-25 09:43:20'),(325483648052404224,'<h1>安装</h1>','sys','待编辑','<p>待编辑</p>\n',0,325629634842238976,'2019-08-26 14:29:29','2019-08-26 14:29:29'),(325972504526757888,'<h1>资料</h1>','sys','待编辑','<p><strong>1．Hive官网地址</strong></p>\n\n<ul>\n	<li><a href=\"http://hive.apache.org/\" target=\"_blank\">http://hive.apache.org/</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2．文档查看地址</strong></p>\n\n<ul>\n	<li><a href=\"https://cwiki.apache.org/confluence/display/Hive/GettingStarted\" target=\"_blank\">https://cwiki.apache.org/confluence/display/Hive/GettingStarted</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3．下载地址</strong></p>\n\n<ul>\n	<li><a href=\"http://archive.apache.org/dist/hive/\" target=\"_blank\">http://archive.apache.org/dist/hive/</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4．github地址</strong></p>\n\n<ul>\n	<li><a href=\"https://github.com/apache/hive\" target=\"_blank\">https://github.com/apache/hive</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,325460365575757824,'2019-08-26 14:27:22','2019-08-26 14:27:22'),(325973693070876672,'<h1>基本数据类型</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、基本数据类型</strong></p>\n\n<ul>\n	<li>Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，</li>\n	<li>不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">Hive数据类型</th>\n			<th scope=\"col\">Java数据类型</th>\n			<th scope=\"col\">长度</th>\n			<th scope=\"col\">示例</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>TINYINT</td>\n			<td>byte</td>\n			<td>1byte有符号整数</td>\n			<td>20</td>\n		</tr>\n		<tr>\n			<td>SMALINT</td>\n			<td>short</td>\n			<td>2byte有符号整数</td>\n			<td>20</td>\n		</tr>\n		<tr>\n			<td>INT</td>\n			<td>int</td>\n			<td>4byte有符号整数</td>\n			<td>20</td>\n		</tr>\n		<tr>\n			<td>BIGINT</td>\n			<td>long</td>\n			<td>8byte有符号整数</td>\n			<td>20</td>\n		</tr>\n		<tr>\n			<td>FLOAT</td>\n			<td>float</td>\n			<td>单精度浮点数</td>\n			<td>3.14159</td>\n		</tr>\n		<tr>\n			<td>DOUBLE</td>\n			<td>double</td>\n			<td>双精度浮点数</td>\n			<td>3.14159</td>\n		</tr>\n		<tr>\n			<td>BOOLEAN</td>\n			<td>boolean</td>\n			<td>布尔类型，true或者false</td>\n			<td>TRUE&nbsp; FALSE</td>\n		</tr>\n		<tr>\n			<td>STRING</td>\n			<td>string</td>\n			<td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td>\n			<td>\"abcd\"</td>\n		</tr>\n		<tr>\n			<td>TIMESTAMP</td>\n			<td>&nbsp;</td>\n			<td>时间类型</td>\n			<td>&nbsp;</td>\n		</tr>\n		<tr>\n			<td>BINARY</td>\n			<td>&nbsp;</td>\n			<td>字节数组</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,325973663496839168,'2019-08-26 14:56:16','2019-08-26 14:56:16'),(325980405735661568,'<h1>集合数据类型</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、集合数据类型</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">数据类型</th>\n			<th scope=\"col\">名称</th>\n			<th scope=\"col\">访问元素</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>STRUCT</td>\n			<td>结构</td>\n			<td>“.字段名”</td>\n			<td>和 C 语言中的 struct 类似，与 Java 中的对象类似</td>\n		</tr>\n		<tr>\n			<td>MAP</td>\n			<td>键值</td>\n			<td>“[键]”</td>\n			<td>一组键值对元组集合</td>\n		</tr>\n		<tr>\n			<td>ARRAY&nbsp;</td>\n			<td>数组</td>\n			<td>“[下标]”</td>\n			<td>一组具有相同类型和名称的变量的集合</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、示例：源数据</strong></p>\n\n<pre><code class=\"language-json\"><span class=\"hljs-comment\">//源数据文件test.txt</span>\nsongsong,bingbing_lili,xiao song:<span class=\"hljs-number\">18</span>_xiaoxiao song:<span class=\"hljs-number\">19</span>,hui <span class=\"hljs-keyword\">long</span> guan_beijing\nyangyang,caicai_susu,xiao yang:<span class=\"hljs-number\">18</span>_xiaoxiao yang:<span class=\"hljs-number\">19</span>,chao yang_beijing\n\n\n<span class=\"hljs-comment\">//源数据结构(JSON)</span>\n{\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"songsong\"</span>,\n    <span class=\"hljs-string\">\"friends\"</span>: [                              <span class=\"hljs-comment\">//列表Array </span>\n        <span class=\"hljs-string\">\"bingbing\"</span>,\n        <span class=\"hljs-string\">\"lili\"</span>\n    ],\n    <span class=\"hljs-string\">\"children\"</span>: {                             <span class=\"hljs-comment\">//键值Map</span>\n        <span class=\"hljs-string\">\"xiao song\"</span>: <span class=\"hljs-number\">18</span>,\n        <span class=\"hljs-string\">\"xiaoxiao song\"</span>: <span class=\"hljs-number\">19</span>\n    },\n    <span class=\"hljs-string\">\"address\"</span>: {                              <span class=\"hljs-comment\">//结构Struct</span>\n        <span class=\"hljs-string\">\"street\"</span>: <span class=\"hljs-string\">\"hui long guan\"</span>,\n        <span class=\"hljs-string\">\"city\"</span>: <span class=\"hljs-string\">\"beijing\"</span>\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例：Hive 建表语句</strong></p>\n\n<pre><code class=\"language-sql\">create table test(\n    name <span class=\"hljs-built_in\">string</span>,\n    friends <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;</span>,\n    children <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">int</span>&gt;</span>,\n    address <span class=\"hljs-keyword\">struct</span>&lt;street:<span class=\"hljs-built_in\">string</span>, city:<span class=\"hljs-built_in\">string</span>&gt;\n)\nrow format delimited fields terminated by <span class=\"hljs-string\">\',\'</span>    -- 列分隔符\ncollection items terminated by <span class=\"hljs-string\">\'_\'</span>               -- 数据分割符号(MAP、STRUCT、ARRAY )\n<span class=\"hljs-built_in\">map</span> keys terminated by <span class=\"hljs-string\">\':\'</span>                       -- MAP中的 key 与 value 的分隔符\nlines terminated by <span class=\"hljs-string\">\'\\n\'</span>;                        -- 行分隔符</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、示例：导入数据</strong></p>\n\n<pre><code class=\"language-bash\">load data local inpath ‘/opt/module/datas/test.txt’<span class=\"hljs-keyword\">into</span> table test</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、示例：访问数据</strong></p>\n\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">select</span> friends[<span class=\"hljs-number\">1</span>],children[<span class=\"hljs-string\">\'xiao song\'</span>],address.city <span class=\"hljs-keyword\">from</span> test <span class=\"hljs-keyword\">where</span> name=<span class=\"hljs-string\">\"songsong\"</span>;</code></pre>\n\n<p>&nbsp;</p>\n',0,325973663496839168,'2019-08-28 15:46:33','2019-08-28 15:46:33'),(325987948084109312,'<h1>类型转化</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、自动向上转型</strong></p>\n\n<ul>\n	<li>与 Java 类似</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n	</thead>\n	<tbody>\n		<tr>\n			<td colspan=\"1\" rowspan=\"4\">规则</td>\n			<td>任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。</td>\n		</tr>\n		<tr>\n			<td>所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。</td>\n		</tr>\n		<tr>\n			<td>TINYINT、SMALLINT、INT都可以转换为FLOAT。</td>\n		</tr>\n		<tr>\n			<td>BOOLEAN类型不可以转换为任何其它的类型。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、强制类型转换</strong></p>\n\n<ul>\n	<li>CAST(\'1\' AS INT)\n	<ul>\n		<li>把字符串\'1\' 转换成整数1</li>\n	</ul>\n	</li>\n	<li>CAST(\'X\' AS INT)\n	<ul>\n		<li>如果转换失败，则返回NULL</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,325973663496839168,'2019-08-26 15:31:27','2019-08-26 15:31:27'),(326684206037770340,'<h1>数据库 - 操作</h1>','sys','待编辑','<p><strong>1、创建</strong></p>\n\n<pre><code class=\"language-sql\">-- 创建数据库，默认存储路径是/user/hive/warehouse/*.db\ncreate database db_hive;\n\n-- 先判断是否存在\ncreate database if not exists db_hive;\n\n-- 指定存储位置\ncreate database db_hive location \'/db_hive.db\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查询</strong></p>\n\n<pre><code class=\"language-sql\">-- 所有数据库\nshow databases;\n\n-- 特定数据库\nshow databases like \'db_hive*\';\n\n-- 数据库详情\ndesc database db_hive;\n\n-- 切换数据库\nuse db_hive;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、修改</strong></p>\n\n<ul>\n	<li>数据库的元数据信息是不可更改，自定义属性信息除外</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 设置数据库属性信息\nalter database db_hive set dbproperties(\'createtime\'=\'20190827\');\n\n-- 查看数据库详情（包括自定义属性信息）\ndesc database extended db_hive;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、删除</strong></p>\n\n<pre><code class=\"language-sql\">-- 删除空数据库\ndrop database db_hive;\n\n-- 先判断是否存在\ndrop database if exists db_hive;\n\n-- 如果数据库不为空，强制删除\ndrop database db_hive cascade;</code></pre>\n\n<p>&nbsp;</p>\n',0,326341992145264640,'2019-08-29 15:17:18','2019-08-29 15:17:18'),(326684206037770440,'<h1>数据表 - 操作</h1>','sys','待编辑','<p><strong>1、建表语法</strong></p>\n\n<pre><code class=\"language-sql\">REATE [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.] table_name \n[(col_name data_type [COMMENT col_comment], ...)] \n[COMMENT table_comment] \n[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] \n[CLUSTERED BY (col_name, col_name, ...)]\n[ROW FORMAT row_format] \n[STORED AS file_format] \n[LOCATION hdfs_path]\n\n\n//指定分隔符\nROW FORMAT DELIMITED \n[FIELDS TERMINATED BY char]             -- 字段间分隔符\n[COLLECTION ITEMS TERMINATED BY char]   -- 数据分割符号(MAP、STRUCT、ARRAY )\n[MAP KEYS TERMINATED BY char]           -- MAP中的 key 与 value 的分隔符\n[LINES TERMINATED BY char]              -- 行分隔符</code></pre>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">字段</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>\n			<p>EXTERNAL</p>\n			</td>\n			<td>\n			<p>创建外部表，需同时指定存储位置（LOCATION）</p>\n			</td>\n		</tr>\n		<tr>\n			<td>COMMENT</td>\n			<td>为表和列添加注释</td>\n		</tr>\n		<tr>\n			<td>PARTITIONED BY</td>\n			<td>创建分区</td>\n		</tr>\n		<tr>\n			<td>CLUSTERED BY</td>\n			<td>创建分桶</td>\n		</tr>\n		<tr>\n			<td>ROW FORMAT</td>\n			<td>指定分隔符</td>\n		</tr>\n		<tr>\n			<td>STORED AS</td>\n			<td>\n			<p>指定存储文件类型，SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）</p>\n			</td>\n		</tr>\n		<tr>\n			<td>LOCATION</td>\n			<td>指定表在HDFS上的存储位置。</td>\n		</tr>\n		<tr>\n			<td>LIKE</td>\n			<td>复制现有的表结构，但是不复制数据</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建表</strong></p>\n\n<pre><code class=\"language-sql\">-- 创建表\ncreate table test(\n    id int,\n    name string,\n    friends array&lt;string&gt;,\n    children map&lt;string, int&gt;,\n    address struct&lt;street:string, city:string&gt;\n)\nrow format delimited fields terminated by \',\'\ncollection items terminated by \'_\'\nmap keys terminated by \':\' \nlines terminated by \'\\n\'\nlocation \'/user/hive/warehouse/test\';\n\n-- 根据查询结果创建表（查询的结果会添加到新创建的表中）\ncreate table if not exists test1 as select id, name from test;\n\n-- 根据已经存在的表结构创建表\ncreate table if not exists test2 like test;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、修改表</strong></p>\n\n<pre><code class=\"language-sql\">-- 增加和替换列\nALTER TABLE tbl_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) \n\n-- 更新列\nALTER TABLE tbl_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment]\n[FIRST|AFTER col_name]\n\n\n-- 重命名表\nalter table old_dept rename to dept;\n\n-- 增加列\nalter table dept add columns(col_name string COMMENT col_comment);\n\n-- 更新列\nalter table dept change column deptdesc remarks string;\n\n-- 替换列\nalter table dept replace columns(deptno string, dname string, loc string);\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、修改表类型</strong></p>\n\n<pre><code class=\"language-sql\">-- 内部表 --&gt; 外部表\nalter table tbl_name set tblproperties(\'EXTERNAL\'=\'TRUE\');\n\n-- 外部表 --&gt; 内部表\nalter table tbl_name set tblproperties(\'EXTERNAL\'=\'FALSE\');</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、查询表</strong></p>\n\n<pre><code class=\"language-sql\">-- 查看所有表\nshow tables;\n\n-- 查看表信息\ndesc tbl_name;\n\n-- 查看表类型\ndesc formatted tbl_name;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、删除表</strong></p>\n\n<pre><code class=\"language-sql\">drop table tbl_name;</code></pre>\n\n<p><br>\n&nbsp;</p>\n',0,326341992145264640,'2019-08-29 15:17:27','2019-08-29 15:17:27'),(326978413624078336,'<h1>分区表 - 操作</h1>','sys','待编辑','<p><strong>1、<strong>定义分区</strong></strong></p>\n\n<pre><code class=\"language-sql\">create table dept(\n    deptno int, \n    dname string, \n    loc string\n)\npartitioned by (month string)\nrow format delimited fields terminated by \'\\t\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、增加分区</strong></p>\n\n<pre><code class=\"language-sql\">-- 创建单个分区\nalter table dept add partition(month=\'201908\') ;\n\n-- 创建多个分区\nalter table dept add partition(month=\'201909\') partition(month=\'201910\');\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、加载数据</strong></p>\n\n<pre><code class=\"language-sql\">load data local inpath \'/opt/module/datas/dept.txt\' into table default.dept partition(month=\'201908\');\n...</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、查询数据</strong></p>\n\n<pre><code class=\"language-sql\">-- 单分区查询\nselect * from dept where month=\'201908\';\n\n-- 多分区联合查询\nselect * from dept where month=\'201909\'\nunion\nselect * from dept where month=\'201910\';\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、查询分区数量</strong></p>\n\n<pre><code class=\"language-sql\">show partitions dept;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、删除分区</strong></p>\n\n<pre><code class=\"language-sql\">-- 删除单个分区\nalter table dept drop partition (month=\'201908\');\n\n-- 删除多个分区\nalter table dept drop partition (month=\'201909\'), partition (month=\'201910\');\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7、</strong><strong>多级分区</strong></p>\n\n<pre><code class=\"language-sql\">-- 创建二级分区表\ncreate table dept2(\n    deptno int,\n    dname string,\n    loc string\n)\npartitioned by (month string, day string)\nrow format delimited fields terminated by \'\\t\';\n\n-- 加载数据\nload data local inpath \'/opt/module/datas/dept.txt\' into table default.dept2 partition(month=\'201709\', day=\'13\');\n\n-- 查询数据\nselect * from dept2 where month=\'201709\' and day=\'13\';\n</code></pre>\n',0,326341992145264640,'2019-08-29 15:17:37','2019-08-29 15:17:37'),(326978413624078500,'<h1>内部表、外部表</h1>','sys','待编辑','<p><strong>1、内部表</strong></p>\n\n<ul>\n	<li>Hive 内部的表</li>\n	<li>删除内部表时，会同时删除表元数据和表数据</li>\n	<li>表数据存储在 hive.metastore.warehouse.dir（默认：/user/hive/warehouse）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、外部表</strong></p>\n\n<ul>\n	<li>Hive 外部的表</li>\n	<li>删除外部表时，仅删除表的元数据</li>\n	<li>因为表是外部表，所以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。</li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、内部表与外部表的区别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">&nbsp;</th>\n			<th scope=\"col\">内部表</th>\n			<th scope=\"col\">外部表</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>创建语句</td>\n			<td>create table</td>\n			<td>create external table</td>\n		</tr>\n		<tr>\n			<td>表类型</td>\n			<td>MANAGED_TABLE</td>\n			<td>EXTERNAL_TABLE</td>\n		</tr>\n		<tr>\n			<td>是否移动数据到 warehouse</td>\n			<td>是</td>\n			<td>否</td>\n		</tr>\n		<tr>\n			<td>源数据</td>\n			<td>本地磁盘数据或 HDFS 数据</td>\n			<td>HDFS中已经存在的数据</td>\n		</tr>\n		<tr>\n			<td>创建表和加载数据</td>\n			<td>分别独立完成</td>\n			<td>同时完成</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、应用场景</strong></p>\n\n<ul>\n	<li>内部表：\n	<ul>\n		<li>在做统计分析时候用到的中间表、结果表可以使用内部表，</li>\n		<li>因为这些数据不需要共享，使用内部表更为合适</li>\n	</ul>\n	</li>\n	<li>外部表：\n	<ul>\n		<li>比如某个公司的原始日志数据存放在一个目录中，多个部门对这些原始数据进行分析，</li>\n		<li>那么创建外部表是明智选择，这样原始数据不会被删除\n		<ul>\n		</ul>\n\n		<ul>\n		</ul>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,326341470822637500,'2019-08-29 14:05:54','2019-08-29 14:05:54'),(326978413624078510,'<h1>分区表、分桶表</h1>','sys','待编辑','<ul>\n</ul>\n\n<p><strong>1、分区表</strong></p>\n\n<ul>\n	<li>分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件</li>\n	<li>应用场景\n	<ul>\n		<li>将每个小时或每天的日志文件进行分区存储，</li>\n		<li>可以针对某个特定时间段做业务分析，而不必分析扫描所有数据；</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<div><strong>2、分桶表</strong></div>\n\n<div>\n<ul>\n	<li>分桶表是对数据进行哈希取值，然后放到不同文件中存储。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>3、区别</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<tbody>\n		<tr>\n			<th scope=\"row\">分区</th>\n			<td>针对的是数据的存储路径</td>\n			<td>一个文件夹下辖多个子文件</td>\n		</tr>\n		<tr>\n			<th scope=\"row\">分桶</th>\n			<td>针对的是数据文件</td>\n			<td>一个大文件分为多个小文件</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,326341470822637500,'2019-08-29 14:15:50','2019-08-29 14:15:50'),(327055238187753400,'<h1>分区表 - 关联数据</h1>','sys','待编辑','<p><strong>把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>1、方式一：上传数据后修复</strong></p>\n\n<pre><code class=\"language-sql\">-- 上传数据\ndfs -mkdir -p /user/hive/warehouse/dept2/month=201908/day=12;\ndfs -put /opt/module/datas/dept.txt &nbsp;/user/hive/warehouse/dept2/month=201908/day=12;\n\n-- 执行修复命令\nmsck repair table dept2;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、方式二：上传数据后添加分区</strong></p>\n\n<pre><code class=\"language-sql\">-- 上传数据\ndfs -mkdir -p&nbsp;/user/hive/warehouse/dept2/month=201908/day=11;\ndfs -put /opt/module/datas/dept.txt &nbsp;/user/hive/warehouse/dept2/month=201908/day=11;\n\n-- 添加分区\nalter table dept2 add partition(month=\'201908\',&nbsp;day=\'11\');</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、方式三：创建文件夹后load数据到分区</strong></p>\n\n<pre><code class=\"language-sql\">-- 创建目录\ndfs -mkdir -p&nbsp;/user/hive/warehouse/dept2/month=201908/day=10;\n\n-- 上传数据\nload data local inpath \'/opt/module/datas/dept.txt\' into table&nbsp;dept2 partition(month=\'201908\',day=\'10\');</code></pre>\n\n<div>&nbsp;</div>\n',0,326341992145264640,'2019-08-29 15:21:04','2019-08-29 15:21:04'),(327055238187753472,'<h1>分桶表 - 抽样查询</h1>','sys','待编辑','<p><strong>1、设置属性</strong></p>\n\n<pre><code class=\"language-sql\">-- 设置支持分桶\nset hive.enforce.bucketing=true;\n\n-- 设置分桶个数由用户指定\nset mapreduce.job.reduces=-1;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、定义分桶表</strong></p>\n\n<pre><code class=\"language-sql\">create table stu_buck(id int, name string)\nclustered by(id) into 4 buckets\nrow format delimited fields terminated by \'\\t\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、通过子查询，导入数据</strong></p>\n\n<pre><code class=\"language-sql\">-- 普通表\ncreate table stu(id int, name string)\nrow format delimited fields terminated by \'\\t\';\nload data local inpath \'/opt/module/datas/student.txt\' into table stu;\n\n-- 导入数据\ninsert into table stu_buck\nselect id, name from stu;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、分桶抽样查询</strong></p>\n\n<pre><code class=\"language-sql\">select * from stu_buck tablesample(bucket 1 out of 4 on id);</code></pre>\n\n<ul>\n	<li>语法\n	<ul>\n		<li>TABLESAMPLE(BUCKET x OUT OF y)</li>\n	</ul>\n	</li>\n	<li>说明\n	<ul>\n		<li>y 是桶数的因子或倍数，表示抽取整个表的 1/y 份</li>\n		<li>x 表示从哪个桶开始抽取</li>\n		<li>x 的值必须小于等于 y 的值</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,326341992145264640,'2019-08-29 15:18:02','2019-08-29 15:18:02'),(327073871811092480,'<h1>数据导入</h1>','sys','待编辑','<p><strong>1、load</strong></p>\n\n<pre><code class=\"language-sql\">-- 语法\nload data [local] inpath \'/.../xxx.xx\' [overwrite] into table tbl_name [partition (xxx=xxx,…)];\n\n-- local       是否从本地加载，默认从HDFS加载\n-- inpath      所加载数据的路径\n-- overwrite   是否覆盖，默认追加\n-- partition   上传到指定分区\n\n\n-- 示例\nload data inpath \'/user/atguigu/hive/student.txt\' overwrite into table default.student;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、insert</strong></p>\n\n<pre><code class=\"language-sql\">-- 基本插入数据\ninsert into table  student partition(month=\'201908\') values(1,\'wangwu\');\n\n-- 根据单表\ninsert overwrite table student partition(month=\'201909\')\nselect id, name from student where month=\'201908\';\n\n-- 根据多表\nfrom student\ninsert overwrite table student partition(month=\'201909\')\nselect id, name where month=\'201908\'\ninsert overwrite table student partition(month=\'201910\')\nselect id, name where month=\'201908\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、as select</strong></p>\n\n<pre><code class=\"language-sql\">-- 根据查询结果创建表\ncreate table if not exists student2\nas select id, name from student1;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、location</strong></p>\n\n<pre><code class=\"language-sql\">-- 上传数据到hdfs\ndfs -put /opt/module/datas/student.txt /user/hive/warehouse/student5;\n\n\n-- 创建表时指定在hdfs上的位置\ncreate table if not exists student5(\n    id int, name string\n)\nrow format delimited fields terminated by \'\\t\'\nlocation \'/user/hive/warehouse/student5\';\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、import</strong></p>\n\n<ul>\n	<li>注意：使用 export 导出的数据，才能用 import 导入</li>\n</ul>\n\n<pre><code class=\"language-sql\">import table student2 partition(month=\'201709\') from \'/user/hive/warehouse/export/student\';</code></pre>\n\n<p>&nbsp;</p>\n',0,326342117554954240,'2019-08-29 16:30:19','2019-08-29 16:30:19'),(327090766568267776,'<h1>数据导出</h1>','sys','待编辑','<p><strong>1、insert</strong></p>\n\n<pre><code class=\"language-sql\">-- 将查询的结果，导出到本地\ninsert overwrite local directory \'/opt/module/datas/export/student\' select * from student;\n\n-- 将查询的结果，导出到HDFS\ninsert overwrite directory \'/user/atguigu/student\' \nselect * from student;\n\n-- 将查询的结果，格式化导出\ninsert overwrite local directory \'/opt/module/datas/export/student1\'\nROW FORMAT DELIMITED FIELDS TERMINATED BY \'\\t\'\nselect * from student;\n\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Hadoop 导出</strong></p>\n\n<pre><code class=\"language-ini\">-- Hadoop命令导出到本地\ndfs -get /user/hive/warehouse/student/month=201709/000000_0 /opt/module/datas/export/student3.txt;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3、Hive Shell 导出</strong></p>\n\n<pre><code class=\"language-ini\">-- 语法：（hive -f/-e 执行语句或者脚本 &gt; file）\n$ bin/hive -e \'select * from default.student;\' &gt; /opt/module/datas/export/student4.txt;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、export&nbsp;</strong></p>\n\n<pre><code class=\"language-sql\">export table default.student to \'/user/hive/warehouse/export/student\';\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Sqoop 导出</strong></p>\n\n<ul>\n	<li>略</li>\n</ul>\n',0,326342117554954240,'2019-08-29 16:48:38','2019-08-29 16:48:38'),(327095806657863680,'<h1>清除数据</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、truncate</strong></p>\n\n<ul>\n	<li>注意：truncate 只能删除内部表，不能删除外部表中的数据</li>\n</ul>\n\n<pre><code class=\"language-sql\">truncate table student;\n</code></pre>\n\n<p>&nbsp;</p>\n',0,326342117554954240,'2019-08-29 16:50:29','2019-08-29 16:50:29'),(327775361462738944,'<h1>查询语法</h1>','sys','待编辑','<p><strong>1、资料</strong></p>\n\n<ul>\n	<li><a href=\"https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select\" target=\"_blank\">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查询语法</strong></p>\n\n<pre><code class=\"language-sql\">SELECT [ALL | DISTINCT] select_expr, select_expr, ...\nFROM table_reference\n[WHERE where_condition]\n[GROUP BY col_list]\n[ORDER BY col_list]\n[CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list]]\n[LIMIT number]\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-08-31 13:55:16','2019-08-31 13:55:16'),(327776969995100160,'<h1>基本查询</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、全表查询</strong></p>\n\n<pre><code class=\"language-sql\">select * from emp;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、查询特定列</strong></p>\n\n<pre><code class=\"language-sql\">select empno, ename from emp;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、算术运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">运算符</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>+、-、*、/、%</td>\n			<td>加、减、乘、除、取余</td>\n		</tr>\n		<tr>\n			<td>&amp;、|、^、~</td>\n			<td>按位取与、或、异或、反</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-sql\">select sal +1 from emp;</code></pre>\n\n<p><br>\n<strong>4、常用函数</strong></p>\n\n<pre><code class=\"language-sql\">-- 求总行数（count）\nselect count(*) cnt from emp;\n\n-- 求最大值（max）\nselect max(sal) max_sal from emp;\n\n-- 求最小值（min）\nselect min(sal) min_sal from emp;\n\n-- 求总和（sum）\nselect sum(sal) sum_sal from emp; \n\n-- 求平均值（avg）\nselect avg(sal) avg_sal from emp;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、Limit 语句</strong></p>\n\n<pre><code class=\"language-sql\">-- 限制返回的行数\nselect * from emp limit 5;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-08-31 14:06:38','2019-08-31 14:06:38'),(327779802270179328,'<h1>where 语句</h1>','sys','待编辑','<p><strong>1、比较运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">操作符</th>\n			<th scope=\"col\">支持的数据类型</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>=、&lt;、&lt;=、&gt;、=&gt;</td>\n			<td>基本数据类型</td>\n			<td>等于、小于、小于等于、大于、大于等于</td>\n		</tr>\n		<tr>\n			<td>&lt;&gt;、!=</td>\n			<td>基本数据类型</td>\n			<td>不等于</td>\n		</tr>\n		<tr>\n			<td>&lt;=&gt;</td>\n			<td>基本数据类型</td>\n			<td>操作数均为null时，返回 true。其他与 = 相同</td>\n		</tr>\n		<tr>\n			<td>A BETWEEN B AND C</td>\n			<td>基本数据类型</td>\n			<td>A 是否在 B 与 C 之间</td>\n		</tr>\n		<tr>\n			<td>IS NULL</td>\n			<td>所有数据类型</td>\n			<td>是否为null</td>\n		</tr>\n		<tr>\n			<td>IS NOT NULL</td>\n			<td>所有数据类型</td>\n			<td>是否不为null</td>\n		</tr>\n		<tr>\n			<td>IN(..., ...)</td>\n			<td>所有数据类型</td>\n			<td>在几个值之中</td>\n		</tr>\n		<tr>\n			<td>A LIKE B</td>\n			<td>STRING 类型</td>\n			<td>A 匹配 B</td>\n		</tr>\n		<tr>\n			<td>A RLIKE B, A REGEXP B</td>\n			<td>STRING 类型</td>\n			<td>A 匹配 B，正则匹配</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-sql\">-- 查询出薪水等于5000的所有员工\nselect * from emp where sal =5000;\n\n-- 查询工资在500到1000的员工信息\nselect * from emp where sal between 500 and 1000;\n\n-- 查询comm为空的所有员工信息\nselect * from emp where comm is null;\n\n-- 查询工资是1500或5000的员工信息\nselect * from emp where sal IN (1500, 5000);\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Like 和 RLike</strong></p>\n\n<ul>\n	<li>使用 LIKE 运算选择类似的值</li>\n	<li>代表任意个字符：%</li>\n	<li>代表一个字符：_</li>\n	<li>RLIKE 子句是 Hive 中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件。</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 查找以2开头薪水的员工信息\nhive (default)&gt; select * from emp where sal LIKE \'2%\';\n\n-- 查找第二个数值为2的薪水的员工信息\nhive (default)&gt; select * from emp where sal LIKE \'_2%\';\n\n-- 查找薪水中含有2的员工信息\nhive (default)&gt; select * from emp where sal RLIKE \'[2]\';</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、逻辑运算符</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">操作符</th>\n			<th scope=\"col\">说明</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td>AND</td>\n			<td>逻辑并</td>\n		</tr>\n		<tr>\n			<td>OR</td>\n			<td>逻辑或</td>\n		</tr>\n		<tr>\n			<td>NOT&nbsp;</td>\n			<td>逻辑否</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-sql\">-- 查询薪水大于1000，部门是30\nhive (default)&gt; select * from emp where sal&gt;1000 and deptno=30;\n\n-- 查询薪水大于1000，或者部门是30\nhive (default)&gt; select * from emp where sal&gt;1000 or deptno=30;\n\n-- 查询除了20部门和30部门以外的员工信息\nhive (default)&gt; select * from emp where deptno not IN(30, 20);</code></pre>\n\n<p><br>\n&nbsp;</p>\n',0,326342268075941888,'2019-08-31 14:31:28','2019-08-31 14:31:28'),(327786211833585664,'<h1>group by 语句</h1>','sys','待编辑','<p><strong>1、Group By 语句</strong></p>\n\n<ul>\n	<li>通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 计算emp表每个部门的平均工资\nselect t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno;\n\n-- 计算emp每个部门中每个岗位的最高薪水\nselect t.deptno, t.job, max(t.sal) max_sal from emp t group by&nbsp;t.deptno, t.job;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、Having 语句</strong></p>\n\n<ul>\n	<li>where 针对表中的列发挥作用，查询数据；having 针对查询结果中的列发挥作用，筛选数据。</li>\n	<li>where 后面不能写分组函数，而 having 后面可以使用分组函数。</li>\n	<li>having 只用于 group by 分组统计语句。</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 求每个部门的平均工资\nselect deptno, avg(sal) from emp group by deptno;\n\n-- 求每个部门的平均薪水大于2000的部门\nselect deptno, avg(sal) avg_sal from emp group by deptno having&nbsp;avg_sal &gt; 2000;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-08-31 16:02:57','2019-08-31 16:02:57'),(327794772282220544,'<h1>Join 语句</h1>','sys','待编辑','<p><strong>1、Join 语句</strong></p>\n\n<ul>\n	<li>Hive只支持等值连接，不支持非等值连接。</li>\n</ul>\n\n<pre><code class=\"language-sql\">select e.empno, e.ename, d.deptno, d.dname from emp e join dept d on e.deptno = d.deptno;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、内连接</strong></p>\n\n<ul>\n	<li>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</li>\n</ul>\n\n<pre><code class=\"language-sql\">select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno&nbsp;= d.deptno;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、左外连接</strong></p>\n\n<ul>\n	<li>JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。</li>\n</ul>\n\n<pre><code class=\"language-sql\">select e.empno, e.ename, d.deptno from emp e left join dept d on e.deptno&nbsp;= d.deptno;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、右外连接</strong></p>\n\n<ul>\n	<li>JOIN操作符右边表中符合WHERE子句的所有记录将会被返回。</li>\n</ul>\n\n<pre><code class=\"language-sql\">select e.empno, e.ename, d.deptno from emp e right join dept d on e.deptno&nbsp;= d.deptno;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、满外连接</strong></p>\n\n<ul>\n	<li>将会返回所有表中符合WHERE语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用NULL值替代。</li>\n</ul>\n\n<pre><code class=\"language-sql\">select e.empno, e.ename, d.deptno from emp e full join dept d on e.deptno&nbsp;= d.deptno;</code></pre>\n\n<p><br>\n<strong>6、多表连接</strong></p>\n\n<ul>\n	<li>注意：连接 n个表，至少需要n-1个连接条件</li>\n	<li>Hive 一般会对每对 JOIN 连接对象启动一个 MapReduce 任务\n	<ul>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-sql\">SELECT e.ename, d.deptno, l.loc_name\nFROM &nbsp; emp e&nbsp;\nJOIN &nbsp; dept d\nON &nbsp; &nbsp; d.deptno = e.deptno&nbsp;\nJOIN &nbsp; location l\nON &nbsp; &nbsp; d.loc = l.loc;\n\n-- 为什么不是表d和表l先进行连接操作呢？\n-- 因为Hive总是按照从左到右的顺序执行的。</code></pre>\n\n<p><br>\n<strong>7、笛卡尔积</strong></p>\n\n<ul>\n	<li>产生笛卡尔积的条件\n	<ul>\n		<li>省略连接条件</li>\n		<li>连接条件无效</li>\n		<li>所有表中的所有行互相连接</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-sql\">select empno, dname from emp, dept;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>8、连接谓词中不支持or</strong></p>\n\n<pre><code class=\"language-sql\">-- 这条语句会报错\nselect e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno or e.ename=d.ename;</code></pre>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-08-31 15:23:24','2019-08-31 15:23:24'),(327799149847945216,'<h1>排序语句</h1>','sys','待编辑','<p><strong>1、order by</strong></p>\n\n<ul>\n	<li>全局排序\n	<ul>\n		<li>只有一个Reducer</li>\n	</ul>\n	</li>\n	<li>升序\n	<ul>\n		<li>默认</li>\n		<li>ASC，ascend</li>\n	</ul>\n	</li>\n	<li>降序\n	<ul>\n		<li>DESC，descend</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 查询员工信息按工资升序排列\nselect * from emp order by sal;\n\n-- 查询员工信息按工资降序排列\nselect * from emp order by sal desc;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、按照别名排序</strong></p>\n\n<pre><code class=\"language-sql\">-- 按照员工薪水的2倍排序\nselect ename, sal*2 twosal from emp order by twosal;</code></pre>\n\n<p><br>\n<strong>3、多个列排序</strong></p>\n\n<pre><code class=\"language-sql\">-- 按照部门和工资升序排序\nselect ename, deptno, sal from emp order by deptno, sal ;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、sort by</strong></p>\n\n<ul>\n	<li>每个Reducer内部进行排序，对全局结果集来说不是排序。</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 设置reduce个数\nset mapreduce.job.reduces=3;\n\n-- 查看reduce个数\nset mapreduce.job.reduces;\n\n--将查询结果导入到文件中（按照部门编号降序排序）\ninsert overwrite local directory \'/opt/module/datas/sortby-result\'\nselect * from emp sort by deptno desc;\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、distribute by</strong></p>\n\n<ul>\n	<li>分区排序，类似 MR 中 partition，进行分区，结合 sort by 使用。</li>\n	<li>distribute by<strong>&nbsp;</strong>语句要写在 sort by 语句之前</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 先按照部门编号分区\nset mapreduce.job.reduces=3;\n\n-- 再按照员工编号降序排序。\ninsert overwrite local directory \'/opt/module/datas/distribute-result\' \nselect * from emp distribute by deptno sort by empno desc;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6、cluster by</strong></p>\n\n<ul>\n	<li>当distribute by和sorts by字段相同时，可以使用cluster by方式。</li>\n	<li>限制：只能是升序排序，</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 以下两种写法等价\nselect * from emp cluster by deptno;\nselect * from emp distribute by deptno sort by deptno;</code></pre>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-08-31 16:03:20','2019-08-31 16:03:20'),(327799207494459392,'<h1>条件语句</h1>','sys','待编辑','<p><strong>1、CASE WHEN</strong></p>\n\n<pre><code class=\"language-sql\">select \n    dept_id,\n    sum(case sex when \'男\' then 1 else 0 end) male_count,\n    sum(case sex when \'女\' then 1 else 0 end) female_count\nfrom emp_sex\ngroup by dept_id;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、if</strong></p>\n\n<pre><code>select \n    dept_id,\n    sum(if(sex=\'男\',1,0)) male_count,\n    sum(if(sex=\'女\',1,0)) female_count\nfrom emp_sex\ngroup by dept_id;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,326342268075941888,'2019-09-02 15:52:51','2019-09-02 15:52:51'),(327807910411018240,'<h1>时间函数、NVL()</h1>','sys','待编辑','<p><strong>1、NVL()</strong></p>\n\n<ul>\n	<li>给值为NULL的数据赋值</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 如果 name 为 NULL，则返回 defaultName 的值，否则返回 name 的值\nselect nvl(name,defaultName) from emp;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、时间函数</strong></p>\n\n<ul>\n	<li>date_format()</li>\n	<li>date_add()</li>\n	<li>date_sub()</li>\n	<li>datediff()</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 格式化时间\nselect date_format(\'2019-06-29\',\'yyyy-MM-dd\');\n\n-- 返回加上几天后的日期\nselect date_add(\'2019-06-29\',5);\nselect date_add(\'2019-06-29\',-5);\n\n-- 返回几天后的日期\nselect date_sub(\'2019-06-29\',5);\nselect date_sub(\'2019-06-29\',-5);\n\n-- 两个时间相差的天数\nselect datediff(\'2019-06-29\',\'2019-06-24\');\n</code></pre>\n\n<p>&nbsp;</p>\n',0,327807873220124672,'2019-09-05 13:08:43','2019-09-05 13:08:43'),(327807910411028240,'<h1>行列转换函数</h1>','sys','待编辑','<p><strong>1、行转列</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:400px\">\n	<tbody>\n		<tr>\n			<td>CONCAT()</td>\n			<td>拼接字符串</td>\n		</tr>\n		<tr>\n			<td>CONCAT_WS()</td>\n			<td>以分隔符拼接字符串</td>\n		</tr>\n		<tr>\n			<td>COLLECT_SET()</td>\n			<td>去重汇总，返回array类型字段</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-sql\">-- 源数据\n   name      constellation  blood_type\n   孙悟空    白羊座       	A\n   大海	     射手座       	A\n   宋宋	     白羊座       	B\n   猪八戒    白羊座       	A\n   凤姐	     射手座       	A\n\n-- 目标数据\n   射手座,A   大海|凤姐\n   白羊座,A   孙悟空|猪八戒\n   白羊座,B   宋宋\n\n\n-- HQL\nselect\n    t1.base,\n    concat_ws(\'|\', collect_set(t1.name)) name\nfrom (\n        select\n            name,\n            concat(constellation, \",\", blood_type) base\n        from\n            person_info\n    ) t1\ngroup by\n    t1.base;</code></pre>\n\n<p><br>\n<strong>2、列转行</strong></p>\n\n<ul>\n	<li>EXPLODE()\n	<ul>\n		<li>将hive一列中复杂的array或者map结构拆分成多行。</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>LATERAL VIEW\n	<ul>\n		<li>用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</li>\n		<li>解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。<br>\n		&nbsp;</li>\n	</ul>\n	</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 源数据\n	movie		category\n	疑犯追踪	悬疑,动作,科幻,剧情\n	战狼2		战争,动作,灾难\n\n-- 目标数据\n	疑犯追踪	悬疑\n	疑犯追踪	动作\n	疑犯追踪	科幻\n	疑犯追踪	剧情\n	战狼2		战争\n	战狼2		动作\n	战狼2		灾难\n\n-- HQL\nselect\n    movie,\n    category_name\nfrom \n    movie_info lateral view explode(category) table_tmp as category_name;\n</code></pre>\n\n<p><br>\n&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,327807873220124672,'2019-09-05 13:09:20','2019-09-05 13:09:20'),(329589865351782400,'<h1>窗口函数</h1>','sys','待编辑','<p><strong>1、示例数据</strong></p>\n\n<pre><code class=\"language-ini\">name,orderdate,cost\njack,2017-01-01,10\ntony,2017-01-02,15\njack,2017-02-03,23\ntony,2017-01-04,29\njack,2017-01-05,46\njack,2017-04-06,42\ntony,2017-01-07,50\njack,2017-01-08,55\nmart,2017-04-08,62\nmart,2017-04-09,68\nneil,2017-05-10,12\nmart,2017-04-11,75\nneil,2017-06-12,80\nmart,2017-04-13,94</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、OVER()</strong></p>\n\n<ul>\n	<li>开窗函数，指定分析函数工作的数据窗口大小</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 查询在 2017 年 4 月份购买过的顾客及总人数\nselect \n    name,\n    count(*) over ()\nfrom business\nwhere substring(orderdate,1,7) = \'2017-04\'\ngroup by name;\n\n-- 查询顾客的购买明细及月购买总额\nselect \n    name,orderdate,cost,\n    sum(cost) over(partition by month(orderdate)) \nfrom business;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、属性</strong></p>\n\n<ul>\n	<li>当前行：current row</li>\n	<li>往前 n 行数据：n preceding</li>\n	<li>往后 n 行数据：n following</li>\n	<li>表示从前面的起点：unbounded preceding</li>\n	<li>表示到后面的终点：unbounded following</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 上述的场景,要将 cost 按照日期进行累加\nselect \n    name,orderdate,cost,\n    sum(cost) over() as sample1,                                        --所有行相加\n    sum(cost) over(partition by name) as sample2,                       -- 按 name 分组，组内数据相加\n    sum(cost) over(partition by name order by orderdate) as sample3,    -- 按 name 分组，组内数据累加\n    sum(cost) over(partition by name order by orderdate \n        rows between UNBOUNDED PRECEDING and current row ) as sample4,  --由起点到当前行的聚合\n    sum(cost) over(partition by name order by orderdate \n        rows between 1 PRECEDING and current row) as sample5,           --当前行和前面一行做聚合\n    sum(cost) over(partition by name order by orderdate \n        rows between 1 PRECEDING AND 1 FOLLOWING ) as sample6,          --当前行和前边一行及后面一行\n    sum(cost) over(partition by name order by orderdate \n        rows between current row and UNBOUNDED FOLLOWING ) as sample7   --当前行及后面所有行\nfrom business;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4、函数</strong></p>\n\n<ul>\n	<li>往前第 n 行数据：lag(col,n)</li>\n	<li>往后第 n 行数据：lead(col,n)</li>\n	<li>行所属的组的编号：ntile(n)</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 查看顾客上次的购买时间\nselect \n    name,orderdate,cost,\n    lag(orderdate,1,\'1900-01-01\') over(partition by name order by orderdate ) as time1,\n    lag(orderdate,2) over (partition by name order by orderdate) as time2\nfrom business;\n\n-- 查询前 20%时间的订单信息\nselect * from (\n    select \n        name,orderdate,cost, \n        ntile(5) over(order by orderdate) sorted\n    from business\n) t\nwhere sorted = 1;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、排序</strong></p>\n\n<ul>\n	<li>rank()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;排序相同时会重复，总数不会变</li>\n	<li>dense_rank()：&nbsp; &nbsp; 排序相同时会重复，总数会减少</li>\n	<li>row_number()：&nbsp; 会根据顺序计算</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 准备数据\nname,subject,score\n张三,语文,87\n张三,数学,95\n张三,英语,68\n大海,语文,94\n大海,数学,56\n大海,英语,84\n宋宋,语文,64\n宋宋,数学,86\n宋宋,英语,84\n婷婷,语文,65\n婷婷,数学,85\n婷婷,英语,78\n\n-- HQL\nselect \n    name,subject,score,\n    rank() over(partition by subject order by score desc) rp,\n    dense_rank() over(partition by subject order by score desc) drp,\n    row_number() over(partition by subject order by score desc) rmp\nfrom score;\n\n-- 结果数据\nname,subject,score,rp,drp,rmp\n张三,数学,95,1,1,1\n宋宋,数学,86,2,2,2\n婷婷,数学,85,3,3,3\n大海,数学,56,4,4,4\n宋宋,英语,84,1,1,1\n大海,英语,84,1,1,2\n婷婷,英语,78,3,2,3\n张三,英语,68,4,3,4\n大海,语文,94,1,1,1\n张三,语文,87,2,2,2\n婷婷,语文,65,3,3,3\n宋宋,语文,64,4,4,4</code></pre>\n\n<p>&nbsp;</p>\n',0,327807873220124672,'2019-09-05 14:33:07','2019-09-05 14:33:07'),(329602909297483776,'<h1>系统内置函数</h1>','sys','待编辑','<p><strong>1、系统函数</strong></p>\n\n<pre><code class=\"language-sql\">-- 查看全部\nshow functions;\n\n-- 查看详情\ndesc function upper;\n\n-- 查看扩展详情\ndesc function extended upper;\n\n</code></pre>\n\n<p>&nbsp;</p>\n',0,329616486255337472,'2019-09-05 15:45:36','2019-09-05 15:45:36'),(329604051033169920,'<h1>自定义函数</h1>','sys','待编辑','<p>&nbsp;</p>\n\n<p><strong>1、文档资料</strong></p>\n\n<ul>\n	<li><a href=\"https://cwiki.apache.org/confluence/display/Hive/HivePlugins\" target=\"_blank\">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、自定义函数分类</strong></p>\n\n<ul>\n	<li>UDF\n	<ul>\n		<li>User-Defined-Function</li>\n		<li>一进一出</li>\n		<li>传入一行数据，得到一行结果数据，以下类似</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>UDAF\n	<ul>\n		<li>User-Defined Aggregation Function</li>\n		<li>聚集函数，多进一出</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>UDTF\n	<ul>\n		<li>User-Defined Table-Generating Functions</li>\n		<li>一进多出</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、编程过程</strong></p>\n\n<ul>\n	<li>编写自定义函数\n	<ul>\n		<li>继承特定的类</li>\n		<li>实现特定的方法</li>\n		<li>打包jar</li>\n	</ul>\n	</li>\n</ul>\n\n<ul>\n	<li>hive命令行中，创建函数：</li>\n</ul>\n\n<pre><code class=\"language-sql\">-- 添加jar\nadd jar linux_jar_path;\n\n-- 创建函数\ncreate [temporary] function [dbname.]function_name AS class_name;\n\n-- 删除函数\nDrop [temporary] function [if exists] [dbname.]function_name;</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,329616486255337472,'2019-09-05 16:00:59','2019-09-05 16:00:59'),(329618748184764416,'<h1>自定义 UDF 函数</h1>','sys','待编辑','<p><strong>1、创建工程，导入依赖</strong></p>\n\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;\n    &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;\n    &lt;version&gt;1.2.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、创建自定义函数类</strong></p>\n\n<pre><code class=\"language-java\">package com.test.hive.Lower\nimport org.apache.hadoop.hive.ql.exec.UDF;\n\npublic class Lower extends UDF {\n    public String evaluate (String s) {\n        if (s == null) {\n            return null;\n        }\n        return s.toLowerCase();\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、打包上传到服务器</strong></p>\n\n<ul>\n	<li>例：/opt/module/datas/udf.jar</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、添加jar</strong></p>\n\n<pre><code class=\"language-sql\">add jar /opt/module/datas/udf.jar;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>5、创建自定义函数</strong></p>\n\n<pre><code class=\"language-sql\">create temporary function mylower as \"com.test.hive.Lower\";</code></pre>\n\n<p><br>\n<strong>6．使用自定义函数</strong></p>\n\n<pre><code class=\"language-sql\">select ename, mylower(ename) lowername from emp;</code></pre>\n\n<p>&nbsp;</p>\n',0,329616486255337472,'2019-09-05 16:10:17','2019-09-05 16:10:17'),(329627620479901696,'<h1>自定义 UDTF 函数</h1>','sys','待编辑','<p><strong>1、函数类</strong></p>\n\n<pre><code class=\"language-java\">package com.test.udtf;\nimport org.apache.hadoop.hive.ql.exec.UDFArgumentException;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;\nimport org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\nimport org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\nimport org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\nimport org.apache.hadoop.hive.serde2.objectinspector.primitive.Primitive ObjectInspectorFactory;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MyUDTF extends GenericUDTF {\n    private ArrayList&lt;String&gt; outList = new ArrayList&lt;&gt;();\n	\n    @Override\n    public StructObjectInspector initialize(StructObjectInspector argOIs) throws UDFArgumentException {\n        //1.定义输出数据的列名和类型\n        List&lt;String&gt; fieldNames = new ArrayList&lt;&gt;();\n        List&lt;ObjectInspector&gt; fieldOIs = new ArrayList&lt;&gt;();\n		\n        //2.添加输出数据的列名和类型\n        fieldNames.add(\"lineToWord\");\n        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);\n        return ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);\n    }\n\n    @Override\n    public void process(Object[] args) throws HiveException {\n        //1.获取原始数据\n        String arg = args[0].toString();\n		\n        //2.获取数据传入的第二个参数， 此处为分隔符\n        String splitKey = args[1].toString();\n		\n        //3.将原始数据按照传入的分隔符进行切分\n        String[] fields = arg.split(splitKey);\n		\n        //4.遍历切分后的结果，并写出\n        for (String field : fields) {\n		\n            //集合为复用的，首先清空集合\n            outList.clear();\n			\n            //将每一个单词添加至集合\n            outList.add(field);\n			\n            //将集合内容写出\n            forward(outList);\n        }\n    }\n	\n    @Override\n    public void close() throws HiveException {\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>2、其他</strong></p>\n\n<ul>\n	<li>参照“自定义 UDF 函数”</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,329616486255337472,'2019-09-05 16:38:07','2019-09-05 16:38:07'),(330301389611507712,'<h1>XPath</h1>','sys','待编辑','<p><strong>1、XPath</strong></p>\n\n<ul>\n	<li>XML 路径语言</li>\n	<li>是一种用来确定 XML 文档中某部分位置的语言</li>\n	<li>基于XML的树状结构，提供在数据结构树中找寻节点的能力</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、xml 示例</strong></p>\n\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n\n&lt;bookstore&gt;\n\n&lt;book&gt;\n  &lt;title lang=\"eng\"&gt;Harry Potter&lt;/title&gt;\n  &lt;price&gt;29.99&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book&gt;\n  &lt;title lang=\"eng\"&gt;Learning XML&lt;/title&gt;\n  &lt;price&gt;39.95&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;/bookstore&gt;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>3、选取节点</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">表达式</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">nodeName</td>\n			<td>选取此节点的所有子节点。</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">/</td>\n			<td>根节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">//</td>\n			<td>当前节点下，所有匹配的子节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">.</td>\n			<td>当前节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">..</td>\n			<td>取父节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">@</td>\n			<td>选取属性。</td>\n		</tr>\n	</thead>\n</table>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">路径表达式</th>\n			<th scope=\"col\">结果</th>\n		</tr>\n		<tr>\n			<td>bookstore</td>\n			<td>选取 bookstore 元素的所有子节点。</td>\n		</tr>\n		<tr>\n			<td>/bookstore</td>\n			<td>选取根元素 bookstore。</td>\n		</tr>\n		<tr>\n			<td>bookstore/book</td>\n			<td>选取属于 bookstore 的子元素的所有 book 元素。</td>\n		</tr>\n		<tr>\n			<td>//book</td>\n			<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>\n		</tr>\n		<tr>\n			<td>bookstore//book</td>\n			<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>\n		</tr>\n		<tr>\n			<td>//@lang</td>\n			<td>选取名为 lang 的所有属性。</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>4、谓语</strong></p>\n\n<ul>\n	<li>语用来查找某个特定的节点或者包含某个指定的值的节点。</li>\n	<li>谓语被嵌在方括号中。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th>路径表达式</th>\n			<th>结果</th>\n		</tr>\n		<tr>\n			<td>/bookstore/book[1]</td>\n			<td>选取属于 bookstore 子元素的第一个 book 元素。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book[last()]</td>\n			<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book[last()-1]</td>\n			<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book[position()&lt;3]</td>\n			<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>\n		</tr>\n		<tr>\n			<td>//title[@lang]</td>\n			<td>选取所有拥有名为 lang 的属性的 title 元素。</td>\n		</tr>\n		<tr>\n			<td>//title[@lang=\'eng\']</td>\n			<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book[price&gt;35.00]</td>\n			<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book[price&gt;35.00]/title</td>\n			<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>5、选取未知节点</strong></p>\n\n<ul>\n	<li>XPath 通配符可用来选取未知的 XML 元素。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th>路径表达式</th>\n			<th>结果</th>\n		</tr>\n		<tr>\n			<td>/bookstore/*</td>\n			<td>选取 bookstore 元素的所有子元素。</td>\n		</tr>\n		<tr>\n			<td>//*</td>\n			<td>选取文档中的所有元素。</td>\n		</tr>\n		<tr>\n			<td>//title[@*]</td>\n			<td>选取所有带有属性的 title 元素。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>6、选取若干路径</strong></p>\n\n<ul>\n	<li>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<th>路径表达式</th>\n			<th>结果</th>\n		</tr>\n		<tr>\n			<td>//book/title | //book/price</td>\n			<td>选取 book 元素的所有 title 和 price 元素。</td>\n		</tr>\n		<tr>\n			<td>//title | //price</td>\n			<td>选取文档中的所有 title 和 price 元素。</td>\n		</tr>\n		<tr>\n			<td>/bookstore/book/title | //price</td>\n			<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>\n		</tr>\n	</tbody>\n</table>\n\n<p><br>\n&nbsp;</p>\n',0,330298965706448896,'2019-09-07 14:03:58','2019-09-07 14:03:58'),(330303777579769856,'<h1>JSONPath</h1>','sys','待编辑','<p><strong>1、定义</strong></p>\n\n<ul>\n	<li>类似 XPath&nbsp;</li>\n	<li>用于路径检索或设置Json</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、语法</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px\">\n	<thead>\n		<tr>\n			<th scope=\"col\" style=\"text-align:center\">表达式</th>\n			<th scope=\"col\">描述</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">$</td>\n			<td>根节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">@</td>\n			<td>当前节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">*</td>\n			<td>通配符</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">..</td>\n			<td>递归搜索</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">.&lt;name&gt;</td>\n			<td>一个子节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">[&lt;name&gt;,...]</td>\n			<td>多个子节点</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">[&lt;number&gt;,...]</td>\n			<td>多个数组下标</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">[start:end]</td>\n			<td>数组片段，范围为[start,end)</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center\">[?(&lt;expression&gt;)]</td>\n			<td>过滤器表达式</td>\n		</tr>\n	</thead>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>3、示例</strong></p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<thead>\n		<tr>\n			<th scope=\"col\">JSONPath</th>\n			<th scope=\"col\">结果</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td><code>$.store.book[*].author</code></td>\n			<td>商店里所有书籍的作者</td>\n		</tr>\n		<tr>\n			<td><code>$..author</code></td>\n			<td>所有作者</td>\n		</tr>\n		<tr>\n			<td><code>$.store.*</code></td>\n			<td>商店里的所有东西，都是一些书和一辆红色的自行车。</td>\n		</tr>\n		<tr>\n			<td><code>$.store..price</code></td>\n			<td>商店里一切的价格。</td>\n		</tr>\n		<tr>\n			<td><code>$..book[2]</code></td>\n			<td>第三本书</td>\n		</tr>\n		<tr>\n			<td><code>$..book[(@.length-1)]</code><br>\n			<code>$..book[-1:]</code></td>\n			<td>最后一本书。</td>\n		</tr>\n		<tr>\n			<td><code>$..book[0,1]</code><br>\n			<code>$..book[:2]</code></td>\n			<td>前两本书</td>\n		</tr>\n		<tr>\n			<td><code>$..book[?(@.isbn)]</code></td>\n			<td>使用isbn number过滤所有书籍</td>\n		</tr>\n		<tr>\n			<td><code>$..book[?(@.price&lt;10)]</code></td>\n			<td>过滤所有便宜10以上的书籍</td>\n		</tr>\n		<tr>\n			<td><code>$..*</code></td>\n			<td>XML文档中的所有元素。JSON结构的所有成员。</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre><code class=\"language-json\">{ \"store\": {\n    \"book\": [ \n      { \"category\": \"reference\",\n        \"author\": \"Nigel Rees\",\n        \"title\": \"Sayings of the Century\",\n        \"price\": 8.95\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"Evelyn Waugh\",\n        \"title\": \"Sword of Honour\",\n        \"price\": 12.99\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"Herman Melville\",\n        \"title\": \"Moby Dick\",\n        \"isbn\": \"0-553-21311-3\",\n        \"price\": 8.99\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"J. R. R. Tolkien\",\n        \"title\": \"The Lord of the Rings\",\n        \"isbn\": \"0-395-19395-8\",\n        \"price\": 22.99\n      }\n    ],\n    \"bicycle\": {\n      \"color\": \"red\",\n      \"price\": 19.95\n    }\n  }\n}</code></pre>\n',0,330298965706448896,'2019-09-07 14:21:15','2019-09-07 14:21:15'),(334323643781521408,'<h1>大数据概述</h1>','sys','待编辑','<p><strong>1、大数据（big data）</strong></p>\n\n<ul>\n	<li>指<span style=\"color:#d35400\">无法在一定时间范围</span>内用常规软件工具进行捕捉、管理和处理的数据集合</li>\n	<li>是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的<span style=\"color:#d35400\">海量、高增长率和多样化的信息资产</span>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、特点</strong></p>\n\n<ul>\n	<li>大量：Volume</li>\n	<li>高速：Velocity</li>\n	<li>多样：Variety</li>\n	<li>低价值密度：Value</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、应用场景</strong></p>\n\n<ul>\n	<li>主要解决，海量数据的<strong><span style=\"color:#d35400\">存储</span></strong>和海量数据的<strong><span style=\"color:#d35400\">分析计算</span></strong>问题。</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:900px\">\n	<tbody>\n		<tr>\n			<td>物流仓储</td>\n			<td>大数据分析系统助力商家精细化运营、提升销量、节约成本。</td>\n		</tr>\n		<tr>\n			<td>零售</td>\n			<td>分析用户消费习惯，为用户购买商品提供方便，从而提升商品销量。</td>\n		</tr>\n		<tr>\n			<td>旅游</td>\n			<td>深度结合大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。</td>\n		</tr>\n		<tr>\n			<td>商品广告推荐</td>\n			<td>给用户推荐可能喜欢的商品</td>\n		</tr>\n		<tr>\n			<td>保险</td>\n			<td>海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。</td>\n		</tr>\n		<tr>\n			<td>金融</td>\n			<td>多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。</td>\n		</tr>\n		<tr>\n			<td>房产</td>\n			<td>大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。</td>\n		</tr>\n		<tr>\n			<td>人工智能</td>\n			<td>&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>&nbsp;</p>\n',0,334323611258888192,'2019-09-18 15:53:51','2019-09-18 15:53:51'),(334329868283846656,'<h1>大数据部门</h1>','sys','待编辑','<p><strong>1、业务流程</strong></p>\n\n<ul>\n	<li>产品人员提需求（统计总用户数、日活跃用户数、回流用户数等）</li>\n	<li>数据部门搭建数据平台、分析数据指标</li>\n	<li>数据可视化（报表展示、邮件发送、大屏幕展示等）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、组织结构</strong></p>\n\n<p><img alt=\"20190919-000213-213.png\" src=\"/furesky/images/201909/20190919-000213-213.png\" style=\"height:448px; width:900px\"></p>\n\n<p>&nbsp;</p>\n',0,334323611258888192,'2019-09-18 16:03:52','2019-09-18 16:03:52'),(349160469906104320,'<h1>软件结构</h1>','sys','待编辑','<p><strong>1、C/S</strong></p>\n\n<ul>\n	<li>Client/Server，即客户机/服务器架构</li>\n	<li>例如：QQ、office</li>\n	<li>特点：\n	<ul>\n		<li>使用软件前，需先安装客户端</li>\n		<li>软件更新时，客户端需要更新</li>\n		<li>不能跨平台使用</li>\n		<li>客户端和服务器通信采用自有协议，相对来说较安全</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、B/S</strong></p>\n\n<ul>\n	<li>Browser/Server，即浏览器/服务器架构</li>\n	<li>例如：京东、淘宝、百度</li>\n	<li>特点：\n	<ul>\n		<li>本质上也是C/S，只不过B/S软件使用浏览器作为客户端</li>\n		<li>软件不需要安装，可使用浏览器直接访问</li>\n		<li>软件更新时，客户端不需要更新</li>\n		<li>可以跨平台使用</li>\n		<li>客户端和服务器之间通信采用的是HTTP协议，相对来说不安全</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n',0,349159910239150080,'2019-10-29 14:30:13','2019-10-29 14:30:13'),(349160489766133760,'<h1>网页结构</h1>','sys','待编辑','<p><strong>1、网页结构</strong></p>\n\n<ul>\n	<li>结构\n	<ul>\n		<li>HTML 用于描述页面的结构</li>\n	</ul>\n	</li>\n	<li>表现\n	<ul>\n		<li>CSS 用于控制页面中元素的样式</li>\n	</ul>\n	</li>\n	<li>行为\n	<ul>\n		<li>JavaScript 用于响应用户操作</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"20191101-223211-211.png\" src=\"/furesky/images/201911/20191101-223211-211.png\" style=\"height:274px; width:600px\"></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,349159910239150080,'2019-10-29 14:38:06','2019-10-29 14:38:06'),(349190457518759936,'<h1>进制</h1>','sys','待编辑','<p><strong>1、进制</strong></p>\n\n<ul>\n	<li>几进制就是满几进一</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、二进制</strong></p>\n\n<ul>\n	<li>0、1</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>3、八进制</strong></p>\n\n<ul>\n	<li>0、1、2、3、4、5、6、7、8</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>4、十进制</strong></p>\n\n<ul>\n	<li>0、1、2、3、4、5、6、7、8、9</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>5、十六进制</strong></p>\n\n<ul>\n	<li>0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f</li>\n</ul>\n\n<p>&nbsp;</p>\n',0,349159910239150080,'2019-10-29 16:08:45','2019-10-29 16:08:45'),(349191423676686336,'<h1>编码</h1>','sys','待编辑','<p><strong>1、编码、解码</strong></p>\n\n<ul>\n	<li>编码：依据一定的规则，将字符转换为二进制编码的过程</li>\n	<li>解密：依据一定的规则，将二进制编码转换为字符的过程</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>2、字符集</strong></p>\n\n<ul>\n	<li>编码和解码所采用的规则，我们称为字符集</li>\n	<li>常用字符集\n	<ul>\n		<li>美国：ASCII</li>\n		<li>欧盟：ISO-8859-1</li>\n		<li>中国：GBK、GB2312（默认）</li>\n		<li>全球：UTF-8</li>\n	</ul>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n',0,349159910239150080,'2019-10-29 16:13:24','2019-10-29 16:13:24');
/*!40000 ALTER TABLE `article_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `catalog_info`
--

DROP TABLE IF EXISTS `catalog_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `catalog_info` (
  `catalog_id` bigint(20) NOT NULL,
  `catalog_name` varchar(64) NOT NULL,
  `parent_id` bigint(20) NOT NULL,
  `rank` varchar(16) NOT NULL,
  `class_name` varchar(32) NOT NULL,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`catalog_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `catalog_info`
--

LOCK TABLES `catalog_info` WRITE;
/*!40000 ALTER TABLE `catalog_info` DISABLE KEYS */;
INSERT INTO `catalog_info` VALUES (283963385795473408,'JavaSE',0,'1','JavaSE','2019-08-10 04:12:58'),(283963875107172352,'基础语法',283963385795473408,'101','JavaSE','2019-08-10 04:12:58'),(284556803206705152,'Spring',0,'1','Spring','2019-08-10 04:12:58'),(284563567113302016,'MyBatis',0,'1','MyBatis','2019-08-10 04:12:58'),(284570045819809792,'概述',284563567113302016,'11','MyBatis','2019-08-10 04:12:58'),(284571578275885056,'XML配置',284563567113302016,'13','MyBatis','2019-08-10 04:12:58'),(284571670672207872,'XML映射文件',284563567113302016,'14','MyBatis','2019-08-10 04:12:58'),(284571884682375168,'动态SQL',284563567113302016,'15','MyBatis','2019-08-10 04:12:58'),(285067054821568512,'概述',284556803206705152,'11','Spring','2019-08-10 04:12:58'),(285201811140145152,'IoC',284556803206705152,'12','Spring','2019-08-10 04:12:58'),(285260926591856640,'依赖注入',284556803206705152,'13','Spring','2019-08-10 04:12:58'),(285291594407374848,'注解注入',285260926591856640,'131','Spring','2019-08-10 04:12:58'),(285306178895769600,'SpEL',284556803206705152,'14','Spring','2019-08-10 04:12:58'),(285314020126126080,'AOP',284556803206705152,'15','Spring','2019-08-10 04:12:58'),(285411895787024384,'事务管理',284556803206705152,'16','Spring','2019-08-10 04:12:58'),(285596120477757440,'SpringMVC',0,'1','SpringMVC','2019-08-10 04:12:58'),(285703542961762304,'概述',285596120477757440,'11','SpringMVC','2019-08-10 04:12:58'),(285955163037790208,'配置文件',285596120477757440,'12','SpringMVC','2019-08-10 04:12:58'),(285974274438492160,'请求与响应',285596120477757440,'13','SpringMVC','2019-08-10 04:12:58'),(286059549709725696,'Request',285974274438492160,'131','SpringMVC','2019-08-10 04:12:58'),(286059589295566848,'Response',285974274438492160,'132','SpringMVC','2019-08-10 04:12:58'),(286428845560459264,'Spring Boot',0,'1','Spring Boot','2019-08-10 04:12:58'),(286568455259189248,'概述',286428845560459264,'11','Spring Boot','2019-08-10 04:12:58'),(286799487287848960,'基本配置',286428845560459264,'12','Spring Boot','2019-08-10 04:12:58'),(286823679957823488,'Spring Boot 功能',286428845560459264,'13','Spring Boot','2019-08-10 04:12:58'),(286857540888588288,'web 开发',286823679957823488,'131','Spring Boot','2019-08-10 04:12:58'),(287200745656053760,'MySQL',0,'1','MySQL','2019-08-10 04:12:58'),(287200950493278208,'NoSQL',0,'1','NoSQL','2019-08-10 04:12:58'),(287212421000359936,'概述',287200745656053760,'11','MySQL','2019-08-10 04:12:58'),(287456761731772416,'基本概念',287200745656053760,'12','MySQL','2019-08-10 04:12:58'),(287456761731772600,'SQL',287200745656053760,'13','MySQL','2019-08-10 04:12:58'),(287457461102604288,'SQL初阶',287456761731772600,'131','MySQL','2019-08-10 04:12:58'),(287512265581555712,'SQL进阶',287456761731772600,'132','MySQL','2019-08-10 04:12:58'),(287512265581555714,'高级',287200745656053760,'14','MySQL','2019-08-10 04:12:58'),(287512265581555715,'SQL语言',287456761731772600,'133','MySQL','2019-08-10 04:12:58'),(287512265581555720,'用户权限',287456761731772600,'134','MySQL','2019-08-10 04:12:58'),(287512265581555740,'数据库引擎',287512265581555714,'141','MySQL','2019-08-10 04:12:58'),(287512265581555750,'存储过程',287512265581555714,'142','MySQL','2019-08-10 04:12:58'),(287512265581555760,'触发器',287512265581555714,'143','MySQL','2019-08-10 04:12:58'),(287600438802280448,'视图',287512265581555714,'144','MySQL','2019-08-10 04:12:58'),(287606829403238400,'事务',287512265581555714,'145','MySQL','2019-08-10 04:12:58'),(287606829403238500,'MySQL调优',287200745656053760,'15','MySQL','2019-08-10 04:12:58'),(287957523322793984,'MyFiles',0,'1','MyFiles','2019-08-10 04:12:58'),(287957628796956672,'个人信息',287957523322793984,'11','MyFiles','2019-08-10 04:12:58'),(287960981564190720,'项目经历',287957523322793984,'12','MyFiles','2019-08-10 04:12:58'),(288305142666522624,'面向对象',283963385795473408,'102','JavaSE','2019-08-10 04:12:58'),(288305142666522700,'常用类',283963385795473408,'103','JavaSE','2019-08-10 04:12:58'),(288305142666522800,'I/O 流',283963385795473408,'104','JavaSE','2019-08-10 04:12:58'),(288305142666522900,'异常处理',283963385795473408,'105','JavaSE','2019-08-10 04:12:58'),(289376422903836672,'概述',287200950493278208,'11','NoSQL','2019-08-10 04:12:58'),(289404035772870656,'Redis',287200950493278208,'12','NoSQL','2019-08-10 04:12:58'),(289408880953159680,'概述',289404035772870656,'121','NoSQL','2019-08-10 04:12:58'),(289414388690874368,'命令',289404035772870656,'122','NoSQL','2019-08-10 04:12:58'),(289438180121145344,'配置',289404035772870656,'123','NoSQL','2019-08-10 04:12:58'),(289440211389018112,'持久化',289404035772870656,'124','NoSQL','2019-08-10 04:12:58'),(289471075917393920,'事务',289404035772870656,'125','NoSQL','2019-08-10 04:12:58'),(289472917942464512,'订阅发布',289404035772870656,'126','NoSQL','2019-08-10 04:12:58'),(289474290947878912,'主从复制',289404035772870656,'127','NoSQL','2019-08-10 04:12:58'),(289474380475297792,'Jedis',289404035772870656,'128','NoSQL','2019-08-10 04:12:58'),(289637599579893760,'消息队列',0,'1','Kafka','2019-08-10 04:12:58'),(289637599579893770,'Kafka',0,'2','Kafka','2019-08-10 04:12:58'),(289689056442216448,'集合框架',283963385795473408,'106','JavaSE','2019-08-10 04:12:58'),(289689362567688192,'多线程',283963385795473408,'107','JavaSE','2019-08-10 04:12:58'),(289689675425017856,'网络编程',283963385795473408,'108','JavaSE','2019-08-10 04:12:58'),(289689726427754496,'Java 特性',283963385795473408,'109','JavaSE','2019-08-10 04:12:58'),(289692097304227840,'面试题',287957523322793984,'13','MyFiles','2019-08-10 04:12:58'),(289700998506508288,'Java虚拟机',0,'1','JVM','2019-08-10 04:12:58'),(290016802041131008,'ZooKeeper',0,'1','ZooKeeper','2019-08-10 04:12:58'),(290016907565625344,'概述',290016802041131008,'11','ZooKeeper','2019-08-10 04:12:58'),(290071254609588224,'原理',290016802041131008,'12','ZooKeeper','2019-08-10 04:12:58'),(290084054585208832,'操作命令',290016802041131008,'13','ZooKeeper','2019-08-10 04:12:58'),(290084132502794240,'API应用',290016802041131008,'14','ZooKeeper','2019-08-10 04:12:58'),(291585438186893312,'概述',289700998506508288,'11','JVM','2019-08-10 04:12:58'),(291585637458276352,'内存结构',289700998506508288,'12','JVM','2019-08-10 04:12:58'),(291585682601570304,'垃圾回收',289700998506508288,'13','JVM','2019-08-10 04:12:58'),(292350110464897024,'类加载机制',289700998506508288,'14','JVM','2019-08-10 04:12:58'),(292419127003213824,'JVM 工具',289700998506508288,'15','JVM','2019-08-10 04:12:58'),(292547297379512320,'RegEx',0,'1','RegEx','2019-08-10 04:12:58'),(292569194980864000,'JavaEE',0,'1','JavaEE','2019-08-10 04:12:58'),(292643413399859200,'Spring Cloud',0,'1','Spring Cloud','2019-08-10 04:12:58'),(292643476800958464,'概述',292643413399859200,'11','Spring Cloud','2019-08-10 04:12:58'),(293086936796393472,'Eureka',292643413399859200,'12','Spring Cloud','2019-08-10 04:12:58'),(293133096366010368,'Ribbon',292643413399859200,'13','Spring Cloud','2019-08-10 04:12:58'),(293177554998554624,'Feign',292643413399859200,'14','Spring Cloud','2019-08-10 04:12:58'),(293274311803695104,'Hystrix',292643413399859200,'15','Spring Cloud','2019-08-10 04:12:58'),(293301929030610944,'Zuul',292643413399859200,'16','Spring Cloud','2019-08-10 04:12:58'),(293343993759952896,'Config',292643413399859200,'17','Spring Cloud','2019-08-10 04:12:58'),(293465793894445056,'设计原则',0,'1','Design Pattern','2019-08-10 04:12:58'),(293465959888220160,'设计模式',0,'2','Design Pattern','2019-08-10 04:12:58'),(293466724669222912,'创建型',293465959888220160,'21','Design Pattern','2019-08-10 04:12:58'),(293466805917085696,'结构型',293465959888220160,'22','Design Pattern','2019-08-10 04:12:58'),(293466863634903040,'行为型',293465959888220160,'23','Design Pattern','2019-08-10 04:12:58'),(295461276368138240,'JDBC',283963385795473408,'110','JavaSE','2019-08-10 04:12:58'),(296098831367303168,'索引',287512265581555714,'145','MySQL','2019-08-10 04:12:58'),(296115674555510500,'SQL语句和索引',287606829403238500,'151','MySQL','2019-08-10 04:12:58'),(296115674555510600,'表结构优化',287606829403238500,'152','MySQL','2019-08-10 04:12:58'),(296115674555510784,'配置及硬件',287606829403238500,'152','MySQL','2019-08-10 04:12:58'),(298422909654704128,'Linux',0,'1','Linux','2019-08-10 04:12:58'),(298772070904274944,'简介',298422909654704128,'11','Linux','2019-08-10 04:12:58'),(298889203055239000,'系统安装',298422909654704128,'12','Linux','2019-08-10 04:12:58'),(298889203055239095,'vi 编辑器',298422909654704128,'13','Linux','2019-08-10 04:12:58'),(298889203055239100,'实用指令',298422909654704128,'14','Linux','2019-08-10 04:12:58'),(299298154733281280,'HTML',0,'2','HTML','2019-10-29 14:05:04'),(299298744272068608,'HTML 基础',299298154733281280,'11','HTML','2019-08-10 04:12:58'),(299317853919551488,'CSS',0,'1','CSS','2019-08-10 04:12:58'),(299318043602755584,'CSS 基础',299317853919551488,'11','CSS','2019-08-10 04:12:58'),(299318150809165824,'CSS 样式',299317853919551488,'12','CSS','2019-08-10 04:12:58'),(299318210791907328,'CSS 位置',299317853919551488,'13','CSS','2019-08-10 04:12:58'),(299648487987830210,'基础指令',298889203055239100,'131','Linux','2019-08-10 04:12:58'),(299648487988830200,'功能指令',298889203055239100,'131','Linux','2019-08-10 04:12:58'),(299648487988830208,'用户权限',298889203055239100,'132','Linux','2019-08-10 04:12:58'),(299687534769643520,'文件文本',298889203055239100,'133','Linux','2019-08-10 04:12:58'),(299968191760605184,'进程管理',298889203055239100,'135','Linux','2019-08-10 04:12:58'),(299969176256028672,'软件安装',298889203055239100,'136','Linux','2019-08-10 04:12:58'),(300045831431430100,'Shell',0,'2','Linux','2019-08-10 04:12:58'),(300045831431430144,'Shell 概述',300045831431430100,'21','Linux','2019-08-10 04:12:58'),(300046265172795392,'Shell 基础',300045831431430100,'22','Linux','2019-08-10 04:12:58'),(300289641222676480,'Shell 语法',300045831431430100,'23','Linux','2019-08-10 04:12:58'),(301059309214539776,'Idea',287957523322793984,'14','MyFiles','2019-08-10 04:12:58'),(302152276897603584,'概述',289637599579893770,'21','Kafka','2019-08-10 04:12:58'),(302501160253562880,'工作流程',289637599579893770,'22','Kafka','2019-08-10 04:12:58'),(302511004901613568,'API 实战',289637599579893770,'23','Kafka','2019-08-10 04:12:58'),(302518227996418048,'配置信息',289637599579893770,'24','Kafka','2019-08-10 04:12:58'),(302520070348644352,'拦截器',289637599579893770,'25','Kafka','2019-08-10 04:12:58'),(302520162526863360,'Kafka Streams',289637599579893770,'26','Kafka','2019-08-10 04:12:58'),(302520687695667200,'分布式',0,'1','Dubbo','2019-08-10 04:12:58'),(302596962502221824,'Dubbo',0,'2','Dubbo','2019-08-10 04:12:58'),(302604718965694464,'概述',302596962502221824,'21','Dubbo','2019-08-10 04:12:58'),(302936523870740480,'Dubbo 配置',302596962502221824,'22','Dubbo','2019-08-10 04:12:58'),(304777444979548160,'Employment',0,'1','Employment','2019-08-10 04:12:58'),(304778037714395126,'个人信息',304777444979548160,'11','Employment','2019-08-10 04:12:58'),(304778037714395136,'职业规划',304777444979548160,'12','Employment','2019-08-10 04:12:58'),(304796631336656876,'简历',304777444979548160,'13','Employment','2019-08-10 04:12:58'),(304796631336656880,'面试',304777444979548160,'14','Employment','2019-08-10 04:12:58'),(304796631336656886,'准备工作',304796631336656880,'141','Employment','2019-08-10 04:12:58'),(304962812706201600,'面试',304796631336656880,'142','Employment','2019-08-10 04:12:58'),(305159181966417920,'收尾工作',304796631336656880,'143','Employment','2019-08-10 04:12:58'),(305173532265848832,'关于offer',304777444979548160,'15','Employment','2019-08-10 04:12:58'),(306214568429789184,'Context',0,'1','Context','2019-08-10 04:12:58'),(306214857434112000,'并发编程',0,'2','JavaSE','2019-08-10 04:12:58'),(309278468985495552,'Git/GitHub',0,'1','Git/GitHub','2019-08-10 04:12:58'),(309280225044111360,'概述',309278468985495552,'11','Git/GitHub','2019-08-10 04:12:58'),(309288856988852224,'工作流程',309278468985495552,'12','Git/GitHub','2019-08-10 04:12:58'),(309295405190782976,'基本操作',309278468985495552,'13','Git/GitHub','2019-08-10 04:12:58'),(310774903040024576,'远程仓库',309278468985495552,'14','Git/GitHub','2019-08-10 04:12:58'),(311119956631527424,'Eclipse 插件',309278468985495552,'15','Git/GitHub','2019-08-10 04:12:58'),(311301388918235136,'GitLab 服务器',309278468985495552,'16','Git/GitHub','2019-08-10 04:12:58'),(315070609460465664,'Kettle',0,'1','Kettle','2019-08-19 16:29:38'),(318698313921155072,'TortoiseGit',0,'2','Git/GitHub','2019-08-10 04:12:58'),(318698504812318720,'使用指南',318698313921155072,'21','Git/GitHub','2019-08-10 04:12:58'),(318728151894892524,'概述',315070609460465664,'11','Kettle','2019-08-10 04:12:58'),(318728151894892534,'ETL',318728151894892524,'111','Kettle','2019-08-10 04:12:58'),(318728151894892544,'Kettle',318728151894892524,'112','Kettle','2019-08-10 04:12:58'),(318728726812336128,'抽取 - Extract',315070609460465664,'12','Kettle','2019-08-10 04:12:58'),(318729439978233856,'转换 - Transform',315070609460465664,'13','Kettle','2019-08-10 04:12:58'),(318729562703568896,'加载 - Load',315070609460465664,'14','Kettle','2019-08-10 04:12:58'),(318729562703568900,'插件',315070609460465664,'15','Kettle','2019-09-07 12:56:21'),(319463499105083392,'管理 ETL 环境',315070609460465664,'16','Kettle','2019-09-07 12:56:24'),(319999019333754880,'Eclipse',0,'1','Eclipse','2019-08-10 04:12:58'),(319999186439020544,'使用指南',319999019333754880,'11','Eclipse','2019-08-10 04:19:58'),(323467252497948672,'性能和扩展性',315070609460465664,'17','Kettle','2019-09-07 12:56:26'),(323753503372128256,'高级主题',315070609460465664,'18','Kettle','2019-09-07 12:56:29'),(325460365575757824,'Hive',0,'1','Hive','2019-08-25 04:30:08'),(325466112309108736,'概述',325460365575757824,'11','Hive','2019-08-25 04:52:58'),(325629634842238976,'安装配置',325460365575757824,'12','Hive','2019-08-25 15:42:45'),(325973663496839168,'数据类型',325460365575757824,'13','Hive','2019-08-26 14:29:47'),(326341470822637500,'数据表分类',325460365575757824,'14','Hive','2019-08-29 13:52:23'),(326341470822637568,'HQL 语法',325460365575757824,'15','Hive','2019-08-29 13:49:26'),(326341992145264640,'定义语句 - DDL',326341470822637568,'151','Hive','2019-08-29 13:49:30'),(326342117554954240,'操纵语句 - DML',326341470822637568,'152','Hive','2019-08-29 13:49:32'),(326342268075941888,'查询语句 - DQL',326341470822637568,'153','Hive','2019-08-29 13:49:34'),(327807873220124672,'常用函数',326341470822637568,'154','Hive','2019-09-05 15:44:38'),(329616486255337472,'定义函数',326341470822637568,'155','Hive','2019-09-05 15:47:08'),(329630677280268288,'压缩存储',325460365575757824,'16','Hive','2019-09-05 16:42:04'),(329630774462291968,'性能调优',325460365575757824,'17','Hive','2019-09-05 16:41:51'),(330298965706448896,'其他',315070609460465664,'19','Kettle','2019-09-07 12:57:00'),(334322963176005632,'Hadoop',0,'1','Hadoop','2019-09-18 15:26:56'),(334323611258888192,'大数据',334322963176005632,'11','Hadoop','2019-09-18 15:54:08'),(349159910239150080,'前言',0,'1','HTML','2019-10-29 14:26:11');
/*!40000 ALTER TABLE `catalog_info` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-11-04  1:04:38
